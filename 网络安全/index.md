# Web前端安全之XSS和CSRF


## Web前端安全之XSS和CSRF

### 写在前面

昨晚（2021 / 11 / 2），面试有赞实习，面试官提问了XSS和CSRF，从没了解过的我只能尴尬地回答：“不好意思，我没有了解过相关的知识”。那么什么是XSS和CSRF，今天就必须给他搞懂了！

### XSS

#### XSS是什么

**跨站脚本攻击（Cross-site scripting，XSS）**是一种安全漏洞，攻击者可以利用这种漏洞在网站上**注入恶意的客户端代码**。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。XSS 在 2017 年被认为 [7 种最常见的 Web 应用程序漏洞之一](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))。这种攻击的主要目的是窃取其他用户的身份数据——cookie、会话令牌和其他信息。在大多数情况下，这种攻击是用来窃取其他人的 cookie。 大多数情况下，这种攻击是通过 Javascript 和 HTML 完成的。

**XSS 的本质**是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

#### XSS攻击的类型

##### 存储型

1. 攻击者将恶意代码**提交到目标网站的数据库**中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，**拼接在 HTML 中返回给浏览器**。
3. 用户浏览器接收到响应后解析执行，混在其中的**恶意代码也被执行**。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于**带有用户保存数据的网站功能**，如论坛发帖、商品评论、用户私信等。

##### 反射型

1. 攻击者构造出**特殊的 URL，其中包含恶意代码**。
2. 用户打开带有恶意代码的 URL 时，**网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器**。
3. 用户浏览器接收到响应后解析执行，混在其中的**恶意代码也被执行**。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：**存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL** 里。

反射型 XSS 漏洞常见于**通过 URL 传递参数的功能**，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段**诱导用户点击**。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

##### DOM型

1. 攻击者构造出**特殊的 URL，其中包含恶意代码**。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行**。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，**取出和执行恶意代码由浏览器端完成**，属于前端 JavaScript **自身的安全漏洞**，而其他两种 XSS 都属于服务端的安全漏洞。

#### 如何防范XSS

现在，我们已经了解了XSS攻击的两大要素

- 攻击者提交恶意代码
- 浏览器执行恶意代码

我们就可以针对这两大要素进行防护

##### 输入过滤

输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。但对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。

##### 预防存储型和反射型

存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。对此有两种解决方案

###### 纯前端渲染

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

###### HTML转义

使用转义库，在不同的上下文里应用不同的转义规则。

##### 预防DOM型

DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，一定要避免在字符串中拼接不可靠数据

##### 其他通用措施

- Content Security Policy
- 输入内容长度控制
- 禁止JavaScript读取cookie
- 验证码，防止脚本模拟用户

#### 如何检测XSS

1. 使用通用 XSS 攻击字符串手动检测 XSS 漏洞。
2. 使用扫描工具自动检测 XSS 漏洞。

#### 总结

很难通过技术手段完全避免XSS攻击，但要遵守以下原则来避免漏洞的产生

- **利用模板引擎** 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 `<%= data %>` 而不是 `<%- data %>`； 在 doT.js 中，尽量使用 `{{! data }` 而不是 `{{= data }`； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 `freemarker.core.OutputFormat`。

- **避免内联事件** 尽量不要使用 `onLoad="onload('{{data}}')"`、`onClick="go('{{action}}')"` 这种拼接内联事件的写法。在 JavaScript 中通过 `.addEventlistener()` 事件绑定会更安全。

- **避免拼接 HTML** 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 `createElement`、`setAttribute` 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。

- **时刻保持警惕** 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。

- **增加攻击难度，降低攻击后果** 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。

- **主动检测和发现** 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。

### CSRF

#### 什么是CSRF

**CSRF（Cross-site request forgery）跨站请求伪造**：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

- 攻击一般发起在**第三方网站**，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的登录凭证，**冒充受害者提交操作**；而不是直接窃取数据。
- 整个过程攻击者**并不能获取到受害者的登录凭证，仅仅是“冒用”**。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

**CSRF通常是跨域的**，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。

#### CSEF攻击的类型

##### GET类型

##### POST类型

##### 链接类型

#### 如何防范CSRF

CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。

我们已经了解到：

- CSRF（通常）发生在第三方域名。
- CSRF攻击者不能获取到Cookie等信息，只是使用。

我们可以针对这两点来制定防护策略：

- **阻止不明外域的访问**
  - 同源检测
  - Samesite Cookie
- **提交时要求附加本域才能获取的信息**
  - CSRF Token
  - 双重Cookie验证

#### 总结

- CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。
- CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。
- 保证页面的幂等性，后端接口不要在GET页面中做用户操作。

### 附录

[一个有趣的练习XSS攻击的网站](https://xss-game.appspot.com)

