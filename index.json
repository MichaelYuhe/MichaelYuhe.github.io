[{"categories":["面经"],"content":"阿里云OpenAPI一面 绩点，排名，相关课程 面试官：你们绩点也太高了，这才百分三十几吗 自我介绍，要求介绍自己的优势 说自己学习能力强，上手快 简单介绍一下各种排序 名称和复杂度就可以了 详细介绍快排 时间复杂度的情况，时间复杂度和什么有关 数组的各种方法 slice和splice 哪些改变原数组 尽可能多说 React的hooks 说自己只用过useState和useEffect Node.js 用什么框架，文件操作用过吗 算法 两题都是快慢指针，秒了 DFS和BFS 数据结构 区别 用途 填充颜色用哪个 Flex布局讲一下 居中 space-between和space-around的区别 COCOS架构 。。。 小游戏亮点 讲了环保理念 反问 做的是IT自动化，开放api的整个生命周期的管理 对我有什么建议 “整体面下来，在大家的横向比较中，你的前端经验算是比较丰富的，也比较有逻辑性” “需要有一棵属于自己的前端知识树，查缺补漏” ","date":"2022-02-14","objectID":"https://MichaelYuhe.github.io/%E9%98%BF%E9%87%8C%E4%BA%91openapi%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"阿里云OPENAPI前端实习_一面","uri":"https://MichaelYuhe.github.io/%E9%98%BF%E9%87%8C%E4%BA%91openapi%E4%B8%80%E9%9D%A2/"},{"categories":["生活"],"content":"实习总结 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:0","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"写在前面 11.16进入入职，1.15离职，不算考试周，刚好凑足了两个月。交完电脑工牌，签了离职文件，最后和大家合照，就正式离开这第一个收留我的公司，离开两个月间朝夕相处的大家。 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:1","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"实习干了什么 两个月时间，做的工作有限。 支付运营平台搜索体验优化。 本来的搜索体验很差，UI也挺离谱。入职第二天就接需求优化这个体验。把搜索改为了全局聚焦搜索框，增加了快捷键，美观、快捷，顺便修复了一点遗留的bug。 小猫咪组件升级 小猫咪用的还是好几年前的zent6，需要把组件库升级到zent9。跨越了三个大版本，有一些破坏性的改动，“牵一发而动全身”，升级组件不像自己想象的那么简单。比如filter、selector等涉及到数据的组件，组件库升级过程中需要把原来定义的数据结构、函数也做相应的修改。对没有学过react和typescript的我是一个挺大的挑战。 对接V2应用日志 简单地换个接口，换套参数，加上token来对接V2天网。然后根据天网的搜索来改进前端的输入和体验 后端应用日志治理 这个任务花费了最长的时间。本来小猫咪只支持前端应用的日志治理。首先说后端部分。后端部分，需要每天自动获取一次token，然后携带token发送请求，获取对应应用的天网日志。拿到天网日志以后，对日志进行治理，根据前端所设定的规则来匹配，匹配到得则数量累加，若有日志没有匹配到则计入unknown。统计完成后，存入线上的数据库，同时还需要支持对这些日志的状态的管理。前端部分的话，最主要的就是在增添机器人配置时，支持用户自定义配置一些规则，规则用正则匹配，如果是tag则使用对象相等的方法，用户可以拖拽改变规则的优先级。 机器人自动通知错误信息 治理完了日志，还是不够完美：想看错误信息一样要自己登录小猫咪去看。为了解决这个问题，在配置机器人时可选填入机器人url，支持飞书机器人和企业微信机器人，利用飞书和企业微信的api，将每日报错的信息统计，在次日九点发送到对应的群组，方便大家应用日志治理。 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:2","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"思考 实习期间，除了coding这种基础能力的提升，最主要的还是接触到了生产环境的工作流程，有许多的思考。 扩展性。写出的程序应该具有扩展性，不能只是局限于眼前的功能，还要考虑到程序的扩展性，是否能只是单纯地修改几个参数就能扩展到其他应用，解决其他需要求？ 低耦合性。大型的应用，数据往往很多很杂，一处改动可能会影响到很多地方。写代码时要注意尽量保持低耦合。 多人协作。首先，需要保持良好的注释习惯。大型应用不可能一个人独立开发，退一万步，离职了也有人会来接受，良好的注释习惯就能帮助其他人阅读自己的代码。接手的都是0注释的代码，给我整蒙了。其次，规范commit。不要乱提commit，方便回溯。 先确定需求再写代码，可以省下许多无用功，提高效率。 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:3","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"实习一月小结 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:0","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"写在前面 抱着试试看＋练习面试的想法，冲刺了几天面经，参与了几家公司的面试。只能说基础太不扎实了，许多js的基本问题都不能回答出来。 最后，经过三轮技术面＋HR面，拿到了人生第一份offer——有赞前端实习生。对于这个offer还是很满意的~ 毕竟学习前端算上来也就三个多月，再者有赞的前端实力还是很强的，于是就接受了这个offer（虽然钱少了点，200 + 50饭补） 11.16，正式入职有赞。开启了一段全新的旅程。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:1","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"入职体验 入职第一天，大家就一起出去吃了顿饭，介绍了一下自己，也初步认识了大家。大家给我的第一印象都很好，热情、随和，让我消去了刚入职的迷茫和些许焦虑、慌张。组里除了我还有两个实习生，小有和小赞😂 第一天，领取了Macbook Pro；第二天，领取了显示器；真香！不得不说，显示器的体验实在太好了~ 至于mac和windows，见仁见智，我还是比较喜欢windows。 第一天配置好了环境，本以为接下来的几天就是让我自己熟悉代码摸索摸索，没想到直接来了一个小需求😂 —— 支付运营平台的搜索样式优化。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:2","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"第一个任务 从gitLab拉来代码，庞大的代码量让人头疼，React，TypeScript，不好意思没有学过；还有闻所未闻的njk等东西，定位代码就花了一小段时间，需要改的代码都在njk模板里。 还好，需求本身并不难。在前人代码的基础上进行一些小的修改和优化即可。代码古老，用的还是JavaScript直接操作DOM的方法。也好，给没学过React和TypeScript的我一些缓冲时间。 一顿操作猛如虎，当天下午就做好了初版。虽然只是初版，但可能是为了让我熟悉熟悉发布流程，有伴直接教我如何发布自己刚刚的修改。不得不说，这一套发布流程还是蛮复杂的。单是搞懂各种环境的区别、ZanProxy的配置、各种平台的使用、Code Review、Merge Request等等等等。一个月的工作过后，现在可以说从Git小白变成已经掌握了Git的各种常见操作，也可以利用Git来进行协作开发。合过分支、解决过冲突…… 自测没发现什么问题，直接提交发布单发布到了生产环境。结果因为快捷键设置得不合理，刚发布没多久就有人在群里提出了问题。回滚。再提交，又有问题。回滚。 这么简单的东西，回滚了两次😂 最后自己认真地重新修改了一下，也删除了冗余代码，修复了一个前人遗留的bug，样式也做了更细节的优化，如圆角和颜色等，经过各页面详细的自测，再提交发布单，终于没有问题，也得到了比较好的反馈。 简单总结一下，第一个任务没有什么技术上的难度，但是收获了一些经验和教训。比如，在这种已经维护了好几年的大型项目中修改或者增加功能时，不能只看到自己的那一部分，牵一发而动全身，需要考虑到已有的代码和逻辑。再就是不能像自己搞项目一样随意提交代码，毕竟做的东西是给许多人使用的，稍有不慎就会影响到很多人的体验。 任务中学到的CSS小技巧： 当Icon库里没有你想要的图标、公司又不允许引用外部样式时，就需要自己网上搜寻或制作一个PNG图标，放到图床上使用。而本次任务中的搜索图标就是这种形式来引用的。但当搜索激活时，要求有图标从灰色变成白色的效果，难道我要传两张PNG图标，一灰一白？这不合理，而且这样无法达到完美的过渡效果，灰色直接切到白色会比较生硬。其实可以通过CSS来直接改变PNG图片的颜色。 filter: brightness(90); brightness的数值设置为100，亮度调到最高，自然就是白色；设成0，就是黑色。原理就不在此细讲了，贴个链接。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:3","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"第二个任务 接下来接的任务就是和小猫咪平台有关的。小猫咪是我们部门开发的一个机器人，可以抓取日志，提醒相应负责人，也可以设置值班顺序，在企业微信群里自动艾特并通知对应人员……是一个功能比较完善了的机器人，现在公司希望我们将其做成可自定义配置的，让所有部门都可以很方便的接入使用。 目前小猫咪只能读取天网V1的日志，然而日志已经在全面迁移到V2，2022年将不再维护V1的日志，这个功能再不改就会失效。 于是接到了一个需求：让小猫咪接入天网V2的日志系统。 要解决一个需求，需要先调研这个需求能否完成。找到对应负责人，加了天网服务群，天网API群等等，调研结果是小猫咪有能力实时获得天网日志，但数量庞大，无法存储在自身数据库。 接下来就是实现获取天网V2的日志。实现也很简单，就是一个基础的网络请求，拿到的数据做一定的解析即可。 说来惭愧，这竟是我第一次做ajax网络请求…… 好在功能很快就顺利完成了。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:4","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"第三个任务 接下来的任务就比较困难了一点：给小猫咪全面升级zent9。zent是有赞自己研发的React组件库，小猫咪是三年前开发的，使用的还是zent6，现在需要进行升级。 然而升级组件库并没有想象中的简单。对于那些只改变了样式的组件，比如按钮、提示框等等，一键升级就完事。 但对于一些“破坏性升级”的组件，就比较麻烦。例如，zent9重写了各个选择器，如基本的select，还有时间选择器DatePicker等一系列衍生组件。由于重写组件，内部逻辑被改变了，数据接口和返回的数据都得做相应更改。加上全面TS化，有更严格的类型检查，从没接触过TS的我，最开始是真的一脸懵逼。花大半天时间，学习了解了TypeScript，就开始着手进行升级。 升级过程中，也对React的单向数据流有了更深的理解。（以前好像也理解过 三天时间，和另一位实习生，也是大三，两个人合作全面升级了小猫咪的zent版本，顺带还升级了各种依赖和TS的版本，对一些样式也做了优化。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:5","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"满月 不知不觉，写了四次周报了。也意味着在有赞已经实习满一个月了。 一个月以来，似乎也没干什么活，主要还是在熟悉代码熟悉流程，带薪学习React和TS😂 最主要的感受：我一定要找955的大外企😂 在有赞，每周三五是六点下班，其他都是九点下班；早上十点前到就可以，晚一点也没事；中午也有午休时间。实际工作时长确实不多，但有一种公司把自己拴住了的感觉。九点下班以后，也很难再有自己的生活。 可能是现在比较累吧。又要实习，又要兼顾学校的课程。要是正式工作了，可能周末就可以好好放松，而不是像现在，周末恶补学校课程和作业…… 没时间学英语，没时间刷Leetcode，不禁怀疑自己做出了错误的选择。想出国，或是进外企，除了前端的技术能力，一样很看重英语和算法能力。而这两个能力自己都比较缺乏。 同时，没有时间做自己的项目。以前没有实习时，虽然比较没有方向比较迷茫，但可以自由学习各种知识，想做什么就去做什么。现在了解了更多新的技术，例如区块链，也有许多项目想法，但都没有时间去做。还想学吉他，想学投资，想好好享受校园生活，想天天练球，想旅游，想学摄影，想学英语…… 下学期是否还要实习，需要好好思考一下了。 是珍惜校园时光，自由地学习；还是继续实习，为简历增色，便于找到更好的工作…… 得好好思考一下自己真正想要的东西了。 先赶大作业去了。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:6","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["面经"],"content":"滴滴日常实习一面 10月30日 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"自我介绍 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:1","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"项目 小游戏的难点，做了些什么，登陆相关 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:2","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"CSS 盒模型 怎么居中，尽可能多方法 flex布局讲一下 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:3","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Javascript reduce用过吗 数组的map和forEach的区别 数据类型和判断方法，typeof和instanceof的区别 打乱一个数组 var、let、const ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:4","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Vue 双向绑定原理，具体到源码 组件通信方式 data为什么是函数不是对象 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:5","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"总结 一些简单的问题都没答好，感觉面试官已经放了点水了，但没想到我仍是没答对。以及简历的“阅读过Vue部分源码就是在给自己挖坑” 面试官建议：项目经验已经足够了，现在需要巩固基础和做一些单纯技术导向的项目，努力在一个项目用到尽可能多的东西。 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:6","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"有赞日常实习二面 11月4号 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:0","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"自我介绍 然后问了专业相关，聊到下学期才上计网，于是“那我计网只问你一些基础的吧” ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:1","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"计算机网络 讲一下HTTP，讲一下和HTTPS的区别 DNS查询 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:2","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"JavaScript this相关，问的很细，很久，比如什么时候会导致this传错了，然后出了一些例题等等，还出了会报莫名其妙错的例题 数据类型，判断方法，问的很细，很久，比如改写toString，比如中途改变原型链 讲一下数字精度丢失，那我们怎么让0.1 + 0.2 === 0.3 异步的理解，async和await，底层原理，还有什么是异步的，引到并发并行，单线程，事件循环 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:3","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"Vue 对比传统开发有什么好处 讲一下双向绑定，讲一下双向绑定的缺点 操作真实DOM和虚拟DOM哪个快，为什么，数据量大时呢，数据量小时呢，不涉及重排重绘时呢，为什么呢 挂载发生了什么 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:4","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"项目 怎么和后端API交互的 todo实现了些什么 微信小游戏和其他前端项目的区别，登录怎么做的 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:5","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"HTML5 新特性 异步加载 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:6","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"其他 遇到不明报错该怎么做（搜索…） ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:7","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"反问 去做什么：他们部门是支付收银相关，但风险大的工作不会给实习生，去是做一些公司内部看的数据平台 学习建议：买书看，自己实习的时候可以边做项目，实现一些想法 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:8","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"有赞日常实习一面 11月2日 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"线上笔试 直播写代码 网站：showMeTheCode，有赞自己的平台 1、字符串相加 忘记处理最后一步的进位 /** * 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和 * * tips: 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 * * 示例输入: '197880986', '5112281222' * 示例输出: '5310162208' * */ var addStrings = function (num1, num2) { // code here let len1 = num1.length, len2 = num2.length let carry = 0, sum = 0 let res = [] while (len1 || len2) { if (len1 \u0026\u0026 len2) { sum = parseInt(num1[--len1]) + parseInt(num2[--len2]) + carry } else if (len1) { sum = carry + parseInt(num1[--len1]) } else { sum = carry + parseInt(num2[--len2]) } carry = 0 res.unshift(sum % 10) if (sum \u003e= 10) { carry = 1 } } return res.join('') }; console.log('result --\u003e ' + addStrings('197880986', '5112281222')); console.log('want ----\u003e ' + '5310162208'); console.log('[equal] -\u003e ' + (addStrings('197880986', '5112281222') === '5310162208')); 2、两个对象快速相等 /** * fastEqual 两个对象快速相等 * * 示例输入: a = { arr: [1, 2], num: 12 } b = { arr: [1, 2], num: 12 } * * 示例输出: true * * tips: 不需要考虑太多边界情况, 优先保证执行效率, 输入 a / b 可以是任意数据类型 */ function fastEqual(obj1, obj2) { // code here var o1 = obj1 instanceof Object; var o2 = obj2 instanceof Object; // 两个简单的判断 if (!o1 || !o2){ return obj1 === obj2 } if(Object.keys(obj1).length !== Object.keys(obj2).length){ return false; } // 循环看属性 for(var o in obj1){ var t1 = obj1[o] instanceof Object; var t2 = obj2[o] instanceof Object; // 如果都还是对象 if(t1\u0026\u0026t2){ if(!fastEqual(obj1[o],obj2[o])) { return false } } else if(obj1[o] !== obj2[o]){ return false; } } return true; } 3、解析URL 没有解码，callback输出错误 /** * 解析 URL 中的 Query String，返回一个对象 */ // 返回值示例： // { // name: 'coder', // age: '20'. // callback: 'https://youzan.com?name=test' // } const testURL = 'https://www.youzan.com?name=coder\u0026age=20\u0026callback=https%3A%2F%2Fyouzan.com%3Fname%3Dtest'; function parseQueryString(url) { // code here let res = {} // 分割 if (url.indexOf('?') === -1) { return res } let query = url.split('?')[1].split('\u0026') query.forEach((item) =\u003e { let temp = item.split('=') // 解码 res[temp[0]] = decodeURIComponent(temp[1]) }) return res; } console.log(\"====== QueryString Parser ======\") console.log(\"should --\u003e \" + JSON.stringify({ name: 'coder', age: '20', callback: 'https://youzan.com?name=test' })); console.log(\"[result] --\u003e \" + JSON.stringify(parseQueryString(testURL))); 总结：三道题都大概做出来了，但是都不完美 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:1","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"计算机网络 XSS、CSRF 讲讲非简单请求和简单请求 // 简单请求：同时满足两个条件 // 请求头是 HEAD,POST,GET（讲漏了POST） // 头信息不超出 Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain // 非简单请求的CORS请求，会在通信之前增加一个预检请求 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:2","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"浏览器 跨域，具体用过哪些，上线了还可以devServer吗 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:3","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Vue computed和watch的区别 vue-router的模式 ，底层原理 生命周期（父子组件间） ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:4","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"CSS position各种属性及其特点 居中 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:5","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Javascript 基本数据类型有哪几种 ，Symbol的具体作用 怎么判断是不是数组 // 答出来的 Object.prototype.toString.call(arr) Array.isArray(arr) arr instanceof Array // 其他的方法 arr.__proto__ === Array.prototype arr.constructor === Array async、await讲一下，和forEach连用会发生什么 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:6","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"其他 为什么选择前端 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:7","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"面试官的建议 学习网络相关的知识，包括网络安全 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:8","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["计算机网络"],"content":"Web前端安全之XSS和CSRF ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:0","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"写在前面 昨晚（2021 / 11 / 2），面试有赞实习，面试官提问了XSS和CSRF，从没了解过的我只能尴尬地回答：“不好意思，我没有了解过相关的知识”。那么什么是XSS和CSRF，今天就必须给他搞懂了！ ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:1","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"XSS XSS是什么 跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。XSS 在 2017 年被认为 7 种最常见的 Web 应用程序漏洞之一。这种攻击的主要目的是窃取其他用户的身份数据——cookie、会话令牌和其他信息。在大多数情况下，这种攻击是用来窃取其他人的 cookie。 大多数情况下，这种攻击是通过 Javascript 和 HTML 完成的。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 XSS攻击的类型 存储型 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 DOM型 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 如何防范XSS 现在，我们已经了解了XSS攻击的两大要素 攻击者提交恶意代码 浏览器执行恶意代码 我们就可以针对这两大要素进行防护 输入过滤 输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。但对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。 预防存储型和反射型 存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。对此有两种解决方案 纯前端渲染 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 HTML转义 使用转义库，在不同的上下文里应用不同的转义规则。 预防DOM型 DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，\u003ca\u003e 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，一定要避免在字符串中拼接不可靠数据 其他通用措施 Content Security Policy 输入内容长度控制 禁止JavaScript读取cookie 验证码，防止脚本模拟用户 如何检测XSS 使用通用 XSS 攻击字符串手动检测 XSS 漏洞。 使用扫描工具自动检测 XSS 漏洞。 总结 很难通过技术手段完全避免XSS攻击，但要遵守以下原则来避免漏洞的产生 利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 \u003c%= data %\u003e 而不是 \u003c%- data %\u003e； 在 doT.js 中，尽量使用 {{! data }} 而不是 {{= data }}； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。 避免内联事件 尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。 ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:2","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"CSRF 什么是CSRF CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 CSEF攻击的类型 GET类型 POST类型 链接类型 如何防范CSRF CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 我们已经了解到： CSRF（通常）发生在第三方域名。 CSRF攻击者不能获取到Cookie等信息，只是使用。 我们可以针对这两点来制定防护策略： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重Cookie验证 总结 CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。 CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。 保证页面的幂等性，后端接口不要在GET页面中做用户操作。 ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:3","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"附录 一个有趣的练习XSS攻击的网站 ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:4","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["知识点"],"content":"面试专用 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:0","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Web前端面试——面试官系列 简介 为语音打卡社群(JS每日一题)维护的前端面试题库，包含不限于Vue面试题，React面试题，JS面试题，HTTP面试题，工程化面试题，CSS面试题，算法面试题，大厂面试题，高频面试题 特点 资源很全，囊括了各个方面的知识点 阅读体验良好 语言通俗易懂 但会有一些小错误，需要自己注意 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:1","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"前端面试2021及答案 简介 个人按专题整理的面试题，均附上了答案和重要指数 特点 给每一项都进行了重要程度的评级 缺点是有些知识点讲的不够详细，但都会附上一些更详细的链接 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:2","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"前端面试真题 简介 一个介绍面试真题和经验的飞书文档 特点 以飞书文档的形式整理，可以管理个人进度 分模块、分题集 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:3","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"技术博客 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:2:0","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"冴羽的个人博客 ⭐ 简介 大佬的个人博客，包含四个系列，JavaScript深入系列、JavaScript专题系列、ES6系列、React系列。 特点 语言精练严谨 Javascript深入系列yyds 大佬人很好，会回答留言里的问题 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:2:1","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"阮一峰的网络日志 简介 ES6入门教程的作者，阮一峰大佬的个人博客，十分经典，除了有一些知识的讲解，也有许多好的分享 特点 能把知识点描述得通俗易懂且全面 现在在做科技爱好者周刊，每周五推送值得分享的科技内容 可以去看他开源的《ECMAScript6入门》作为ES6的入门学习资料 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:2:2","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"CSS \u0026 UI ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:0","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Uigradients 获取渐变色代码，提高背景逼格专用！ ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:1","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"CSSBattle 使用尽量简洁优美的CSS来完成任务！ ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:2","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"dribbble 一个汇聚许多优美的web设计的网站，独立开发时的UI灵感来源。 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:3","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Neumorphism 自动生成优雅的CSS代码，可以手动调节大小、圆角等参数。 Dunmmyimage 生成占位图。 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:4","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Navnav+ 许多优秀精美的CSS小组件 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:5","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["Program"],"content":"Node.js初体验 — nodemailer的使用 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:0","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"写在前面 需求：给自己的todo应用添加一个邮件提醒的功能，当创建了任务则会发送邮件至指定邮箱 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:1","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"历程 作为一个Node.js小白，其他网络的知识也几乎没接触过，踩了许多的坑。 首先，经网上查找，找到了nodemailer这个库，兴致勃勃地下载，根据官方文档配置使用，在本地node环境中成功发送了测试邮件。 但当我把它放到我基于vue框架的todo应用中时，运行却报错了。nodemailer**仅可以在node环境中使用！**也就意味着项目需要前后端分离，并且需要前端与后端的交互。 没错，就是这个问题，一个简单的前后端交互困扰了我一整天。 最开始，自信满满的我，由于想把自己的项目都部署上线，本就有购买服务器的想法，直接去腾讯云购买了一个轻量应用服务器。将服务器配置了Node.js的应用镜像，将之前在本地node环境中运行的代码部署在服务器上直接运行，成功发送邮件至指定邮箱。 接着，就是分析逻辑：我要做的事情，无非就是向服务器上传邮件具体内容到服务器，同时发起发送邮件的请求，达到前端填写内容，按下发送按钮，服务端即可发送邮件的效果。 要能够向服务器发起请求，显然首先要能够访问到该服务器。在vue中引入了axios（没错这也是我第一次使用它），向服务器发起一个简单的get请求，结果却抛出了错误 has been blocked by CORS policy。 这是由于请求是跨域进行的。跨域的原因和解决方案后续将在另一篇文章知识点总结中提到，此处仅关注这个需求。 Vue就自带了一个使用代理来解决跨域的方案。代理的作用：监测本地的接口，当接口为需要访问外网的接口时，代理替你访问这个接口并把返回值返回给当前网页 为方便测试，在本地起了一个node服务。 // app.js const express = require('express'); const app = express(); const email = require('./email'); app.get('/', (req, res) =\u003e { res.send('Hello') }) app.use('/email', email); // 监听端口3000 app.listen(3000, () =\u003e console.log('Service start at port 3000...')) // email.js const express = require('express'); const email = express.Router(); // 创建express路由 const nodemailer = require('nodemailer'); // 导入nodemailer const transporter = nodemailer.createTransport({ // 以qq邮箱为例 service: 'QQ', port: 465, secureConnection: true, auth: { user: '2312744987@qq.com', pass: '自行获取（SMTP授权码，而非邮箱密码）', } }); email.get('/', (req, res) =\u003e { const { to, html, subject } = req.query; // 将请求解构 const from = '\"XYH\"\u003c2312744987@qq.com\u003e'; const mailOptions = { from, to, subject, html, }; transporter.sendMail(mailOptions, (error, info) =\u003e { if (error) return console.log(error); console.log(info); }); }); module.exports = email; 在终端中输入命令 node app.js，即可在本地主机的3000端口启动服务。 那么在Vue中，如何配置代理呢？ 来到我们项目中的vue.config.js文件，添加以下代码。 devServer: { proxy: { 'test': { target: 'http://localhost:4000', changeOrigin: true, logLevel: 'debug', pathRewrite: {'^/test' : '/'} } } }, 那么当我们访问/api/xxxx接口时，webpack会识别到它是对外的接口，并访问target，将结果返回。接下来编写请求代码。 axios({ url: \"test/email\", method: \"get\", params: { to: \"xiayuhang1106@gmail.com\", subject: \"A New Task\", html: `\u003ch2\u003e${this.title}\u003c/h2\u003e \u003cp\u003econtent\u003cp/\u003e`, }, }) .then((res) =\u003e console.log(res)) .catch((err) =\u003e console.log(err)); 上述代码发送了一个携带参数的axios请求，请求发送至配置好的代理端口的email中，请求发送电子邮件。 点击发送后，服务端打印出邮件信息，代表发送成功。 查看我们的邮箱，也可以看到该新到达的热乎的邮件。 下一步，就是在服务器端复现这个功能，省去每次都需要自己在本地启动服务的步骤。 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:2","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"结语 这是第一次真正意义上的接触Node.js，前前后后摸索了一天半，也学习到了很多知识：跨域、Linux基本操作、服务器部署、axios等。最后也成功实现了发送邮件的功能，虽然不太实用，后期需要想办法修改为定时发送的服务，到了设定时间前一天再发送邮件提醒。 不得不感慨真的是学无止境呀。还有许多东西需要自己去慢慢学习。 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:3","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"年轻人的第一个项目 Vusic ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:0","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"项目简介 Vusic是一个使用Vue3作为框架的在线音乐播放器，目前仅适配了移动端，桌面版的适配工作正在进行中。后端采用QQ音乐API来获取歌曲等数据。 以下是Vusic各界面截图及功能介绍。 播放界面 【待补充】 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:1","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"开发中学到了什么 Composition API的使用 Vue3中新增了Composition API，代替之前的Options API，在逻辑、功能较多时，能使代码更简洁，有效降低耦合度，实现同一功能的代码分离到单独的文件，通过setup()调用以及返回到模板中，不需要再把所有data、所有methods等等都挤在同一个文件中。 代码复用和模块化的思想 当有一段代码需要用到多次，不应该复制粘贴，而是需要学会将其封装起来，以方便复用。 要将大的项目模块化，更有助于我们的开发。在进行项目的开发之前，根据设计图和设计框架进行分析抽象，通过对结构和功能的划分来划分出具体的相应的模块。 学会封装一些基础的组件作为基本的模块，其他组件可能就只需要由已经封装好的基础组件拼装而成，不需要重新编写界面和逻辑。就如本项目中的音乐列表界面，可以从排行榜、歌手详情、推荐歌单等等进入，皆是他们的子路由，封装成基础组件，就减少了许多重复的工作。 而同一模块的代码和文件应该统一存放在一个文件夹中，方便代码的管理。 Sass的使用 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库有助于更好地组织管理样式文件，以及更高效地开发项目。 后端接口的使用及数据的处理 后端数据由QQ音乐API获取 // 对 axios get 请求的封装 function get(url, params) { return axios.get(url, { headers: { referer: 'https://y.qq.com/', origin: 'https://y.qq.com/' }, params: Object.assign({}, commonParams, params) }) } // 对 axios post 请求的封装 function post(url, params) { return axios.post(url, params, { headers: { referer: 'https://y.qq.com/', origin: 'https://y.qq.com/', 'Content-Type': 'application/x-www-form-urlencoded' } }) } 性能优化 keep-alive 使用Vue的keep-alive，缓存访问过的路由，有效地避免切换路由时重复多余的网络请求。 \u003crouter-view v-slot=\"{ Component }\"\u003e \u003ckeep-alive\u003e \u003ccomponent :is=\"Component\"/\u003e \u003c/keep-alive\u003e \u003c/router-view\u003e 异步加载路由组件 用工厂模式导入路由组件，使路由组件达到按需加载的效果。 const Singer = () =\u003e import('@/views/Singer'/* webpackChunkName: \"singer\" */) 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令 本项目中，创建了三个自定义指令。v-lazy和v-loading和v-no-result 注册指令： 使用Vue.directive('command name')来全局注册指令 钩子函数 一个指令定义对象可以提供以下几个钩子函数 bind：只调用一次，在指令第一次绑定到元素时调用 inserted：被绑定元素插入父节点时调用 update：所在组件的VNode更新时调用 componentUpdated：指令所在组件的VNode和其子VNode全部更新后调用 unbind：只调用一次，解绑时调用 钩子函数参数 el：指令所绑定的元素，可以用它来操作DOM binding：一个包含传递给钩子的参数的对象。有许多可用的参数，包括name，value，oldValue，expression，arg和modifiers。 vnode：Vue编译生成的虚拟节点 oldVnode：上一个虚拟节点 自定义指令实例： 以本项目中自定义组件为例。由于几个自定义指令的逻辑大体相同，将其封装为createLoadingLikeDirective文件。 // 创造自定义指令 export default function createLoadingLikeDirective(Comp) { return { mounted(el, binding) { const app = createApp(Comp) const instance = app.mount(document.createElement('div')) const name = Comp.name if (!el[name]) { el[name] = {} } el[name].instance = instance const title = binding.arg if (typeof title !== 'undefined') { instance.setTitle(title) } if (binding.value) { append(el) } }, updated(el, binding) { const title = binding.arg const name = Comp.name if (typeof title !== 'undefined') { el[name].instance.setTitle(title) } if (binding.value !== binding.oldValue) { binding.value ? append(el) : remove(el) } } } function append(el) { const name = Comp.name const style = getComputedStyle(el) if (['absolute', 'fixed', 'relative'].indexOf(style.position) === -1) { appendClass(el, relativeCls) } el.appendChild(el[name].instance.$el) } function remove(el) { const name = Comp.name removeClass(el, relativeCls) el.removeChild(el[name].instance.$el) } } ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:2","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"开发中的难点 【待补充】 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:3","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"todos 支持创建歌单 Material you设计 主题的切换 自动取色功能 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:4","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"下一阶段该做的事情 开发新的项目。项目选题：Material Vue（Vue项目样式改变的组件）/ 自定义生成头像的网站 / 记账工具； 学习计算机网络的知识 深入学习JavaScript ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:5","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["知识点"],"content":"知识点总结 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:0:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"Javascript ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下闭包 闭包的定义 闭包是指那些能够访问自由变量的函数。 那么什么是自由变量？自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 可以看出，闭包 = 函数 + 函数能够访问的自由变量 所以，从技术的角度讲，所有的JavaScript函数都是闭包。 从实际出发： 即使创建它的执行上下文已经被销毁了，但它还是存在； 在其中引用了自由变量 var data = [] for(var i = 0; i \u003c 3; i++) { data[i] = function() { console.log(i) } } data[0]() // 3 data[1]() // 3 data[2]() // 3 // 使用闭包 var data = [] for(var i = 0; i \u003c 3; i++) { data[i] = (function(i) { return function() { console.log(i) } }) } data[0]() // 0 data[1]() // 1 data[2]() // 2 // var改成let也可以 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"原型和原型链 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下继承 1.原型链继承 function Parent() { this.name = 'Michael' } Parent.prototype.getName = function() { console.log(this.name) } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.getName() // 'Michael' 缺陷： 引用类型的属性被所有实例共享 function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+', 'Lily'] 在创建Child实例时不能向Parent传参 2.借用构造函数（经典继承） function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { Parent.call(this) } var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+'] 优点： 避免了引用类型的属性被所有实例共享 可以在Child中向Parent传参 function Parent (name) { this.name = name } function Child (name) { Parent.call(this, name) } var child1 = new Child('kevin') console.log(child1.name);// kevin var child2 = new Child('daisy') console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法 3.组合继承 function Parent() { this.name = name this.colors = ['black', 'pink'] } Parent.prototype.getName = function() { console.log(this.name) } function Child(name, age) { Parent.call(this, name) this.age = age } Child.prototype = new Parent() Child.prototype.constructor = Child var child1 = new Child('Lily', 18) child1.colors.push('blue') console.log(child1.name) // Lily console.log(child1.age) // 18 console.log(child1.colors) // ['black', 'pink', 'blue'] var child2 = new Child('Mike', 22) console.log(child2.name) // Mike console.log(child2.age) // 22 console.log(child2.colors) // ['black', 'pink'] 优点： 融合了原型链继承和经典继承的优点，是JavaScript中最常用的继承方式 缺点： 调用了两次父构造函数 4.原型式继承 function createObj(o) { function F() {} F.prototype = o return new F() } 缺点： 和原型链继承一样，包含引用类型的属性值始终都会共享相应的值 var person = { name: 'Mike', friends: ['Lily', 'Daisy'] } var person1 = createObj(person) var person2 = createObj(person) person1.name = 'person1' console.log(person2.name) // Mike person1.friends.push('Cole') console.log(person2.friends) // ['Lily', 'Daisy', 'Cole'] 此处修改person1.name的值，可以看到person2.name并未改变，并非因为二者有独立的name值，而是因为是给person1添加了name值，而非修改原型上的name值 5.寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 function createObj(o) { var clone = Object.create(o) clone.sayName = function() { console.log('hi') } return clone } 缺点： 和经典继承一样，每次创建对象都会创建一次方法 6.寄生组合式继承 引用类型最理想的继承范式 function object(o) { function F() {} F.prototype = o; return new F(); } function prototype(child, parent) { var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype; } // 使用的时候： prototype(Child, Parent); ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"跨域原理和解决方案 什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 而我们常说的跨域是狭义上的，是由浏览器同源策略限制的一类请求场景。浏览器的同源策略会导致跨域。 同源策略 同源：协议、域名和端口都相同。 同源策略限制以下行为 无法读取cookie，localStorage和indexDB 无法获得DOM和js对象 不能发送AJAX请求 跨域解决方案 1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"JS是单线程还是多线程的？ JavaScript是单线程的： JS的一大特点就是单线程。也就是说，同一时间只能做一件事。这是因为JavaScript是脚本语言，是为处理页面中用户的交互以及操作DOM产生的，所以若其是多线程，会带来很复杂的同步问题。所以为了避免复杂性，JavaScript一诞生起就是单线程，已经成为了这门语言的核心特征。 既然JavaScript是单线程的，那么它怎么执行异步的代码？ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。但JS引擎执行异步代码并不需要等待，是因为有消息队列和事件循环。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"事件循环 JavaScript是一门单线程的语言，但不意味着单线程就会阻塞，实现单线程不阻塞的方法就是事件循环。 所有的任务都会分为同步和异步，同步直接放到主线程执行，异步任务进入任务队列，主线程的任务执行完了，就来消息队列取一个任务推到主线程执行。然后异步任务还可以细分成宏任务和微任务。每次执行一个宏任务，然后如果遇到微任务就把它放到微任务的任务队列。这个宏任务执行完了以后，就去看微任务队列，把里面所有微任务执行完。 常见宏任务：setTimeout,setInterval,setImmediate; 常见微任务：Promise.then() ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:6","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"JS中new具体做了些什么？ new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例 new会进行哪些操作？ 创建一个简单的空的JavaScript对象，即{ } 为步骤一创建出的对象添加属性__proto__ ，将该属性链接至构造函数的原型对象 将步骤一创建的对象作为this的上下文 如果该函数没有返回对象，则返回this ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:7","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"手写new function objectFactory() { // 新建一个对象 var obj = new Object() Constructor = [].shift.call(arguments) // 将obj的原型指向构造函数 obj.__proto__ = Constructor.prototype // 使用 apply，改变构造函数 this 的指向到新建的对象res var res = Constructor.apply(obj, arguments) return typeof res === 'object' ? res : obj } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:8","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"立即执行函数 IIFE(Immediately Invoked Function Expression),在定义后立即执行的JavaScript函数 (function() { statements;})(); 第一部分是包围在()里的一个匿名函数，该函数拥有独立的块级作用域，避免了外界访问此IIFE的变量，也不会污染全局作用域。 第二部分再次使用()创建了一个立即执行函数表达式，JavaScript引擎到此将直接执行函数。 将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:9","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"浮点数精度 数字类型 ECMAScript中的Number类型使用IEEE754标准，全称 IEEE 二进制浮点数算术标准，来表示整数和浮点数值。 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。 浮点数转二进制 先看0.75转二进制 $0.75 = a * 2^{-1} + b * 2^{-2} + c * 2^{-3} …$ 两边同时乘2， $1 + 0.5 = a * 2^{0} + b * 2^{-1} + …$ 得出a = 1，剩下的再乘2 $1 = b * 2^{0} + c * 2^{-1} + …$ 得出b = 1，其余为0 所以$0.75_{10} = 0.11_{2}$ 但并非每一个小数都这么好计算，就比如$0.1 = 0.00011001100110011…$ 是无限循环的 浮点数的存储 即使有些浮点数转成二进制是无限循环的，但我们仍需要存储它。在IEEE754中，一个浮点数表示方法为 $Value = sign * exponent * fraction$ 比如说，0.1的二进制表示，就是$1 * 2^{-4} * 1.1001100110011…$ 当只做二进制科学计数法的表示，value可以更具体。$Value = (-1)^{sign} * (1 + fraction) * 2^{exponent}$ $(-1)^{sign}$表示符号位，sign为0为正数。再看$(1 + fraction)$，前面的1是共有的，不用存储，只需要存储1.xxxxx中的xxxxx。最后看$2^{exponent}$真正存储时，并不会直接存exponent，而是存$exponent + bias$。 所以要存储一个浮点数，只需存储sign、fraction、(exponent + bias)这三个值。其中sign用到一位，(exponent + bias)用到11位，fraction用到剩下的52位 所以当0.1这样的数被存储下来时，就已经发生了精度丢失。 浮点数的运算 五个步骤：对阶、尾数运算、规格化、舍入处理、溢出判断 两次存储时的精度丢失加上一次运算时的精度丢失，导致$0.1 + 0.2 !== 0.3$ ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:10","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"深拷贝和浅拷贝 浅拷贝 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址，即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 // 浅拷贝的实现 // 1. 遍历复制 function shallowClone(obj) { let newObj = {} for(let prop in obj) { if(obj.hasOwnProperty(prop)) { newObj[prop] = obj[prop] } } return newObj } // 2. Object.assign() 深拷贝 深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 // 手写循环递归 function deepClone(obj, hash = new WeakMap()) { if (!obj) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (typeof obj !== \"object\") return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:11","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下Promise Promise是什么 Promise是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大。他解决异步操作的优点： 链式操作减低了编码难度 代码可读性明显增强 Promise的状态 pending（进行中） fulfilled（已成功） rejected（已失败） Promise的状态不受外界的影响，只有异步操作的结果可以决定状态 状态改变是不可逆的 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:12","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"CSS ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"双栏布局和三栏布局 双栏布局 双栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在 实现思路 使用float左浮左边栏；右边的自适应栏用margin-left撑开内容块；为父级添加BFC（如overflow: hidden），防止下方元素飞到上方内容。 使用flex弹性布局。父元素添加display: flex左边设置定宽，右边设置flex: 1或者width: 100% 三栏布局 两边使用float，中间使用margin 两边使用absolute，中间使用margin 两边使用float，并设置负的margin display: table | flex | grid ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"BFC Block Formatting Contexts (块级格式化上下文)。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"水平居中 对于行内元素： text-align: center; 对于块级元素 { margin: 0 auto; } { display: flex; justify-content: center; } { position: absolute; left: 50%; transform: translate(-50%, 0); } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"垂直居中 对于行内元素 .parent { height: h; } .child { line-height: h; } 对于块级元素 table，元素高度可以动态改变 .parent { display: table; } .child { display: table-cell; vertical-align: middle; } flex，内容块宽高任意；可以用于更复杂高级的布局技术 .parent { display: flex; align-items: center; } 绝对定位 .son { position: absolute; top: 50%; transform: translate(0, -50%); } .son { position: absolute; top: 0; bottom: 0; margin: auto 0; } /* 适用于所有浏览器 */ .son { position: absolute; top: 50%; height: 高度; margin-top: -0.5高度; } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"HTML \u0026 浏览器 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下DOM树 什么是DOM？ 从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。 简而言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容 DOM的作用？ 页面的视角，生成页面的基本结构 Javascript脚本视角，提供脚本操作的接口 安全视角，是一道安全防线，一些不安全的内容在DOM解析阶段就被拒绝 DOM怎么生成的？ 渲染引擎内部，有一个叫HTML解析器的模块，负责将HTML字节流转换成DOM，网络进程加载了多少数据，解析器便解析多少数据 第一阶段，通过分词器将字节流转换成Token，分为Tag Token和文本Token 第二阶段（将Token解析为DOM节点）和第三阶段（将DOM节点添加到DOM树）是同时进行的 HTML解析器维护了一个Token栈结构，根据转换的Token来维护这个栈，进行出栈入栈的操作 DOM解析中的影响因素 遇到JavaScript脚本时，需要暂停整个DOM的解析，先执行JavaScript代码。原因：Javascript脚本可能更改原有的节点 可以通过预解析操作：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件 来优化 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"路由 为什么要使用路由 单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。 hash模式 使用window.location.hash属性以及窗口的onhashchange事件，实现监听浏览器地址hash值变换，执行相应的js来切换网页 hash指的是地址中#号以及后面的字符，也称散列值。 散列值并不随请求发送到服务器端，所以改变hash不会重载页面 当散列值改变，通过window.location.hash属性获取和设置hash值 window.location.hash的变化会直接反映到浏览器地址栏 history模式 window.history属性指向History对象，代表当前窗口的浏览历史。History对象保存了当前窗口访问过的所有页面网址，通过history.length可以知道当前窗口访问过几个网址。 方法：history.back(); history.forward(); history.go(); history.pushState(); history.replaceState() ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"跨页面通信 同源页面 广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent 共享存储模式：Shared Worker / IndexedDB / cookie 口口相传模式：window.open + window.opener 基于服务端：Websocket / Comet / SSE 非同源页面 嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"缓存机制 浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"本地存储 本地存储共有三种方式，coookie，localStorage和sessionStorage 三者的异同 特性 cookie localStorage sessionStorage 生命周期 一般由服务器端生成，会设置失效时间。若没有设置，则默认关闭浏览器时清除 除非手动清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 5M 5M 与服务器端通信 每次都会被携带在HTTP请求头部中，若使用cookie保存过多数据会带来性能问题 仅在客户端保存，不与服务器端进行通信 仅在客户端保存，不与服务器端进行通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景 cookie：存储用户登录信息。针对登陆过的用户，服务器端会在他登陆时在cookie中插入一段加密过的唯一辨识单一用户的辨识码。cookie还需要指定作用域，不可以跨域调用。 localStorage可以用来夸页面传递参数，代替了cookie保存用户购物车信息的工作。sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。 安全性 并非所有数据都适合保存在上述三者中。只要打开控制台，就可以随意修改他们的值。所以重要的数据需要保存在服务器端而非客户端。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"计算机网络 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"HTTP常见状态码 1xx代表信息相应；2xx代表成功相应；3xx代表重定向；4xx代表客户端响应；5xx代表服务端响应。 100 Continue ：表明到目前为止所有内容都是可行的，客户端可以继续请求 101 Switching Protocol：指示服务器正在切换协议 200 OK：请求成功，具体含义取决于请求的方法 204 Not Content：服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。 205 Reset Content：服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。如用户输入表单，提交后清空表单。 206 Partial Content：服务器已经成功处理了部分 GET 请求。迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 301 Move Permanently：被请求的资源已经永久移到了新位置。拥有编辑功能的客户端会自动把请求的地址修改为服务器返回的地址。 302 Found：临时重定向，以后应该继续按原地址发送请求。 304 Not Modified：客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器返回这个状态码。禁止包含消息体，因此始终以消息头后的第一个空行结尾。 400 Bad Request：语义有误，服务器无法理解；请求参数有误。 401 Unauthorized：当前请求需要用户验证。 403 Forbidden：服务器已经理解请求，但是拒绝执行。 404 Not Found：请求失败，请求需要的资源在服务器上未被发现。 500 Interval Server Error：服务器遇到不知道该如何处理的情况。 503 Service Unavailable：服务器没有准备好处理请求，常见原因是服务器因维护或重载而停机。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"TCP三次握手和四次挥手 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"TCP和UDP的区别 UDP 用户数据包协议，一个简单的面向数据的通信协议，对于应用层传递下来的报文，它只会简单地加上首部，就交给网络层，不会做合并或者拆分的工作。特点如下 不提供复杂的控制机制，利用IP提供面向无连接的通信服务 传输过程中若出现了丢包，UDP也不会重发 包的到达顺序错乱了的话，UDP也无法纠正 无法进行流量控制等避免网络堵塞的行为 首部8个字节 发送端只负责将数据发送到网络，接收端从消息队列读取 支持一对一、一对多、多对一和多对多的交互通信 TCP 传输控制协议，是一种可靠的、面向字节流的通信协议，把应用层传递下来的数据看做是无结构的字节流来发送。，会根据当前网络的堵塞情况来确定每个报文段的大小。 充分地实现了数据传输时的各种控制功能，可以进行重发控制、顺序控制 作为一种面向连接的服务，只有在确认通信对端的存在后才会发数据，控制通信流量的浪费 建立连接3次握手、断开连接四次挥手 根据TCP的机制，在IP这种无连接的网络上也能实现高可靠性的通信。 首部20字节 只能点对点全双工通信 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"https和http的区别 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"七层网络模型 应用层 该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务；在应用层交互的数据单元称为报文。应用层协议：HTTPS、DNS、SMTP等 表示层 表示层的作用是使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异 会话层 会话层就是负责建立、管理和终止表示层实体之间的通信会话。提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法 传输层 主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。主要的传输层协议是TCP和UDP 网络层 在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。 链路层 在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧 物理层 和软件关系不大，确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性） ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"性能 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"重排和重绘 重排重绘是什么？ 重排：也叫回流，当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排 添加或者删除可见的DOM元素 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 “重绘\"不一定会出现\"重排”，“重排\"必然会出现\"重绘” ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"优化方法 尽可能减少重排的次数和范围：重排的性能花销跟渲染树有多少节点需要重新构建有关系，我们应尽量以局部布局的方式组织HTML 分离读写操作，防止多次拿值触发渲染 样式集中改变 缓存布局信息 离线改变DOM position可以多用absolute和fixed，这样不用考虑他对其他元素的影响 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"白屏 概念 白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。 白屏期间发生了什么？ DNS Lookup 浏览器会先对页面进行域名解析，获取到服务器的IP地址后，进而和服务器进行通信。 建立TCP请求连接 服务端处理响应 在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。 客户端下载、解析、渲染显示页面 白屏优化 针对白屏期间的环节进行逐一优化 DNS缓存优化、DNS预加载、稳定可靠的DNS服务器 TCP网络链路优化 服务端处理优化 尽可能精简HTML、CSS代码和结构。合理放置JS代码 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"Vue ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"对keep-alive的理解 keep-alive是什么 keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM，包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。它可以设置一些属性 include 字符串或者正则表达式，只有名称匹配的组件才会被缓存 exclude 和上面的相反，名称匹配的不被缓存 max 最多可以缓存多少组件 keep-alive基本用法 \u003ckeep-alive\u003e \u003ccomponent :is=\"view\"\u003e\u003c/component\u003e \u003c/keep-alive\u003e 设置了keep-alive缓存的组件，会多出两个生命周期钩子（activated与deactivated） 使用场景 当我们在某些场景下不想让页面重新加载时我们可以使用keepalive 例如，当我们从首页切换到歌手页，再切换到收藏页面，再返回歌手页，我们不想每次切换页面都发送一次请求，就使用keep-alive将其缓存。 原理分析 源码位置：src/core/components/keep-alive.js ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"通信方式 通过 props 传递 通过 $emit 触发自定义事件 使用 ref EventBus $parent 或 root attrs 与 listeners Provide 与 Inject Vuex ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"理解双向数据绑定 双向绑定由三个部分组成：数据层（Model）、视图层（View）、业务逻辑层（ViewModel）。其中最重要的是那个ViewModel，主要职责是数据变化后更新视图，视图变化后更新数据。包含两部分，监听器和解析器。监听器用来监听所有数据的属性，解析器对每个元素节点的指令进行扫描和解析，根据指令模板替换数据,以及绑定相应的更新函数。 简单来说，利用Object.defineProperty()，结合订阅-发布模式，对数据属性的getter和setter进行劫持。Vue3中抛弃了defineProperty()，改为Proxy Proxy相比Object.defineProperty()的优势 Object.defineProperty()虽然可以做到监听对象属性，但是存在着一些缺点。 检测不到对象属性的添加和删除 数组API无法监听到，所以在Vue2中对数组API进行了重写 需要对每个属性进行遍历监听，如果是嵌套对象，需要深层监听，造成性能问题 而Proxy直接可以劫持整个对象，并返回一个新对象，我们只需要操作新对象就可以达到响应式目的。 Proxy的缺点：兼容性差，不兼容IE，而Object.defineProperty()可以兼容到IE9 Vue里的双向绑定流程 初始化，对data执行相应化处理，该过程发生在监听器 同时编译模板，找到里面动态绑定的数据，然后获取、初始化视图层，发生在解析器里 然后定义更新函数和一个Watcher，Watcher来观察数据是否变化了，如果变化就调用更新函数 然后因为某些data会出现多次，就要有多个watcher来观测他，所以对每一个data就准备一个管家来管理那些watcher 如果data变了，就先找他对应的管家，然后通知里面的每一个观察者watcher ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"computed和watch computed computed设计的初衷是为了使模板中的逻辑运算更简单, 在模板中有很多复杂的数据计算的话, 可以把该计算逻辑放到computed中 computed是计算属性的，会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。 应用场景： 一些重复使用的数据或复杂及费时的运算，可以放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取。 如果需要的数据依赖于其他的数据, 我们可以把该数据设计为computed中。 computed和methods的区别 computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值。而methods不是响应式的，每次调用都会重新求值 omputed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get / set变成可读写属性, 但是methods中的成员没有这样的。 watch watch是一个对data数据的监听回调, 当依赖的数据变化时, 会执行回调。在回调中，会传入newVal和oldVal两个参数。 Vue实例会在实例化时调用$watch()，遍历watch对象的每一个属性。 应用场景： 当在data中的某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时. 我们就可以使用watch来进行监听 watch和computed的异同 相同：都是观测页面数据变化的 不同：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。watch每次都需要执行函数。watch更适用于数据变化时的异步操作。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"Vue3新特性 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"diff算法 是什么 diff 算法是一种通过同层的树节点进行比较的高效算法，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较。 它有两个特点 比较只会在相同层级进行，不会跨级比较 在具体某一层的diff比较中，循环从两边向中间比较 原理分析 数据发生改变，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 先看patch。接收四个参数，第一个是旧节点oldVnode，第二个是新节点vnode。 没有新节点，那么直接把旧的删光，触发旧节点的destroy钩子 没有旧节点，直接生成新的就可以了，createElm 通过sameNode判断两个节点一不一样，一样的话直接patchVnode，不一样的话创建新节点，删除旧节点 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:6","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"操作系统 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"进程和线程的区别： 进程，是程序的依次执行过程，是程序在执行过程中分配和管理资源的基本单位，每个进程都有自己的地址空间，至少有五种状态：初始态，执行态，等待状态，就绪状态，终止状态。 线程，是CPU调度和分派的基本单位，可以和同一进程下的其他线程共享全部资源 二者联系：线程是进程中的一部分，一个进程可以有多个线程，但一个线程只能存在于一个进程中。 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["Program"],"content":"Vuex使用小结 ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:0","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"写在前面 虽如官方文档所说：“如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex”。没错，我的应用就是够简单的那个😂 但随着深入学习，迟早也需要掌握Vuex的使用，何不现在就用上他呢？ ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:1","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。（摘自Vue3官方文档） 该状态自管理应用包含三部分 state，状态，驱动应用的数据源 view，视图，以声明方式将state映射到视图 actions，操作，响应在视图上的用户输入导致的状态变化 Vuex可以帮助我们更好地管理共享状态 ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:2","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"开始使用Vuex 引入 npm i install vuex 在src文件夹下新建store目录，在其中新建index.js文件 import { createStore } from \"vuex\" export default createStore({ state: {}, mutations: {}, actions: {}, modules: {} }) 实例 往state中存入我们所需要共享的数据和操作 state: { isLogin: false, configs: [ { title: \"theme\", property: true, id: 1 }, { title: \"enableDelete\", property: true, id: 2 } ] }, mutations: { login(state) { state.isLogin = true } } 存放好了数据，该怎么查看、使用和更改这些数据呢？ 要调用这些数据，需要通过store.state来获取 // 任意组件/视图下 console.log(this.$store.state.isLogin) 我们不能直接更改数据，需要通过提交mutation的方式来改变。例如，当我们点击了登录按钮 methods: { login() { this.$store.commit('login') } // 当需要同时传递数据 this.$store.commit('mutationName', data1, data2) } ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:3","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"解决页面刷新数据丢失问题 store里的数据是保存在运行内存中的，每当页面刷新，就会重载Vue实例，store里的数据就会被重新赋值初始化。 要解决这个问题，就需要想办法把数据存储在本地（localStorage, sessionStorage, cookie三者之一中）。三者区别 由于创建的是单页面应用，操作只是在一个页面跳转路由，因此选择sessionStorage. 具体操作： 在页面初始化和每次更新时，读取sessionStorage的数据存储到store中，使用Vuex的replaceState方法来替换store的根状态 在beforeunload方法中，将store.state存储到sessionStorage. // App.vue created() { //在页面加载时读取sessionStorage里的状态信息 if (sessionStorage.getItem(\"store\")) { this.$store.replaceState( Object.assign( {}, this.$store.state, JSON.parse(sessionStorage.getItem(\"store\")) ) ); } //在页面刷新时将vuex里的信息保存到sessionStorage里 window.addEventListener(\"beforeunload\", () =\u003e { sessionStorage.setItem(\"store\", JSON.stringify(this.$store.state)); }); }, ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:4","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"数据更新页面不更新的问题 解决完数据丢失的问题，又遇到了更新数据页面不随之更新的问题。从底层出发进行分析。 原来的代码如下 // 组件中 data() { return { currentCategory: this.$store.state.currentCategory } } methods: { changeCategory(name) { this.$store.commit('changeCategory', name) console.log(this.$store.state.currentCategory) // 成功更新 console.log(this.currentCategory) // 未更新 } } // store.js mutations: { changeCategory(state, name) { state.currentCategory = name } } 在提交了更新以后，通过控制台查看输出，可以发现store.js里的变量已经成功更新，但组件内的data并没有再次获取更新后的值。这就牵扯到Vue的生命周期。 data() { return { val: 'hello vue' } } beforeCreated() { console.log(this.val) //undefined } created() { console.log(this.val) // hello vue } 不难发现data的赋值，是在created()中进行的。 而Vuex的state数据改变，并不会触发组件的刷新，组件也就无法获取到改变的值，直到手动进行刷新为止。该如何解决这个问题呢？ 最简单的方法，是在组件中直接使用state中的数据，而不是用自建data作为中间变量。 第二个方法，就是在提交数据的时候进行强制刷新操作，迫使组件重新获取store的值 methods: { changeCategory(name) { this.$store.commit('changeCategory', name) console.log(this.$store.state.currentCategory) // 成功更新 console.log(this.currentCategory) // 未更新 this.$forceUpdate() console.log(this.currentCategory) // 成功更新 } } ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:5","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"Vue 3学习之路由的进阶 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:0","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"写在前面 之前学习使用了vue的路由，实现了简单的单页面内部pages跳转，继续跟随官方视频学习，进阶vue3中路由的使用 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:1","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"切换效果 vue-router提供了一套完备方便的，用于给各路由页面切换增加效果的方法。 在vue2中，我们可以使用如下方法给页面切换添加slider效果 \u003ctransition name=\"slide\" mode=\"out-in\"\u003e \u003crouter-view :key=\"$route.path\"/\u003e \u003c/transition\u003e .slide-enter-active, .slide-leave-active { transition: opacity .6s, transform .6s; } .slide-enter, .slide-leave-to { opacity: 0; transform: translateX(-30%); } 但在vue3中，继续这种写法能正常工作，但会有warning。 根据warning提示对其进行修改即可 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:2","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"路由回溯与追踪 想要添加一个回到上一页的功能却苦于状态管理？Vue已经帮我们准备好了方法。很简单，仅需要一行代码。给一个按钮绑定goBack事件，点击触发，以下是goBack函数内的所有内容。this.$router.go()可以接受正数和负数作为参数，来进行路由间的跳转。 return this.$router.go(-1) ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:3","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"嵌套路由 一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构。通过 Vue Router，就可以使用嵌套路由配置来表达这种关系。 想要将组件渲染到嵌套的router-view当中，就需要在路由中配置chidren { path: \"/details/:slug\", name: \"DestinationDetails\", component: () =\u003e import(/* webpackChunkName: \"DestinationDetails\" */\"../views/DestinationDetails.vue\"), props: true, children: [ { path: \":experienceSlug\", name: \"ExperienceDetails\", component: () =\u003e import(/* webpackChunkName: \"ExperienceDetails\" */\"../views/ExperienceDetails.vue\"), props: true } ]} 如上所示，ExperienceDetails组件就将被渲染到嵌套在DestinationDetails组件的router-view中，而不会跳转到新的页面。 children 配置只是另一个路由数组，就像 routes 本身一样。因此，可以根据自己的需要，不断地嵌套视图。 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:4","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"解耦：路由组件传参 在组件中过多使用$route会使组件与路由紧密耦合，限制了其灵活性，因为这样只能用于特定的URL，我们可以通过配置props来解决这个问题。以官方文档为例，我们可以将下面的代码 const User = { template: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e' } const routes = [{ path: '/user/:id', component: User }] 替换成 const User = { props: ['id'], template: '\u003cdiv\u003eUser {{ id }}\u003c/div\u003e' } const routes = [{ path: '/user/:id', component: User, props: true }] 这就允许我们在任何地方使用该组件，使其更易于复用与测试。 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:5","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"导航守卫 正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:6","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"Vue学习历程（二） 路由的使用 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:0","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"写在前面 在着手进行一个大项目之前，想先优化、完善之前的todolist项目。例如：增加登录、注册功能；数据储存在云端；增加todo项目的分类与更清晰的状态表示；增加用户自定义设置，如皮肤，显示项等等……这些简单的功能放在单纯的一个页面中就显得拥挤，多页面又小题大做，也会影响使用体验，引入router就显得很有必要 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:1","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"什么是路由？ 路由，可以根据不同的 url 地址展示不同的内容或页面，又有前端路由和后端路由之分，而后端路由的渲染存在性能问腿，所以在项目中前端路由发挥着重要的作用。 简单来说，前端路由就是在保证只有单页面，且交互时不刷新不跳转，为SPA(single page web application)中的每个视图展示形式匹配一个特殊的url。在刷新、前进后退等操作均通过这个特殊url来实现。 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:2","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"Vue中如何使用路由？ 路由一般有两种模式，分别是hash模式和History模式，此处将使用history模式(除非为了兼容IE8，均推荐使用History模式) 前置工作 在项目所在目录打开终端，输入以下代码 npm i install vue-router 在src文件夹下新建目录route，在该文件夹里添加一个index.js文件 .// index.js import { createRouter, createWebHistory } from \"vue-router\" const history = createWebHistory() const router = createRouter({ history, routes: [ { path: '/', name: 'Home', component: () =\u003e import('../views/Home.vue') }, { path: '/Login', name: 'Login', component: () =\u003e import('../views/Login.vue') } ] }) export default router 修改main.js文件 // main.js import { createApp } from 'vue' import App from './App.vue' import router from './route' // 引入 createApp(App) .use(router) // 注入 .mount('#app') 新建views文件夹，内部存放需要通过路由显示的视图 接下来就需要添加跳转路由的连接，和存放跳转到的视图的容器。更改App.vue文件结构，新增一个导航区存放链接，内容区存放视图，原有结构转移到Home.vue文件中 \u003c!-- 导航区 --\u003e \u003cdiv class=\"nav\"\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e \u003crouter-link to=\"/Login\"\u003eLogin\u003c/router-link\u003e \u003c/div\u003e \u003c!-- 视图区 --\u003e \u003cdiv class=\"main\"\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e 最终效果展示 当点击Login链接，以路由方式跳转到了Login界面 点击Home或者tourist mode， 回到主页面 // to do 学习VueX 区分登录用户和游客 增加task的分类功能 设置页面更换主题 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:3","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["program"],"content":"前言  学习完基础的三剑客后，决定开始学习框架。无非就两种选择，Vue或是React，了解了一番二者的区别，再看着文档写了两个教程demo，二者具体深层的区别并没有太大了解也没有感受到，单纯觉得Vue更加适合我😂，于是就选择了学习Vue。至于Vue和React两个框架的区别，具体可以看看这篇文章  看完了文档，迫不及待想撸出自己第一个Vue应用，但仍不知道如何下手，对Vue应用的搭建的流程也并不了解，所以选择了观看一个很优秀的Youtuber – Traversy Media的“Vue crash course”，看完视频后去复现他的代码，然后再自己修改样式、添加功能等等…… ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:1","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"成品 点击Add Task按钮，弹出输入框，可以输入任务的具体内容和时间安排 待办的任务将会在下方显示，每个任务的右侧有两个功能按钮，分别是编辑和删除 数据储存于本地的json文件中，刷新浏览器或重新启动服务能照常读取数据 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:2","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"todo 将json数据部署到云端，达到无需启动node服务即可访问的效果 调整布局，美化项目 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:3","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"如何给自己的博客添加一键回到顶部的功能？  今天用Hugo搭好了博客，美化、自定义什么的先放在一边，单纯用框架改改参数什么的，总感觉技术含量不高嘛（高了我也做不出来），就想着先添加个小功能，提供一个一键回到顶部的功能。让我们开始吧。  本文以Hugo框架，LoveIt主题为例。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:0","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加样式 在CSS中，定义返回顶部按钮的样式。打开Hugo主题目录下的 static/asserts/_custom.scss，在其中加入样式代码。 .backtop { color: #b3b1b1; position: fixed; right: 16px; bottom: 20px; width: 33px; height: 33px; z-index: 10000; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:1","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"导入按钮图标 准备好按钮的图标，前往Font Awesome找到心仪的图标，下载其SVG文件，打开后全部复制 在Hugo主题目录下layouts/partials新建back2top.html文件，将拷贝的代码放入 \u003csvg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"chevron-circle-up\" class=\"svg-inline--fa fa-chevron-circle-up fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e \u003cpath fill=\"currentColor\" d=\"M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z\"\u003e \u003c/path\u003e \u003c/svg\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:2","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加锚点 在当前目录下找到header.html文件并打开，在任意行加入以下代码 \u003cspan id=\"top\"\u003e\u003c/span\u003e 来到layouts/_default文件夹，打开single.html，添加以下代码(与content同级) {{- define \"main\" -}} \u003ca href=\"#top\" class=\"backtop\"\u003e{{ partial \"back2top.html\" . }}\u003c/a\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:3","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"大功告成！ ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:4","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["Program"],"content":"LeetCode刷题记录 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:0:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"动态规划 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"121.买卖股票的最佳时机 思路： 动态规划题 minPrice保存前i天的最低价格，用第i天的现价去减这个最小值，就得到了在第i天卖出的利润 取最大利润 var maxProfit = function(prices) { let profit = 0, res = 0, minPrice = prices[0]; let len = prices.length; for(let i = 1; i \u003c len; i++){ if((prices[i] - minPrice) \u003e profit){ profit = prices[i] - minPrice; res = i + 1; } minPrice = Math.min(minPrice, prices[i]); //前i-1天最低价格 } return res; }; 时间复杂度：O(n)，遍历一次 空间复杂度：O(1) 执行用时：84ms，击败了97.91%的用户 内存消耗：47.5MB，击败了71.92%的用户 官方题解： 无js版本，但思路是一致的，不同的点在于官方是从0开始遍历，然后min最开始取一个无穷大值以保证其大于第一天的价格。 class Solution: def maxProfit(self, prices: List[int]) -\u003e int: inf = int(1e9) minprice = inf maxprofit = 0 for price in prices: maxprofit = max(price - minprice, maxprofit) minprice = min(price, minprice) return maxprofit ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"714. 买卖股票的最佳时机含手续费 思路： 动态规划，每天有两种状态，一是今天交易结束后不持有股票，二是持有 sell表示不持有，buy表示持有 不持有的情况：前一天就不持有，或者前一天买入今天卖出 持有的情况：前一天就持有，前一天不持有但今天买入 因此可以得到状态转移方程 sell = max(sell, buy + prices[i] - fee), buy = max(buy, sell - prices[i]) var maxProfit = function(prices, fee) { let sell = 0, buy = -prices[0] for(let i = 1; i \u003c prices.length; i++) { sell = Math.max(sell, buy + prices[i] - fee) buy = Math.max(sell - prices[i], buy) } return sell // 要想利润最大，结束后肯定不能持有股票 }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1014.最佳观光组合 思路： maxScore由三个值组成：距离以及两个景点的好看程度 很明显，两个景点都好看，又近的时候最完美 因此可以先用一个值记录第一个好看的景点，当第二个离他越来越远，这个景点的好看程度也一直下降 var maxScoreSightseeingPair = function(values) { let maxScore = 0, firstSight = 0, secondSight = 1 for(let i = 0; i \u003c values.length - 1; i++) { // 如果第一个景点不够好看，无法支持这个距离，更新 if(values[firstSight] \u003c= values[i]) { // 更新第一个景点（第一个因为太远被抛弃了） firstSight = i secondSight = firstSight + 1 } // 每次循环，第一个景点的吸引力就下降一点 values[firstSight]-- // maxScore维护最大值 maxScore = Math.max(maxScore, (values[firstSight] + values[secondSight])) // 一直在往后找第二个景点 secondSight++ } return maxScore ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"413.等差数列划分 思路： 每个等差数列内的子数列，都是等差数列 不是别的等差数列的子数列的等差数列😂,之间不会有交集 var numberOfArithmeticSlices = function(nums) { if(nums.length \u003c 3) return 0 let res = 0, len = 2 for(let i = 1; i \u003c nums.length - 1; i++) { if((nums[i] - nums[i-1]) === (nums[i+1] - nums[i])) { len++ } else { if(len \u003e= 3) { res = res + (len-1) * (len-2) / 2 } len = 2 } if(i === nums.length - 2) { if(len \u003e= 3) { res = res + (len-1) * (len-2) /2 } } } return res }; 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：64ms，击败了88.75%的用户 内存消耗：37.6MB，击败了58.73%的用户 官方题解 var numberOfArithmeticSlices = function(nums) { const n = nums.length; if (n === 1) { return 0; } let d = nums[0] - nums[1], t = 0; let ans = 0; // 因为等差数列的长度至少为 3，所以可以从 i=2 开始枚举 for (let i = 2; i \u003c n; ++i) { if (nums[i - 1] - nums[i] === d) { ++t; } else { d = nums[i - 1] - nums[i]; t = 0; } ans += t; } return ans; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"53.最大子序和 思路： 若只有一个元素，直接返回 从前往后遍历并求和，若sum\u003c0，则sum归零（前面的元素都不要了） 到后面遇到了负数，但是这个负数加进来也不足以使sum\u003c0，则从这个负数开始往后看，它和后面的元素依此相加，得到一个newSum，一大于0就把newSum加上。 官方题解： 动态规划 var maxSubArray = function(nums) { let pre = 0, maxAns = nums[0]; nums.forEach((x) =\u003e { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); }); return maxAns; }; foreach：对数组的每个元素执行一次给定的函数。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:5","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"918. 环形子数组的最大和 思路： 处理思想和最大子序和基本一致，唯一区别要考虑到环 可以分为两种情况考虑，第一种是不需要越过边界，则和最大子序和一样 第二种是越过了边界，这是只需要求出数组的总和，再减去最小子序和，就是越过环的结果 最后在处理结果时还需要考虑全为负数的情况 var maxSubarraySumCircular = function(nums) { let max = nums[0], min = nums[0], preMax = nums[0], preMax = nums[0], sum = nums[0] for(let i = 1; i \u003c nums.length; i++) { preMax = Math.max(nums[i], (preMax + nums[i])) preMin = Math.min(nums[i], (preMin + nums[i])) max = Math.max(preMax, max) min = Math.min(preMin, min) sum += nums[i] } return (max \u003c 0) ? max : Math.max(max, sum - min) } 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：84ms，击败了80.75%的用户 内存消耗：43.6MB，击败了78.73%的用户 官方题解 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:6","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"70. 爬楼梯 思路： 爬到某一级台阶的前一步，必定落在上一级或者上上级。 所以爬到某一台阶的方法数，等于爬到上一级和上上级的方法数之和。 var climbStairs = function(n) { if(n \u003c= 2){ return n; } let i1 = 1, i2 = 2, temp = 0; for(let i = 3; i \u003c= n; i++){ temp = i1 + i2; i1 = i2; i2 = temp; } return temp; } 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：64ms，击败了94.33%的用户 内存消耗：37.7MB，击败了30.68%的用户 官方题解 /* 方法一，动态规划 */ var climbStairs = function(n) { let p = 0, q = 0, r = 1; for (let i = 1; i \u003c= n; ++i) { p = q; q = r; r = p + q; } return r; }; /* 方法二，通项公式 */ var climbStairs = function(n) { const sqrt5 = Math.sqrt(5); const fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1); return Math.round(fibn / sqrt5); }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:7","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"198. 打家劫舍 思路： 小偷身处第 i 间房子时，知道自己在 “ 只偷到(k - 2)间时最多能偷到的钱 i1 ” 和 “ 只偷到(k - 1)间时最多能偷到的钱 i2 ” 第 i 间房子的钱加上 i1 比 i2 大的话，就偷，然后到了下一间房子后，i1 变成了之前的 i2 ， i2 变成了现在的sum 如果小，就不偷，直接到下一间房子，此时 i1 变为 i2， i2 则不变 var rob = function(nums) { let len = nums.length; if(len === 1) return nums[0]; if(len === 2) return Math.max(nums[0], nums[1]); let i1 = nums[0], i2 = Math.max(nums[0], nums[1]); let sum = 0; for(let i = 2; i \u003c len; i++){ if((nums[i] + i1) \u003e i2){ sum = nums[i] + i1; i1 = i2; i2 = sum; } else{ sum = i2; i1 = i2; } } return sum; }; 执行用时：68ms，击败了84.07%的用户 内存消耗：37.7MB，击败了44.61%的用户 时间复杂度：O(n) 空间复杂度：O(1) 官方题解 class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int length = nums.length; if (length == 1) { return nums[0]; } int first = nums[0], second = Math.max(nums[0], nums[1]); for (int i = 2; i \u003c length; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:8","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"二分法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"35.搜索插入位置 思路： 二分查找法的基础变式 如果查找到了，直接返回； 如果没找到，返回left(right+1)，也就是当前“光标”所在位置 var searchInsert = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, mid; while(left \u003c= right){ mid = parseInt(left + (right-left) / 2); if(nums[mid] \u003e target){ right = mid - 1; } else if(nums[mid] \u003c target){ left = mid + 1; } else{ return mid; //找到了就直接返回索引值 } } return left; //若没找到，则返回目前“光标”位置，该位置前面的数都小于target，后面则都更大 }; 执行用时：68ms，击败了94.68%的用户 内存消耗：39.1MB，击败了12.19%的用户 时间复杂度：O(logn) 空间复杂度：O(1) 官方题解： var searchInsert = function(nums, target) { const n = nums.length; let left = 0, right = n - 1, ans = n; while (left \u003c= right) { let mid = ((right - left) \u003e\u003e 1) + left; if (target \u003c= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; }; 和自己思路类似，自己的觉得更简洁直白 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"34. 在排序数组中查找元素的第一个和最后一个位置 思路： 用二分法，找一个target 如果没找到，则直接返回-1，-1 找到了的话，从mid开始两头找start和end var searchRange = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, start = -1, end = -1; let mid = parseInt(left + (right - left) / 2); while(left \u003c= right){ if(nums[mid] \u003e target){ right = mid - 1; mid = parseInt(left + (right - left) / 2); } else if(nums[mid] \u003c target){ left = mid + 1; mid = parseInt(left + (right - left) / 2); } else{ break; /* 找到了 */ } } /* 如果是因为left大于right而跳出的循环，则证明没有找到 */ /* 如果left仍未大于right，则证明找到了，需要继续找 */ if(left \u003e right){ return [start,end]; /* 直接返回[-1,-1] */ } let i = 0, j = 0; while(++i){ if(nums[mid-i] != target || (mid-i) \u003c left){ start = mid - i + 1; break; } } while(++j){ if(nums[mid+j] != target || (mid+j) \u003e right){ end = mid + j - 1; break; } } return [start,end]; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：68ms，击败了94.12%的用户 内存消耗：39.9MB，击败了12.97%的用户 陷入了误区，找到mid后使用了线性查找，导致时间复杂度来到了O(n)而不是O(logn)！！正确的做法是继续二分查找！！！ 改进版 var searchRange = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, start = -1, end = -1; let mid = parseInt(left + (right - left) / 2); while(left \u003c= right){ if(nums[mid] \u003e target){ right = mid - 1; mid = parseInt(left + (right - left) / 2); } else if(nums[mid] \u003c target){ left = mid + 1; mid = parseInt(left + (right - left) / 2); } else{ break; /* 找到了 */ } } /* 如果是因为left大于right而跳出的循环，则证明没有找到 */ /* 如果left仍未大于right，则证明找到了，需要继续找 */ if(left \u003e right){ return [start,end]; /* 直接返回[-1,-1] */ } 官方题解 const binarySearch = (nums, target, lower) =\u003e { let left = 0, right = nums.length - 1, ans = nums.length; while (left \u003c= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] \u003e target || (lower \u0026\u0026 nums[mid] \u003e= target)) { right = mid - 1; ans = mid; } else { left = mid + 1; } } return ans; } var searchRange = function(nums, target) { let ans = [-1, -1]; const leftIdx = binarySearch(nums, target, true); const rightIdx = binarySearch(nums, target, false) - 1; if (leftIdx \u003c= rightIdx \u0026\u0026 rightIdx \u003c nums.length \u0026\u0026 nums[leftIdx] === target \u0026\u0026 nums[rightIdx] === target) { ans = [leftIdx, rightIdx]; } return ans; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"4. 寻找两个正序数组的中位数 思路： 归并排序，根据长度返回中位数 var findMedianSortedArrays = function(nums1, nums2) { let len1 = nums1.length, len2 = nums2.length; let res = 1.0, i = 0, j = 0; let nums = []; while(i \u003c len1 || j \u003c len2) { if(i \u003e= len1) { nums.push(nums2[j++]); } else if(j \u003e= len2) { nums.push(nums1[i++]); } else { if(nums1[i] \u003e= nums2[j]) { nums.push(nums2[j++]); } else { nums.push(nums1[i++]); } } } let len = nums.length; if(len % 2) { res = nums[Math.floor(len / 2)]; } else { res = (nums[len / 2] + nums[len / 2 - 1]) / 2 } return res; }; 时间复杂度：O(m+n) 空间复杂度：O(m+n) 执行用时：124ms，击败了65.19%的用户 内存消耗：43.2MB，击败了63.96%的用户 官方题解： 题目要求：时间复杂度O(log(m+n))。 该题可以转化为，求两个有序数组中第k小的数，其中k为(m+n)/2或者(m+n)/2+1 要找到第k小的元素，我们可以比较nums1[k / 2 - 1]和nums2[k / 2 - 1]，所以对于nums1[k / 2 - 1]和nums2[k / 2 - 1]中的较小值，最多只会有(k-2)个元素比它小，那么它不可能是第k小的元素。 此处k / 2为整数除法( Math.floor() ) 此时可以归纳三种情况： nums1[k / 2 - 1] \u003c nums2[k / 2 - 1]，则可以排除nums1[1] 到nums1[k / 2 - 1] nums2[k / 2 - 1] \u003c nums1[k / 2 - 1]，则可以排除nums2[1] 到nums2[k / 2 - 1] nums1[k / 2 - 1] == nums2[k / 2 - 1]，可以并入第一种情况 所以在比较后，我们可以排除k / 2个不可能是第k小的数，意味着查找的范围已经缩小了一半 下一步就是在排除后的新数组上继续二分查找，并且根据我们排除的数的个数，来减小k的值 有三种特殊情况需要处理： 越界。则取该数组最后一个数字，同时注意k不能直接减半 若一个数组为空，直接返回另一个数组第k小的数字 若k=1，直接返回两数组首元素较小值 优化后： ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"栈 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:3:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"剑指offer 06 从尾到头打印链表 思路： 遍历链表，依此在头部添加val var reversePrint = function(head) { let res = new Array(); while(head!==null){ res.unshift(head.val); head = head.next; } return res; }; 时间复杂度：O(n) 空间复杂度：O(n) 执行用时：80ms，击败了94.21%的用户 内存消耗：39.4MB，击败了94.03%的用户 官方题解 栈 ​ 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:3:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"树 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:4:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"671. 二叉树中第二小的节点(https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/) 思路： 在这个特殊的二叉树中，子节点的元素均大于等于父节点元素的值。 所以只要自顶往下，在某一层遇到了比根节点大，且是这一层最小的，那就是所要的节点。 如果一直没找到，直到所有节点遍历完了，也就是所有叶节点也和根节点的值一样，返回-1； 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解 var findSecondMinimumValue = function(root){ let ans = -1; const rootValue = root.val; const dfs = (node) =\u003e { if(node === null){ return; } if(ans !== -1 \u0026\u0026 node.val \u003e= ans){ return; } if(node.val \u003e rootValue){ ans = node.val; } dfs(node.left); dfs(node.right); } dfs(root); return ans; } **const dfs = (node) =\u003e {} ** =\u003e : 箭头函数，相当于匿名函数，且简化了函数定义 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:4:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"BFS和DFS ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:5:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"200. 岛屿数量 思路 遍历grid，当遇到1，将其置0，将其上下左右的1置0，将其上下左右的1的上下左右的1置零…… var numIslands = function(grid) { let res = 0 const bfs = (i, j) =\u003e { if(i \u003c 0 || j \u003c 0 || i \u003e= grid.length || j \u003e= grid[0].length || grid[i][j] === '0') { return } grid[i][j] = '0' bfs(i + 1, j) bfs(i - 1, j) bfs(i, j + 1) bfs(i, j - 1) } for(let i = 0; i \u003c grid.length; i++) { for(let j = 0; j \u003c grid[0].length; j++) { if(grid[i][j] === '1') { res++ bfs(i, j) } } } return res }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：84ms，击败了52.76%的用户 内存消耗：40.4MB，击败了49.33%的用户 官方题解 1.广度优先搜索BFS class Solution: def numIslands(self, grid: [[str]]) -\u003e int: def bfs(grid, i, j): queue = [[i, j]] while queue: [i, j] = queue.pop(0) if 0 \u003c= i \u003c len(grid) and 0 \u003c= j \u003c len(grid[0]) and grid[i][j] == '1': grid[i][j] = '0' queue += [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]] count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '0': continue bfs(grid, i, j) count += 1 return count 2.深度优先搜索DFS class Solution: def numIslands(self, grid: [[str]]) -\u003e int: def dfs(grid, i, j): if not 0 \u003c= i \u003c len(grid) or not 0 \u003c= j \u003c len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' dfs(grid, i + 1, j) dfs(grid, i, j + 1) dfs(grid, i - 1, j) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:5:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"摩尔投票法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:6:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"面试题17.10.主要元素 思路： 若数组里只有一个数字，直接返回； 对数组进行排序后，若两个相差一半长度的元素相等，则该元素就是主要元素； 若遍历到一半还没出现，则证明没有主要元素。 var majorityElement = function(nums) { l = parseInt(nums.length/2); if(!l){ return nums[0]; } nums.sort(); for(let i = 0; i \u003c= l; i++){ if(nums[i] == nums[i+l]){ return nums[i]; } } return -1; }; 时间复杂度：O(nlogn)。排序复杂度超出了要求 空间复杂度：O(1)，没有用到多余的空间 执行用时：72ms，击败了94.35%的用户 内存消耗：42.2MB，击败了10.63%的用户 官方题解： Boyer-Moore投票算法 Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。 该题中表现为：遍历到x时，若count为0，则先将x的值赋给candidate；接下去若遇到不相同的，count–，遇到相同的，count++，若count为0，重新赋值。因此遍历一遍过后，如果数组nums 中存在主要元素，则candidate 即为主要元素，否则candidate 可能为数组中的任意一个元素。 因此需要二次遍历，看candidate出现的次数是否大于l/2。 【主要元素出现次数大于其他元素出现次数之和】 【== 和 === 的区别： == 会先将两边的值进行强制类型转换】 null == undefined //true null === undefined //false 55 == '55' //true 55 === '55' //false //因此推荐使用=== var majorityElement = function(nums) { let candidate = -1; //候选主要元素，初始可以是任意值 let count = 0; //候选主要元素出现的次数 for (const num of nums) { if (count === 0) { candidate = num; } if (num === candidate) { count++; } else { count--; } } count = 0; const length = nums.length; for (const num of nums) { if (num === candidate) { count++; } } return count * 2 \u003e length ? candidate : -1; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:6:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"双指针 || 滑动窗口 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"3. 无重复字符的最长字串 思路 最初的思路是，用两重循环，以数组每个元素为起点都做一次最大长度，保留最大 后面发现这样会超时(O(N^2)) 改进成：遇到一个重复元素，则将pre中的该重复元素及其之前的元素截取掉 var lengthOfLongestSubstring = function(s) { let pre = [], counts = 0; let len = s.length; for(let i = 0; i \u003c len; i++){ let index = pre.indexOf(s[i]); if(index !== -1){ pre.splice(0,(index + 1)); //截取数组，把前面的重复元素及其之前的元素删掉 } pre.push(s[i]); counts = Math.max(counts,pre.length); } return counts; }; 时间复杂度：O(n)，遍历一次 空间复杂度：O(∣Σ∣)，最坏情况全不重复，则最长是所有字符的合集128 执行用时：76ms，击败了99.90%的用户 内存消耗：41.4MB，击败了71.54%的用户 官方题解 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i \u003c n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 \u003c n \u0026\u0026 !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }; 该做法称为“滑动窗口” 使用两个指针表示字符串的某个子串（窗口）的左右边界 每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，记下长度 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"26.删除有序数组中的重复元素 思路： 因为数组是有序的，所以遍历数组，当某元素和前一个元素不等，则代表它没出现过，把他放到第n个位置，n为出现过的元素个数 var removeDuplicates = function(nums) { let len = nums.length; let res = 0; for(let i=0; i\u003clen; i++){ if(nums[i+1] != nums[i]){ res++; nums[res] = nums[i+1]; } } return res; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解： 快慢指针，实际思想与自己无异 var removeDuplicates = function(nums) { const n = nums.length; if (n === 0) { return 0; } let fast = 1, slow = 1; while (fast \u003c n) { if (nums[fast] !== nums[fast - 1]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"27.移除指定元素 思路： 跟26题几乎一样，不一样的只是res的起点 var removeElement = function(nums, val) { let res = 0; let len = nums.length; for(let i=0; i\u003clen; i++){ if(nums[i] !== val){ nums[res++] = nums[i]; } } return res; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：64ms，击败了99.51%的用户 内存消耗：38MB，击败了32.95%的用户 官方题解： 除了快慢指针，还可以使用左右指针，在val元素数量小时很有效，避免了需要保留的元素的重复赋值操作。 var removeElement = function(nums, val) { let left = 0, right = nums.length; while (left \u003c right) { if (nums[left] === val) { nums[left] = nums[right - 1]; right--; } else { left++; } } return left; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"剑指offer52 两个链表的第一个公共节点 官方题解 var getIntersectionNode = function(headA, headB) { if(headA===null || headB===null){ return null; } /* 有一个为空，则没有交集 */ let pA = headA; let pB = headB; while(pA!==pB){ /* 当他们没有相遇 */ pA = (pA===null) ? headB : pA.next; pB = (pB===null) ? headA : pB.next; } return pA; }; 有点没看懂问什么＋刚搬完寝室无心学习，直接看官方题解了 也属于双指针题目，但特殊的是，由于公共节点离两个头结点的位置是不同的，所以只遍历一遍自身是不够的，需要遍历完自身（若此时还没找到），再去从另一个的头结点处开始遍历，当两边都这么做，就能保证：若有公共节点，则同时停在公共节点处，也就意味着可以返回这个节点。若没有，则会同时处于null（两边都刚好遍历了lenA+lenB） ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"141. 环形链表 思路 val值有限定范围 小聪明，但值得注意的是，面试时应先问清楚面试官题目细节，如果刻意透露了限定条件，则利用反而会加分 var hasCycle = function(head) { while(head){ if(head.val==100001){ return true; } else{ head.val = 100001; } head = head.next; } return false; }; 快慢指针，快的一次走两步，慢的一次走一步，快的能反过来追上慢的就有环 var hasCycle = function(head) { if(head==null || head.next==null){ //没环 return false; } let fast = head.next, slow = head; while(fast){ //如果没环，fast会先到尾 if(fast == slow){ return true; } if(fast.next==null){ return false; } fast = fast.next.next; slow = slow.next; } return false; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解 哈希表，用集合存储访问过的节点 快慢指针 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:5","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"611. 有效三角形的个数 思路 暴力 var triangleNumber = function(nums) { nums.sort((a, b) =\u003e a - b); /* sort方法仅适用于字符串，对数字需要这样操作 */ let len = nums.length; let res = 0; for(let i = 0; i \u003c len - 2; i++){ if(nums[i] \u003c= 0){ continue; /* 三角形边长都是正数 */ } for(let j = i + 1; j \u003c len - 1; j++){ for(let k = j + 1; k \u003c len; k++){ if(nums[i] + nums[j] \u003e nums[k]){ res++; } else{ break; } } } } return res; }; 时间复杂度：O(N3) 执行用时：852ms，击败了23.08%的用户 内存消耗：39.4MB，击败了70.33%的用户 官方题解 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:6","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"881. 救生艇 思路： 重点是每艘船只能载1或2人 排序，最轻的和最重的加，若不大于limit，左边指针后移一位 每次循环都将右指针前移一位，船数也加一 var numRescueBoats = function(people, limit) { let res = 0; people.sort((a,b) =\u003e (a-b)); let left = 0, right = people.length - 1; while(left \u003c= right) { if(people[left] + people[right] \u003c= limit) { left++; } right--; res++; } return res; }; 时间复杂度：O(nlogn) 排序 空间复杂度：O(1) 执行用时：152ms，击败了93.16%的用户 内存消耗：45.5MB，击败了36.32%的用户 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:7","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"15. 三数之和 思路： 此题的重点是，不能存在重复的三元组 要找到和为0的三元组，自然地想到需要先进行排序。排序后找第一个元素，这个元素的特点是不能和前一个元素相等，这也就保证了每个三元组的最小值不会相等，初步保证不会重复 接下去的操作类似于之前的两数之和题目，使用双指针来寻找，对于左指针指向的元素，拥有和对第一个元素一样的约束，这样也保证了第二个元素不会在第二个位置重复使用 当前两个确定后，由于和是0是固定的，第三个只需要正常寻找就可以 var threeSum = function(nums) { let res = []; nums.sort((a,b)=\u003e(a-b)); // 排序数组 for(let i = 0; i \u003c nums.length - 2; i++) { // 最后两个数不可能是三元组内第一个元素 if(i \u003e 0 \u0026\u0026 nums[i-1] === nums[i]) continue; // 确保第一个位置不重复 let first = nums[i]; let left = i + 1, right = nums.length - 1; while(left \u003c right) { let second = nums[left], third = nums[right]; if(first + second + third === 0) { res.push([first, second, third]); // 确保第二个位置不重复 while(1) { left++; if(nums[left] !== nums[left-1] || left \u003e= right) { break; } } } else if(first + second + third \u003c 0) left++; else right--; } } return res; }; 时间复杂度：O(n^2) 空间复杂度：O(logn) 执行用时：136ms，击败了83.01%的用户 内存消耗：6MB，击败了34.90%的用户 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:8","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"基础线性表 || 矩阵 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"2. 两数相加 思路 用carry表示进位 head代表头结点，尾结点往后走到l1、l2都为空 如果用一个为空，另一个还未到结束，则空的那部分都是0 var addTwoNumbers = function(l1, l2) { let carry = 0; /* 第一次一定没有进位 */ let head = null, tail = null; while(l1 || l2){ const num1 = l1 ? l1.val : 0; const num2 = l2 ? l2.val : 0; const sum = num1 + num2 + carry; if(!head){ head = tail = new ListNode(sum % 10); } else{ tail.next = new ListNode(sum % 10); tail = tail.next; } carry = (sum \u003e= 10) ? 1 : 0; if(l1){ l1 = l1.next; } if(l2){ l2=l2.next; } } if(carry == 1){ tail.next = new ListNode(1); tail = tail.next; } return head; }; 时间复杂度：O(max(m,n)) 空间复杂度：O(1) 执行用时：96ms，击败了99.90%的用户 内存消耗：43.2MB，击败了32.54%的用户 官方题解 一样 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"21.合并两个有序链表 思路： 创建结点head和tail 先判断是否都不为空，若有一个为空则返回另一个，都为空则直接返回空结点 都不为空的话，head指向小的那个list，然后进入while循环，根据val值决定tail延伸方向，有一个为空即跳出循环 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ struct ListNode *head, *tail; if(l1 \u0026\u0026 l2){ if(l1-\u003eval \u003c l2-\u003eval){ head = l1; l1 = l1-\u003enext; } else{ head = l2; l2 = l2-\u003enext; } tail = head; while(l1 \u0026\u0026 l2){ if(l1-\u003eval\u003cl2-\u003eval){ tail-\u003enext = l1; l1 = l1-\u003enext; } else{ tail-\u003enext = l2; l2 = l2-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = l1?l1:l2; } else if(l1){ return l1; } else if(l2){ return l2; } return head; } 时间复杂度：O(n+m) 空间复杂度：O(n+m) 执行用时：4ms，击败了90.26%的用户 内存消耗：6MB，击败了59.92%的用户 官方递归解法： struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-\u003eval \u003c l2-\u003eval){ l1-\u003enext = mergeTwoLists(l1-\u003enext,l2); return l1; }else{ l2-\u003enext = mergeTwoLists(l1,l2-\u003enext); return l2; } } 递归： 必须要有边界条件，否则递归无法停止将会出错 递归函数通过不断调用自身，直至遇到边界条件后进行回溯，返回最终答案。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"448.找到消失的数字 思路： 数字大小都在区间[1,n]内，项数范围是[0,n-1] 则每个元素的绝对值减去1，就代表其中一个项的位置 把该位置的元素变为负值 则仍未正数的元素的下标，就是代表没有出现的数字 - 1 var findDisappearedNumbers = function(nums) { len = nums.length; //获取数组长度 var res = new Array(); //存放答案的新数组 for(let i=0;i\u003clen;i++){ let num = Math.abs(nums[i]) - 1; //项数 if(nums[num] \u003e 0){ nums[num] *= -1; //包含的项变负 } } for(let i=0;i\u003clen;i++){ if(nums[i]\u003e0){ res.push(i+1); //添加正数 } } return res; }; 时间复杂度：O(n) 空间复杂度：符合题目要求，除了返回的数组以外不占用其他空间 执行用时：112ms，击败了97.43%的用户 内存消耗：45.2MB，击败了99.32%的用户 官方题解的做法： 每遇到一次x，就让nums[x-1]加上n，最后数组里仍处在[1,n]范围内的项，下标加一就是消失的数字。 var findDisappearedNumbers = function(nums) { const n = nums.length; for (const num of nums) { const x = (num - 1) % n; // %n很重要 nums[x] += n; } const ret = []; for (const [i, num] of nums.entries()) { if (num \u003c= n) { ret.push(i + 1); } } return ret; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"54. 螺旋矩阵 思路： 一层层剥开矩阵，用矩阵的四个边界控制，每走一圈（每剥开一层），矩阵缩小一次 var spiralOrder = function(matrix) { const rows = matrix.length; /* 行数 */ const columns = matrix[0].length; /* 列数 */ let res = []; if(rows==0 || columns==0){ return res; } let left = 0, right = columns - 1, top = 0, bottom = rows - 1; while(left\u003c=right \u0026\u0026 top\u003c=bottom){ for(let j=left; j\u003c=right; j++){ res.push(matrix[top][j]); } for(let i=top+1; i\u003c=bottom; i++){ res.push(matrix[i][right]); } if(left\u003cright \u0026\u0026 top\u003cbottom){ for(let j=right-1; j\u003eleft; j--){ res.push(matrix[bottom][j]); } for(let i=bottom; i\u003etop; i--){ res.push(matrix[i][left]); } } [left,right,top,bottom] = [left + 1, right - 1, top + 1, bottom - 1]; } return res; }; 时间复杂度：O(mn)，遍历矩阵 空间复杂度：O(1)，除了返回的数组，没有用到多余空间 执行用时：60ms，击败了99.00%的用户 内存消耗：37.7MB，击败了48.38%的用户 官方题解： 一样 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"贪心 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:9:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1736. 替换隐藏数字得到的最晚时间 思路: 从第一位开始判断：因为第一位最重要，直接if else枚举 var maximumTime = function(time) { const arr = Array.from(time); //Array.from:从一个类似数组或可迭代对象创建一个新的、浅拷贝的数组实例 if(arr[0]=='?'){ if(arr[1]\u003c=4 || arr[1]=='?'){ arr[0] = 2; } else{ arr[0] = 1; } } if(arr[1]=='?'){ if(arr[0]=='?' || arr[1]==2){ arr[1] = 4; } else{ arr[1] = 9; } } if(arr[3]=='?'){ arr[3] = 5; } if(arr[4]=='?'){ arr[4] = 9; } return arr.join(''); //用join方法来将各元素连接 }; 时间复杂度：O(1) 空间复杂度：O(1) 执行用时：72ms，击败了90.00%的用户 内存消耗：37.8MB，击败了84.00%的用户 官方题解 var maximumTime = function(time) { const arr = Array.from(time); if (arr[0] === '?') { arr[0] = ('4' \u003c= arr[1] \u0026\u0026 arr[1] \u003c= '9') ? '1' : '2'; } if (arr[1] === '?') { arr[1] = (arr[0] == '2') ? '3' : '9'; } if (arr[3] === '?') { arr[3] = '5'; } if (arr[4] === '?') { arr[4] = '9'; } return arr.join(''); }; 思路一致，官方代码利用正则表达式，更加简洁 贪心算法：是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优算法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:9:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"哈希表 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"705. 设计哈希集合 var MyHashSet = function() { this.BASE = 769; // 哈希函数用的取模方法，选取一个较大质数 this.data = new Array(this.BASE).fill(0).map(() =\u003e new Array()); }; MyHashSet.prototype.add = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { return; // 已经存在，不添加 } } it.push(key); }; MyHashSet.prototype.remove = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { it.splice(i, 1); // 删除 return; } } }; MyHashSet.prototype.contains = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { return true; } } return false; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"706. 设计哈希映射 var MyHashMap = function() { this.BASE = 769; this.data = new Array(this.BASE).fill(0).map(() =\u003e new Array()); }; MyHashMap.prototype.put = function(key, value) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { it[1] = value; return; } } this.data[h].push([key, value]); }; MyHashMap.prototype.get = function(key) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { return it[1]; } } return -1 }; MyHashMap.prototype.remove = function(key) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { this.data[h].splice(this.data[h].indexOf(it), 1); return; } } }; MyHashMap.prototype.hash = function(key) { return key % this.BASE; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1.两数之和 思路： 暴力，双重循环 哈希表 var twoSum = function(nums, target) { let hashMap = {}; for(let i = 0; i \u003c nums.length; i++){ if(hashMap[target - nums[i]] !== undefined){ return [i, hashMap[target - nums[i]]]; } hashMap[nums[i]] = i; //存放的是该元素的索引值 } return []; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"128. 最长连续子序列 思路： 因为时间复杂度要求为O(n)，所以不能使用排序算法。而很自然就想到应该使用哈希表来解决这个问题let hashNums = new Set(nums) 得到这样一个集合后，对于在数组内的元素，我们查找它的左邻居(比它小1的数字)是否在集合里，若在则长度加一，并保存长度然后从它的右邻居开始找，直到它的右邻居不在集合里 var longestConsecutive = function(nums) { res = 0 let myHash = new Set(nums) for(let num of myHash) { if(!myHash.has(num - 1)) { let currentNum = num let currentLen = 1 while(myHash.has(currentNum + 1)) { currentNum++ currentLen++ } res = Math.max(res, currentLen) } } return res }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["面经"],"content":"网易雷火一面 自我介绍 移动端自适应 小游戏性能优化 分包加载预加载 模型怎么优化 cocos内部怎么自适应，原理 webpack CSS动画 垂直居中，水平居中 this指向 构造函数的this 箭头函数的this 箭头函数和普通函数的区别 可不可以构造函数，为什么 this arguments Promise setTimeout 宏任务微任务 事件循环 为什么不可以完全精确到1ms vue双向数据绑定 详细讲讲vue干了啥 vue3的区别 defineProperty具体做了啥，怎么做的 数据库连接 用的什么库，什么框架 博客 md怎么转html 用什么打包的 反问 部门主要做什么工作 游戏官网和活动页面制作 内部前端工程化 小游戏开发 ","date":"2021-02-14","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"网易雷火前端实习_一面","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E4%B8%80%E9%9D%A2/"}]