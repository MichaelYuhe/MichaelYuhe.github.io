[{"categories":["program"],"content":"ECMA Script6 学习记录 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:0:0","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"继承 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:0","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"1.原型链继承 function Parent() { this.name = 'Michael' } Parent.prototype.getName = function() { console.log(this.name) } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.getName() // 'Michael' 缺陷： 引用类型的属性被所有实例共享 function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+', 'Lily'] 在创建Child实例时不能向Parent传参 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:1","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"2.借用构造函数（经典继承） function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { Parent.call(this) } var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+'] 优点： 避免了引用类型的属性被所有实例共享 可以在Child中向Parent传参 function Parent (name) { this.name = name } function Child (name) { Parent.call(this, name) } var child1 = new Child('kevin') console.log(child1.name);// kevin var child2 = new Child('daisy') console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:2","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"3.组合继承 function Parent() { this.name = name this.colors = ['black', 'pink'] } Parent.prototype.getName = function() { console.log(this.name) } function Child(name, age) { Parent.call(this, name) this.age = age } Child.prototype = new Parent() Child.prototype.constructor = Child var child1 = new Child('Lily', 18) child1.colors.push('blue') console.log(child1.name) // Lily console.log(child1.age) // 18 console.log(child1.colors) // ['black', 'pink', 'blue'] var child2 = new Child('Mike', 22) console.log(child2.name) // Mike console.log(child2.age) // 22 console.log(child2.colors) // ['black', 'pink'] 优点： 融合了原型链继承和经典继承的优点，是JavaScript中最常用的继承方式 缺点： 调用了两次父构造函数 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:3","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"4.原型式继承 function createObj(o) { function F() {} F.prototype = o return new F() } 缺点： 和原型链继承一样，包含引用类型的属性值始终都会共享相应的值 var person = { name: 'Mike', friends: ['Lily', 'Daisy'] } var person1 = createObj(person) var person2 = createObj(person) person1.name = 'person1' console.log(person2.name) // Mike person1.friends.push('Cole') console.log(person2.friends) // ['Lily', 'Daisy', 'Cole'] 此处修改person1.name的值，可以看到person2.name并未改变，并非因为二者有独立的name值，而是因为是给person1添加了name值，而非修改原型上的name值 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:4","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"5.寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 function createObj(o) { var clone = Object.create(o) clone.sayName = function() { console.log('hi') } return clone } 缺点： 和经典继承一样，每次创建对象都会创建一次方法 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:5","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"6.寄生组合式继承 引用类型最理想的继承范式 ","date":"2021-09-08","objectID":"https://MichaelYuhe.github.io/es6/:1:6","tags":["ES6","JavaScript"],"title":"ES6Learning","uri":"https://MichaelYuhe.github.io/es6/"},{"categories":["program"],"content":"前言  学习完基础的三剑客后，决定开始学习框架。无非就两种选择，Vue或是React，了解了一番二者的区别，再看着文档写了两个教程demo，二者具体深层的区别并没有太大了解也没有感受到，单纯觉得Vue更加适合我😂，于是就选择了学习Vue。至于Vue和React两个框架的区别，具体可以看看这篇文章  看完了文档，迫不及待想撸出自己第一个Vue应用，但仍不知道如何下手，对Vue应用的搭建的流程也并不了解，所以选择了观看一个很优秀的Youtuber – Traversy Media的“Vue crash course”，看完视频后去复现他的代码，然后再自己修改样式、添加功能等等…… ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:1","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"成品 点击Add Task按钮，弹出输入框，可以输入任务的具体内容和时间安排 待办的任务将会在下方显示，每个任务的右侧有两个功能按钮，分别是编辑和删除 数据储存于本地的json文件中，刷新浏览器或重新启动服务能照常读取数据 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:2","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"todo 将json数据部署到云端，达到无需启动node服务即可访问的效果 调整布局，美化项目 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:3","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"如何给自己的博客添加一键回到顶部的功能？  今天用Hugo搭好了博客，美化、自定义什么的先放在一边，单纯用框架改改参数什么的，总感觉技术含量不高嘛（高了我也做不出来），就想着先添加个小功能，提供一个一键回到顶部的功能。让我们开始吧。  本文以Hugo框架，LoveIt主题为例。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:0","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加样式 在CSS中，定义返回顶部按钮的样式。打开Hugo主题目录下的 static/asserts/_custom.scss，在其中加入样式代码。 .backtop { color: #b3b1b1; position: fixed; right: 16px; bottom: 20px; width: 33px; height: 33px; z-index: 10000; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:1","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"导入按钮图标 准备好按钮的图标，前往Font Awesome找到心仪的图标，下载其SVG文件，打开后全部复制 在Hugo主题目录下layouts/partials新建back2top.html文件，将拷贝的代码放入 \u003csvg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"chevron-circle-up\" class=\"svg-inline--fa fa-chevron-circle-up fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e \u003cpath fill=\"currentColor\" d=\"M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z\"\u003e \u003c/path\u003e \u003c/svg\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:2","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加锚点 在当前目录下找到header.html文件并打开，在任意行加入以下代码 \u003cspan id=\"top\"\u003e\u003c/span\u003e 来到layouts/_default文件夹，打开single.html，添加以下代码(与content同级) {{- define \"main\" -}} \u003ca href=\"#top\" class=\"backtop\"\u003e{{ partial \"back2top.html\" . }}\u003c/a\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:3","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"大功告成！ ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:4","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"}]