[{"categories":["Program"],"content":"Node.js初体验 — nodemailer的使用 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:0","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"写在前面 需求：给自己的todo应用添加一个邮件提醒的功能，当创建了任务则会发送邮件至指定邮箱 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:1","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"历程 作为一个Node.js小白，其他网络的知识也几乎没接触过，踩了许多的坑。 首先，经网上查找，找到了nodemailer这个库，兴致勃勃地下载，根据官方文档配置使用，在本地node环境中成功发送了测试邮件。 但当我把它放到我基于vue框架的todo应用中时，运行却报错了。nodemailer**仅可以在node环境中使用！**也就意味着项目需要前后端分离，并且需要前端与后端的交互。 没错，就是这个问题，一个简单的前后端交互困扰了我一整天。 最开始，自信满满的我，由于想把自己的项目都部署上线，本就有购买服务器的想法，直接去腾讯云购买了一个轻量应用服务器。将服务器配置了Node.js的应用镜像，将之前在本地node环境中运行的代码部署在服务器上直接运行，成功发送邮件至指定邮箱。 接着，就是分析逻辑：我要做的事情，无非就是向服务器上传邮件具体内容到服务器，同时发起发送邮件的请求，达到前端填写内容，按下发送按钮，服务端即可发送邮件的效果。 要能够向服务器发起请求，显然首先要能够访问到该服务器。在vue中引入了axios（没错这也是我第一次使用它），向服务器发起一个简单的get请求，结果却抛出了错误 has been blocked by CORS policy。 这是由于请求是跨域进行的。跨域的原因和解决方案后续将在另一篇文章知识点总结中提到，此处仅关注这个需求。 Vue就自带了一个使用代理来解决跨域的方案。代理的作用：监测本地的接口，当接口为需要访问外网的接口时，代理替你访问这个接口并把返回值返回给当前网页 为方便测试，在本地起了一个node服务。 // app.js const express = require('express'); const app = express(); const email = require('./email'); app.get('/', (req, res) =\u003e { res.send('Hello') }) app.use('/email', email); // 监听端口3000 app.listen(3000, () =\u003e console.log('Service start at port 3000...')) // email.js const express = require('express'); const email = express.Router(); // 创建express路由 const nodemailer = require('nodemailer'); // 导入nodemailer const transporter = nodemailer.createTransport({ // 以qq邮箱为例 service: 'QQ', port: 465, secureConnection: true, auth: { user: '2312744987@qq.com', pass: '自行获取（SMTP授权码，而非邮箱密码）', } }); email.get('/', (req, res) =\u003e { const { to, html, subject } = req.query; // 将请求解构 const from = '\"XYH\"\u003c2312744987@qq.com\u003e'; const mailOptions = { from, to, subject, html, }; transporter.sendMail(mailOptions, (error, info) =\u003e { if (error) return console.log(error); console.log(info); }); }); module.exports = email; 在终端中输入命令 node app.js，即可在本地主机的3000端口启动服务。 那么在Vue中，如何配置代理呢？ 来到我们项目中的vue.config.js文件，添加以下代码。 devServer: { proxy: { 'test': { target: 'http://localhost:4000', changeOrigin: true, logLevel: 'debug', pathRewrite: {'^/test' : '/'} } } }, 那么当我们访问/api/xxxx接口时，webpack会识别到它是对外的接口，并访问target，将结果返回。接下来编写请求代码。 axios({ url: \"test/email\", method: \"get\", params: { to: \"xiayuhang1106@gmail.com\", subject: \"A New Task\", html: `\u003ch2\u003e${this.title}\u003c/h2\u003e \u003cp\u003econtent\u003cp/\u003e`, }, }) .then((res) =\u003e console.log(res)) .catch((err) =\u003e console.log(err)); 上述代码发送了一个携带参数的axios请求，请求发送至配置好的代理端口的email中，请求发送电子邮件。 点击发送后，服务端打印出邮件信息，代表发送成功。 查看我们的邮箱，也可以看到该新到达的热乎的邮件。 下一步，就是在服务器端复现这个功能，省去每次都需要自己在本地启动服务的步骤。 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:2","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"结语 这是第一次真正意义上的接触Node.js，前前后后摸索了一天半，也学习到了很多知识：跨域、Linux基本操作、服务器部署、axios等。最后也成功实现了发送邮件的功能，虽然不太实用，后期需要想办法修改为定时发送的服务，到了设定时间前一天再发送邮件提醒。 不得不感慨真的是学无止境呀。还有许多东西需要自己去慢慢学习。 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:3","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"年轻人的第一个项目 Vusic ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:0","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"项目简介 Vusic是一个使用Vue3作为框架的在线音乐播放器，目前仅适配了移动端，桌面版的适配工作正在进行中。后端采用QQ音乐API来获取歌曲等数据。 以下是Vusic各界面截图及功能介绍。 播放界面 【待补充】 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:1","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"开发中学到了什么 Composition API的使用 Vue3中新增了Composition API，代替之前的Options API，在逻辑、功能较多时，能使代码更简洁，有效降低耦合度，实现同一功能的代码分离到单独的文件，通过setup()调用以及返回到模板中，不需要再把所有data、所有methods等等都挤在同一个文件中。 代码复用和模块化的思想 当有一段代码需要用到多次，不应该复制粘贴，而是需要学会将其封装起来，以方便复用。 要将大的项目模块化，更有助于我们的开发。在进行项目的开发之前，根据设计图和设计框架进行分析抽象，通过对结构和功能的划分来划分出具体的相应的模块。 学会封装一些基础的组件作为基本的模块，其他组件可能就只需要由已经封装好的基础组件拼装而成，不需要重新编写界面和逻辑。就如本项目中的音乐列表界面，可以从排行榜、歌手详情、推荐歌单等等进入，皆是他们的子路由，封装成基础组件，就减少了许多重复的工作。 而同一模块的代码和文件应该统一存放在一个文件夹中，方便代码的管理。 Sass的使用 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库有助于更好地组织管理样式文件，以及更高效地开发项目。 后端接口的使用及数据的处理 后端数据由QQ音乐API获取 // 对 axios get 请求的封装 function get(url, params) { return axios.get(url, { headers: { referer: 'https://y.qq.com/', origin: 'https://y.qq.com/' }, params: Object.assign({}, commonParams, params) }) } // 对 axios post 请求的封装 function post(url, params) { return axios.post(url, params, { headers: { referer: 'https://y.qq.com/', origin: 'https://y.qq.com/', 'Content-Type': 'application/x-www-form-urlencoded' } }) } 性能优化 keep-alive 使用Vue的keep-alive，缓存访问过的路由，有效地避免切换路由时重复多余的网络请求。 \u003crouter-view v-slot=\"{ Component }\"\u003e \u003ckeep-alive\u003e \u003ccomponent :is=\"Component\"/\u003e \u003c/keep-alive\u003e \u003c/router-view\u003e 异步加载路由组件 用工厂模式导入路由组件，使路由组件达到按需加载的效果。 const Singer = () =\u003e import('@/views/Singer'/* webpackChunkName: \"singer\" */) 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令 本项目中，创建了三个自定义指令。v-lazy和v-loading和v-no-result 注册指令： 使用Vue.directive('command name')来全局注册指令 钩子函数 一个指令定义对象可以提供以下几个钩子函数 bind：只调用一次，在指令第一次绑定到元素时调用 inserted：被绑定元素插入父节点时调用 update：所在组件的VNode更新时调用 componentUpdated：指令所在组件的VNode和其子VNode全部更新后调用 unbind：只调用一次，解绑时调用 钩子函数参数 el：指令所绑定的元素，可以用它来操作DOM binding：一个包含传递给钩子的参数的对象。有许多可用的参数，包括name，value，oldValue，expression，arg和modifiers。 vnode：Vue编译生成的虚拟节点 oldVnode：上一个虚拟节点 自定义指令实例： 以本项目中自定义组件为例。由于几个自定义指令的逻辑大体相同，将其封装为createLoadingLikeDirective文件。 // 创造自定义指令 export default function createLoadingLikeDirective(Comp) { return { mounted(el, binding) { const app = createApp(Comp) const instance = app.mount(document.createElement('div')) const name = Comp.name if (!el[name]) { el[name] = {} } el[name].instance = instance const title = binding.arg if (typeof title !== 'undefined') { instance.setTitle(title) } if (binding.value) { append(el) } }, updated(el, binding) { const title = binding.arg const name = Comp.name if (typeof title !== 'undefined') { el[name].instance.setTitle(title) } if (binding.value !== binding.oldValue) { binding.value ? append(el) : remove(el) } } } function append(el) { const name = Comp.name const style = getComputedStyle(el) if (['absolute', 'fixed', 'relative'].indexOf(style.position) === -1) { appendClass(el, relativeCls) } el.appendChild(el[name].instance.$el) } function remove(el) { const name = Comp.name removeClass(el, relativeCls) el.removeChild(el[name].instance.$el) } } ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:2","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"开发中的难点 【待补充】 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:3","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"todos 支持创建歌单 Material you设计 主题的切换 自动取色功能 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:4","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"下一阶段该做的事情 开发新的项目。项目选题：Material Vue（Vue项目样式改变的组件）/ 自定义生成头像的网站 / 记账工具； 学习计算机网络的知识 深入学习JavaScript ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:5","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["program"],"content":"知识点总结 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"Javascript ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"执行上下文 当JavaScript执行一段可执行代码时，会创建相应的执行上下文 对于每个执行上下文，都有三个重要的属性 变量对象 作用域链 this ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"讲一下闭包 闭包的定义 闭包是指那些能够访问自由变量的函数。那么什么是自由变量？自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。那么可以看出，闭包 = 函数 + 函数能够访问的自由变量 所以，从技术的角度讲，所有的JavaScript函数都是闭包。 即使创建它的执行上下文已经被销毁了，但它还是存在； 在其中引用了自由变量 var data = [] for(var i = 0; i \u003c 3; i++) { data[i] = function() { console.log(i) } } data[0]() // 3 data[1]() // 3 data[2]() // 3 // 使用闭包 var data = [] for(var i = 0; i \u003c 3; i++) { data[i] = (function(i) { return function() { console.log(i) } }) } data[0]() // 0 data[1]() // 1 data[2]() // 2 // var改成let也可以 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:2","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"原型和原型链 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:3","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"讲一下继承 1.原型链继承 function Parent() { this.name = 'Michael' } Parent.prototype.getName = function() { console.log(this.name) } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.getName() // 'Michael' 缺陷： 引用类型的属性被所有实例共享 function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+', 'Lily'] 在创建Child实例时不能向Parent传参 2.借用构造函数（经典继承） function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { Parent.call(this) } var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+'] 优点： 避免了引用类型的属性被所有实例共享 可以在Child中向Parent传参 function Parent (name) { this.name = name } function Child (name) { Parent.call(this, name) } var child1 = new Child('kevin') console.log(child1.name);// kevin var child2 = new Child('daisy') console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法 3.组合继承 function Parent() { this.name = name this.colors = ['black', 'pink'] } Parent.prototype.getName = function() { console.log(this.name) } function Child(name, age) { Parent.call(this, name) this.age = age } Child.prototype = new Parent() Child.prototype.constructor = Child var child1 = new Child('Lily', 18) child1.colors.push('blue') console.log(child1.name) // Lily console.log(child1.age) // 18 console.log(child1.colors) // ['black', 'pink', 'blue'] var child2 = new Child('Mike', 22) console.log(child2.name) // Mike console.log(child2.age) // 22 console.log(child2.colors) // ['black', 'pink'] 优点： 融合了原型链继承和经典继承的优点，是JavaScript中最常用的继承方式 缺点： 调用了两次父构造函数 4.原型式继承 function createObj(o) { function F() {} F.prototype = o return new F() } 缺点： 和原型链继承一样，包含引用类型的属性值始终都会共享相应的值 var person = { name: 'Mike', friends: ['Lily', 'Daisy'] } var person1 = createObj(person) var person2 = createObj(person) person1.name = 'person1' console.log(person2.name) // Mike person1.friends.push('Cole') console.log(person2.friends) // ['Lily', 'Daisy', 'Cole'] 此处修改person1.name的值，可以看到person2.name并未改变，并非因为二者有独立的name值，而是因为是给person1添加了name值，而非修改原型上的name值 5.寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 function createObj(o) { var clone = Object.create(o) clone.sayName = function() { console.log('hi') } return clone } 缺点： 和经典继承一样，每次创建对象都会创建一次方法 6.寄生组合式继承 引用类型最理想的继承范式 function object(o) { function F() {} F.prototype = o; return new F(); } function prototype(child, parent) { var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype; } // 当我们使用的时候： prototype(Child, Parent); ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:4","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"跨域原理和解决方案 什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 而我们常说的跨域是狭义上的，是由浏览器同源策略限制的一类请求场景。浏览器的同源策略会导致跨域。 同源策略 同源：协议、域名和端口都相同。 同源策略限制以下行为 无法读取cookie，localStorage和indexDB 无法获得DOM和js对象 不能发送AJAX请求 跨域解决方案 1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:5","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"JS是单线程还是多线程的？ JavaScript是单线程的： JS的一大特点就是单线程。也就是说，同一时间只能做一件事。这是因为JavaScript是脚本语言，是为处理页面中用户的交互以及操作DOM产生的，所以若其是多线程，会带来很复杂的同步问题。所以为了避免复杂性，JavaScript一诞生起就是单线程，已经成为了这门语言的核心特征。 既然JavaScript是单线程的，那么它怎么执行异步的代码？ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。但JS引擎执行异步代码并不需要等待，是因为有消息队列和事件循环。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:6","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"JS中new具体做了些什么？ new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例 new会进行哪些操作？ 创建一个简单的空的JavaScript对象，即{ } 为步骤一创建出的对象添加属性__proto__ ，将该属性链接至构造函数的原型对象 将步骤一创建的对象作为this的上下文 如果该函数没有返回对象，则返回this ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:7","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"手写new function objectFactory() { // 新建一个对象 var obj = new Object() Constructor = [].shift.call(arguments) // 将obj的原型指向构造函数 obj.__proto__ = Constructor.prototype // 使用 apply，改变构造函数 this 的指向到新建的对象res var res = Constructor.apply(obj, arguments) return typeof res === 'object' ? res : obj } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:8","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"变量提升 为什么可以先调用再声明？这是因为JavaScript的工作方式是执行上下文，在执行任何代码段之前，将函数声明放入内存。 JavaScript只会提升声明，而不会提升其初始化。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:9","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"立即执行函数 IIFE(Immediately Invoked Function Expression),在定义后立即执行的JavaScript函数 (function() { statements;})(); 第一部分是包围在()里的一个匿名函数，该函数拥有独立的块级作用域，避免了外界访问此IIFE的变量，也不会污染全局作用域。 第二部分再次使用()创建了一个立即执行函数表达式，JavaScript引擎到此将直接执行函数。 将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:10","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"浮点数精度 数字类型 ECMAScript中的Number类型使用IEEE754标准，全称 IEEE 二进制浮点数算术标准，来表示整数和浮点数值。 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。 浮点数转二进制 先看0.75转二进制 $0.75 = a * 2^{-1} + b * 2^{-2} + c * 2^{-3} …$ 两边同时乘2， $1 + 0.5 = a * 2^{0} + b * 2^{-1} + …$ 得出a = 1，剩下的再乘2 $1 = b * 2^{0} + c * 2^{-1} + …$ 得出b = 1，其余为0 所以$0.75_{10} = 0.11_{2}$ 但并非每一个小数都这么好计算，就比如$0.1 = 0.00011001100110011…$ 是无限循环的 浮点数的存储 即使有些浮点数转成二进制是无限循环的，但我们仍需要存储它。在IEEE754中，一个浮点数表示方法为 $Value = sign * exponent * fraction$ 比如说，0.1的二进制表示，就是$1 * 2^{-4} * 1.1001100110011…$ 当只做二进制科学计数法的表示，value可以更具体。$Value = (-1)^{sign} * (1 + fraction) * 2^{exponent}$ $(-1)^{sign}$表示符号位，sign为0为正数。再看$(1 + fraction)$，前面的1是共有的，不用存储，只需要存储1.xxxxx中的xxxxx。最后看$2^{exponent}$真正存储时，并不会直接存exponent，而是存$exponent + bias$。 所以要存储一个浮点数，只需存储sign、fraction、(exponent + bias)这三个值。其中sign用到一位，(exponent + bias)用到11位，fraction用到剩下的52位 所以当0.1这样的数被存储下来时，就已经发生了精度丢失。 浮点数的运算 五个步骤：对阶、尾数运算、规格化、舍入处理、溢出判断 两次存储时的精度丢失加上一次运算时的精度丢失，导致$0.1 + 0.2 !== 0.3$ ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:11","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"CSS ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"BFC Block Formatting Contexts (块级格式化上下文)。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"水平居中 对于行内元素： text-align: center; 对于块级元素 { margin: 0 auto; } { display: flex; justify-content: center; } { position: absolute; left: 50%; transform: translate(-50%, 0); } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:2","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"垂直居中 对于行内元素 .parent { height: h; } .child { line-height: h; } 对于块级元素 table，元素高度可以动态改变 .parent { display: table; } .child { display: table-cell; vertical-align: middle; } flex，内容块宽高任意；可以用于更复杂高级的布局技术 .parent { display: flex; align-items: center; } 绝对定位 .son { position: absolute; top: 50%; transform: translate(0, -50%); } .son { position: absolute; top: 0; bottom: 0; margin: auto 0; } /* 适用于所有浏览器 */ .son { position: absolute; top: 50%; height: 高度; margin-top: -0.5高度; } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:3","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"HTML \u0026 浏览器 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"讲一下DOM树 什么是DOM？ 从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。 简而言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容 DOM的作用？ 页面的视角，生成页面的基本结构 Javascript脚本视角，提供脚本操作的接口 安全视角，是一道安全防线，一些不安全的内容在DOM解析阶段就被拒绝 DOM怎么生成的？ 渲染引擎内部，有一个叫HTML解析器的模块，负责将HTML字节流转换成DOM，网络进程加载了多少数据，解析器便解析多少数据 第一阶段，通过分词器将字节流转换成Token，分为Tag Token和文本Token 第二阶段（将Token解析为DOM节点）和第三阶段（将DOM节点添加到DOM树）是同时进行的 HTML解析器维护了一个Token栈结构，根据转换的Token来维护这个栈，进行出栈入栈的操作 DOM解析中的影响因素 遇到JavaScript脚本时，需要暂停整个DOM的解析，先执行JavaScript代码。原因：Javascript脚本可能更改原有的节点 可以通过预解析操作：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件 来优化 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"路由 为什么要使用路由 单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。 hash模式 使用window.location.hash属性以及窗口的onhashchange事件，实现监听浏览器地址hash值变换，执行相应的js来切换网页 hash指的是地址中#号以及后面的字符，也称散列值。 散列值并不随请求发送到服务器端，所以改变hash不会重载页面 当散列值改变，通过window.location.hash属性获取和设置hash值 window.location.hash的变化会直接反映到浏览器地址栏 history模式 window.history属性指向History对象，代表当前窗口的浏览历史。History对象保存了当前窗口访问过的所有页面网址，通过history.length可以知道当前窗口访问过几个网址。 方法：history.back(); history.forward(); history.go(); history.pushState(); history.replaceState() ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:2","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"跨页面通信 同源页面 广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent 共享存储模式：Shared Worker / IndexedDB / cookie 口口相传模式：window.open + window.opener 基于服务端：Websocket / Comet / SSE 非同源页面 嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:3","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"缓存机制 浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:4","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"本地存储 本地存储共有三种方式，coookie，localStorage和sessionStorage 三者的异同 特性 cookie localStorage sessionStorage 生命周期 一般由服务器端生成，会设置失效时间。若没有设置，则默认关闭浏览器时清除 除非手动清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 5M 5M 与服务器端通信 每次都会被携带在HTTP请求头部中，若使用cookie保存过多数据会带来性能问题 仅在客户端保存，不与服务器端进行通信 仅在客户端保存，不与服务器端进行通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景 cookie：存储用户登录信息。针对登陆过的用户，服务器端会在他登陆时在cookie中插入一段加密过的唯一辨识单一用户的辨识码。cookie还需要指定作用域，不可以跨域调用。 localStorage可以用来夸页面传递参数，代替了cookie保存用户购物车信息的工作。sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。 安全性 并非所有数据都适合保存在上述三者中。只要打开控制台，就可以随意修改他们的值。所以重要的数据需要保存在服务器端而非客户端。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:5","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"计算机网络 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"TCP三次握手和四次挥手 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"TCP和UDP的区别 UDP 用户数据包协议，一个简单的面向数据的通信协议，对于应用层传递下来的报文，它只会简单地加上首部，就交给网络层，不会做合并或者拆分的工作。特点如下 不提供复杂的控制机制，利用IP提供面向无连接的通信服务 传输过程中若出现了丢包，UDP也不会重发 包的到达顺序错乱了的话，UDP也无法纠正 无法进行流量控制等避免网络堵塞的行为 首部8个字节 发送端只负责将数据发送到网络，接收端从消息队列读取 支持一对一、一对多、多对一和多对多的交互通信 TCP 传输控制协议，是一种可靠的、面向字节流的通信协议，把应用层传递下来的数据看做是无结构的字节流来发送。，会根据当前网络的堵塞情况来确定每个报文段的大小。 充分地实现了数据传输时的各种控制功能，可以进行重发控制、顺序控制 作为一种面向连接的服务，只有在确认通信对端的存在后才会发数据，控制通信流量的浪费 建立连接3次握手、断开连接四次挥手 根据TCP的机制，在IP这种无连接的网络上也能实现高可靠性的通信。 首部20字节 只能点对点全双工通信 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:2","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"https和http的区别 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:3","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"七层网络模型 应用层 该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务；在应用层交互的数据单元称为报文。应用层协议：HTTPS、DNS等 表示层 表示层的作用是使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异 会话层 会话层就是负责建立、管理和终止表示层实体之间的通信会话。提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法 传输层 主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。主要的传输层协议是TCP和UDP 网络层 在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。 链路层 在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧 物理层 和软件关系不大，确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性） ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:4","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"跨域 自己实际中遇到跨域的解决方案： 跨域资源共享CORS 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 整个CORS过程，都是由浏览器自动完成，浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会有一次附加的预检请求（对于非简单请求）所以我们只需要关注服务端如何实现 Vue设置proxy代理 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:5","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"webpack ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"性能 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"重排和重绘 重排重绘是什么？ 重排：也叫回流，当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排 添加或者删除可见的DOM元素 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 “重绘\"不一定会出现\"重排”，“重排\"必然会出现\"重绘” ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"优化方法 尽可能减少重排的次数和范围：重排的性能花销跟渲染树有多少节点需要重新构建有关系，我们应尽量以局部布局的方式组织HTML 分离读写操作，防止多次拿值触发渲染 样式集中改变 缓存布局信息 离线改变DOM position多用absolute和fixed，这样不用考虑他对其他元素的影响 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:2","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"白屏 概念 白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。 白屏期间发生了什么？ DNS Lookup 浏览器会先对页面进行域名解析，获取到服务器的IP地址后，进而和服务器进行通信。 建立TCP请求连接 服务端处理响应 在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。 客户端下载、解析、渲染显示页面 白屏优化 针对白屏期间的环节进行逐一优化 DNS缓存优化、DNS预加载、稳定可靠的DNS服务器 TCP网络链路优化 服务端处理优化 尽可能精简HTML、CSS代码和结构。合理放置JS代码 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:3","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"Vue ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"通信方式 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"生命周期 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:2","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"理解双向数据绑定 双向绑定由三个部分组成：数据层（Model）、视图层（View）、业务逻辑层（ViewModel）。其中最重要的是那个ViewModel，主要职责是数据变化后更新视图，视图变化后更新数据。包含两部分，监听器和解析器。监听器用来监听所有数据的属性，解析器对每个元素节点的指令进行扫描和解析，根据指令模板替换数据,以及绑定相应的更新函数 Vue里的双向绑定流程 初始化，对data执行相应化处理，该过程发生在监听器 同时编译模板，找到里面动态绑定的数据，然后获取、初始化视图层，发生在解析器里 然后定义更新函数和一个Watcher，Watcher来观察数据是否变化了，如果变化就调用更新函数 然后因为某些data会出现多次，就要有多个watcher来观测他，所以对每一个data就准备一个管家来管理那些watcher 如果data变了，就先找他对应的管家，然后通知里面的每一个观察者watcher ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:3","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"computed和watch computed computed设计的初衷是为了使模板中的逻辑运算更简单, 在模板中有很多复杂的数据计算的话, 可以把该计算逻辑放到computed中 computed是计算属性的，会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。 应用场景： 一些重复使用的数据或复杂及费时的运算，可以放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取。 如果需要的数据依赖于其他的数据, 我们可以把该数据设计为computed中。 computed和methods的区别 computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值。而methods不是响应式的，每次调用都会重新求值 omputed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get / set变成可读写属性, 但是methods中的成员没有这样的。 watch watch是一个对data数据的监听回调, 当依赖的数据变化时, 会执行回调。在回调中，会传入newVal和oldVal两个参数。 Vue实例会在实例化时调用$watch()，遍历watch对象的每一个属性。 应用场景： 当在data中的某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时. 我们就可以使用watch来进行监听 watch和computed的异同 相同：都是观测页面数据变化的 不同：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。watch每次都需要执行函数。watch更适用于数据变化时的异步操作。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:4","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"Vue3新特性 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:5","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"diff算法 是什么 diff 算法是一种通过同层的树节点进行比较的高效算法，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较。 它有两个特点 比较只会在相同层级进行，不会跨级比较 在具体某一层的diff比较中，循环从两边向中间比较 原理分析 数据发生改变，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 先看patch。接收四个参数，第一个是旧节点oldVnode，第二个是新节点vnode。 没有新节点，那么直接把旧的删光，触发旧节点的destroy钩子 没有旧节点，直接生成新的就可以了，createElm 通过sameNode判断两个节点一不一样，一样的话直接patchVnode，不一样的话创建新节点，删除旧节点 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:6","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"Composition API ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:7","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"操作系统 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:8:0","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["program"],"content":"进程和线程的区别： 进程，是程序的依次执行过程，是程序在执行过程中分配和管理资源的基本单位，每个进程都有自己的地址空间，至少有五种状态：初始态，执行态，等待状态，就绪状态，终止状态。 线程，是CPU调度和分派的基本单位，可以和同一进程下的其他线程共享全部资源 二者联系：线程是进程中的一部分，一个进程可以有多个线程，但一个线程只能存在于一个进程中。 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:8:1","tags":null,"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["Program"],"content":"Vuex使用小结 ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:0","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"写在前面 虽如官方文档所说：“如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex”。没错，我的应用就是够简单的那个😂 但随着深入学习，迟早也需要掌握Vuex的使用，何不现在就用上他呢？ ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:1","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。（摘自Vue3官方文档） 该状态自管理应用包含三部分 state，状态，驱动应用的数据源 view，视图，以声明方式将state映射到视图 actions，操作，响应在视图上的用户输入导致的状态变化 Vuex可以帮助我们更好地管理共享状态 ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:2","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"开始使用Vuex 引入 npm i install vuex 在src文件夹下新建store目录，在其中新建index.js文件 import { createStore } from \"vuex\" export default createStore({ state: {}, mutations: {}, actions: {}, modules: {} }) 实例 往state中存入我们所需要共享的数据和操作 state: { isLogin: false, configs: [ { title: \"theme\", property: true, id: 1 }, { title: \"enableDelete\", property: true, id: 2 } ] }, mutations: { login(state) { state.isLogin = true } } 存放好了数据，该怎么查看、使用和更改这些数据呢？ 要调用这些数据，需要通过store.state来获取 // 任意组件/视图下 console.log(this.$store.state.isLogin) 我们不能直接更改数据，需要通过提交mutation的方式来改变。例如，当我们点击了登录按钮 methods: { login() { this.$store.commit('login') } // 当需要同时传递数据 this.$store.commit('mutationName', data1, data2) } ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:3","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"解决页面刷新数据丢失问题 store里的数据是保存在运行内存中的，每当页面刷新，就会重载Vue实例，store里的数据就会被重新赋值初始化。 要解决这个问题，就需要想办法把数据存储在本地（localStorage, sessionStorage, cookie三者之一中）。三者区别 由于创建的是单页面应用，操作只是在一个页面跳转路由，因此选择sessionStorage. 具体操作： 在页面初始化和每次更新时，读取sessionStorage的数据存储到store中，使用Vuex的replaceState方法来替换store的根状态 在beforeunload方法中，将store.state存储到sessionStorage. // App.vue created() { //在页面加载时读取sessionStorage里的状态信息 if (sessionStorage.getItem(\"store\")) { this.$store.replaceState( Object.assign( {}, this.$store.state, JSON.parse(sessionStorage.getItem(\"store\")) ) ); } //在页面刷新时将vuex里的信息保存到sessionStorage里 window.addEventListener(\"beforeunload\", () =\u003e { sessionStorage.setItem(\"store\", JSON.stringify(this.$store.state)); }); }, ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:4","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"数据更新页面不更新的问题 解决完数据丢失的问题，又遇到了更新数据页面不随之更新的问题。从底层出发进行分析。 原来的代码如下 // 组件中 data() { return { currentCategory: this.$store.state.currentCategory } } methods: { changeCategory(name) { this.$store.commit('changeCategory', name) console.log(this.$store.state.currentCategory) // 成功更新 console.log(this.currentCategory) // 未更新 } } // store.js mutations: { changeCategory(state, name) { state.currentCategory = name } } 在提交了更新以后，通过控制台查看输出，可以发现store.js里的变量已经成功更新，但组件内的data并没有再次获取更新后的值。这就牵扯到Vue的生命周期。 data() { return { val: 'hello vue' } } beforeCreated() { console.log(this.val) //undefined } created() { console.log(this.val) // hello vue } 不难发现data的赋值，是在created()中进行的。 而Vuex的state数据改变，并不会触发组件的刷新，组件也就无法获取到改变的值，直到手动进行刷新为止。该如何解决这个问题呢？ 最简单的方法，是在组件中直接使用state中的数据，而不是用自建data作为中间变量。 第二个方法，就是在提交数据的时候进行强制刷新操作，迫使组件重新获取store的值 methods: { changeCategory(name) { this.$store.commit('changeCategory', name) console.log(this.$store.state.currentCategory) // 成功更新 console.log(this.currentCategory) // 未更新 this.$forceUpdate() console.log(this.currentCategory) // 成功更新 } } ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:5","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"Vue 3学习之路由的进阶 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:0","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"写在前面 之前学习使用了vue的路由，实现了简单的单页面内部pages跳转，继续跟随官方视频学习，进阶vue3中路由的使用 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:1","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"切换效果 vue-router提供了一套完备方便的，用于给各路由页面切换增加效果的方法。 在vue2中，我们可以使用如下方法给页面切换添加slider效果 \u003ctransition name=\"slide\" mode=\"out-in\"\u003e \u003crouter-view :key=\"$route.path\"/\u003e \u003c/transition\u003e .slide-enter-active, .slide-leave-active { transition: opacity .6s, transform .6s; } .slide-enter, .slide-leave-to { opacity: 0; transform: translateX(-30%); } 但在vue3中，继续这种写法能正常工作，但会有warning。 根据warning提示对其进行修改即可 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:2","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"路由回溯与追踪 想要添加一个回到上一页的功能却苦于状态管理？Vue已经帮我们准备好了方法。很简单，仅需要一行代码。给一个按钮绑定goBack事件，点击触发，以下是goBack函数内的所有内容。this.$router.go()可以接受正数和负数作为参数，来进行路由间的跳转。 return this.$router.go(-1) ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:3","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"嵌套路由 一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构。通过 Vue Router，就可以使用嵌套路由配置来表达这种关系。 想要将组件渲染到嵌套的router-view当中，就需要在路由中配置chidren { path: \"/details/:slug\", name: \"DestinationDetails\", component: () =\u003e import(/* webpackChunkName: \"DestinationDetails\" */\"../views/DestinationDetails.vue\"), props: true, children: [ { path: \":experienceSlug\", name: \"ExperienceDetails\", component: () =\u003e import(/* webpackChunkName: \"ExperienceDetails\" */\"../views/ExperienceDetails.vue\"), props: true } ]} 如上所示，ExperienceDetails组件就将被渲染到嵌套在DestinationDetails组件的router-view中，而不会跳转到新的页面。 children 配置只是另一个路由数组，就像 routes 本身一样。因此，可以根据自己的需要，不断地嵌套视图。 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:4","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"解耦：路由组件传参 在组件中过多使用$route会使组件与路由紧密耦合，限制了其灵活性，因为这样只能用于特定的URL，我们可以通过配置props来解决这个问题。以官方文档为例，我们可以将下面的代码 const User = { template: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e' } const routes = [{ path: '/user/:id', component: User }] 替换成 const User = { props: ['id'], template: '\u003cdiv\u003eUser {{ id }}\u003c/div\u003e' } const routes = [{ path: '/user/:id', component: User, props: true }] 这就允许我们在任何地方使用该组件，使其更易于复用与测试。 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:5","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"导航守卫 正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:6","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"Vue学习历程（二） 路由的使用 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:0","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"写在前面 在着手进行一个大项目之前，想先优化、完善之前的todolist项目。例如：增加登录、注册功能；数据储存在云端；增加todo项目的分类与更清晰的状态表示；增加用户自定义设置，如皮肤，显示项等等……这些简单的功能放在单纯的一个页面中就显得拥挤，多页面又小题大做，也会影响使用体验，引入router就显得很有必要 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:1","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"什么是路由？ 路由，可以根据不同的 url 地址展示不同的内容或页面，又有前端路由和后端路由之分，而后端路由的渲染存在性能问腿，所以在项目中前端路由发挥着重要的作用。 简单来说，前端路由就是在保证只有单页面，且交互时不刷新不跳转，为SPA(single page web application)中的每个视图展示形式匹配一个特殊的url。在刷新、前进后退等操作均通过这个特殊url来实现。 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:2","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"Vue中如何使用路由？ 路由一般有两种模式，分别是hash模式和History模式，此处将使用history模式(除非为了兼容IE8，均推荐使用History模式) 前置工作 在项目所在目录打开终端，输入以下代码 npm i install vue-router 在src文件夹下新建目录route，在该文件夹里添加一个index.js文件 .// index.js import { createRouter, createWebHistory } from \"vue-router\" const history = createWebHistory() const router = createRouter({ history, routes: [ { path: '/', name: 'Home', component: () =\u003e import('../views/Home.vue') }, { path: '/Login', name: 'Login', component: () =\u003e import('../views/Login.vue') } ] }) export default router 修改main.js文件 // main.js import { createApp } from 'vue' import App from './App.vue' import router from './route' // 引入 createApp(App) .use(router) // 注入 .mount('#app') 新建views文件夹，内部存放需要通过路由显示的视图 接下来就需要添加跳转路由的连接，和存放跳转到的视图的容器。更改App.vue文件结构，新增一个导航区存放链接，内容区存放视图，原有结构转移到Home.vue文件中 \u003c!-- 导航区 --\u003e \u003cdiv class=\"nav\"\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e \u003crouter-link to=\"/Login\"\u003eLogin\u003c/router-link\u003e \u003c/div\u003e \u003c!-- 视图区 --\u003e \u003cdiv class=\"main\"\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e 最终效果展示 当点击Login链接，以路由方式跳转到了Login界面 点击Home或者tourist mode， 回到主页面 // to do 学习VueX 区分登录用户和游客 增加task的分类功能 设置页面更换主题 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:3","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["program"],"content":"前言  学习完基础的三剑客后，决定开始学习框架。无非就两种选择，Vue或是React，了解了一番二者的区别，再看着文档写了两个教程demo，二者具体深层的区别并没有太大了解也没有感受到，单纯觉得Vue更加适合我😂，于是就选择了学习Vue。至于Vue和React两个框架的区别，具体可以看看这篇文章  看完了文档，迫不及待想撸出自己第一个Vue应用，但仍不知道如何下手，对Vue应用的搭建的流程也并不了解，所以选择了观看一个很优秀的Youtuber – Traversy Media的“Vue crash course”，看完视频后去复现他的代码，然后再自己修改样式、添加功能等等…… ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:1","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"成品 点击Add Task按钮，弹出输入框，可以输入任务的具体内容和时间安排 待办的任务将会在下方显示，每个任务的右侧有两个功能按钮，分别是编辑和删除 数据储存于本地的json文件中，刷新浏览器或重新启动服务能照常读取数据 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:2","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"todo 将json数据部署到云端，达到无需启动node服务即可访问的效果 调整布局，美化项目 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:3","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"如何给自己的博客添加一键回到顶部的功能？  今天用Hugo搭好了博客，美化、自定义什么的先放在一边，单纯用框架改改参数什么的，总感觉技术含量不高嘛（高了我也做不出来），就想着先添加个小功能，提供一个一键回到顶部的功能。让我们开始吧。  本文以Hugo框架，LoveIt主题为例。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:0","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加样式 在CSS中，定义返回顶部按钮的样式。打开Hugo主题目录下的 static/asserts/_custom.scss，在其中加入样式代码。 .backtop { color: #b3b1b1; position: fixed; right: 16px; bottom: 20px; width: 33px; height: 33px; z-index: 10000; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:1","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"导入按钮图标 准备好按钮的图标，前往Font Awesome找到心仪的图标，下载其SVG文件，打开后全部复制 在Hugo主题目录下layouts/partials新建back2top.html文件，将拷贝的代码放入 \u003csvg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"chevron-circle-up\" class=\"svg-inline--fa fa-chevron-circle-up fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e \u003cpath fill=\"currentColor\" d=\"M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z\"\u003e \u003c/path\u003e \u003c/svg\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:2","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加锚点 在当前目录下找到header.html文件并打开，在任意行加入以下代码 \u003cspan id=\"top\"\u003e\u003c/span\u003e 来到layouts/_default文件夹，打开single.html，添加以下代码(与content同级) {{- define \"main\" -}} \u003ca href=\"#top\" class=\"backtop\"\u003e{{ partial \"back2top.html\" . }}\u003c/a\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:3","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"大功告成！ ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:4","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["Program"],"content":"LeetCode刷题记录 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:0:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"动态规划 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"121.买卖股票的最佳时机 思路： 动态规划题 minPrice保存前i天的最低价格，用第i天的现价去减这个最小值，就得到了在第i天卖出的利润 取最大利润 var maxProfit = function(prices) { let profit = 0, res = 0, minPrice = prices[0]; let len = prices.length; for(let i = 1; i \u003c len; i++){ if((prices[i] - minPrice) \u003e profit){ profit = prices[i] - minPrice; res = i + 1; } minPrice = Math.min(minPrice, prices[i]); //前i-1天最低价格 } return res; }; 时间复杂度：O(n)，遍历一次 空间复杂度：O(1) 执行用时：84ms，击败了97.91%的用户 内存消耗：47.5MB，击败了71.92%的用户 官方题解： 无js版本，但思路是一致的，不同的点在于官方是从0开始遍历，然后min最开始取一个无穷大值以保证其大于第一天的价格。 class Solution: def maxProfit(self, prices: List[int]) -\u003e int: inf = int(1e9) minprice = inf maxprofit = 0 for price in prices: maxprofit = max(price - minprice, maxprofit) minprice = min(price, minprice) return maxprofit ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"714. 买卖股票的最佳时机含手续费 思路： 动态规划，每天有两种状态，一是今天交易结束后不持有股票，二是持有 sell表示不持有，buy表示持有 不持有的情况：前一天就不持有，或者前一天买入今天卖出 持有的情况：前一天就持有，前一天不持有但今天买入 因此可以得到状态转移方程 sell = max(sell, buy + prices[i] - fee), buy = max(buy, sell - prices[i]) var maxProfit = function(prices, fee) { let sell = 0, buy = -prices[0] for(let i = 1; i \u003c prices.length; i++) { sell = Math.max(sell, buy + prices[i] - fee) buy = Math.max(sell - prices[i], buy) } return sell // 要想利润最大，结束后肯定不能持有股票 }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1014.最佳观光组合 思路： maxScore由三个值组成：距离以及两个景点的好看程度 很明显，两个景点都好看，又近的时候最完美 因此可以先用一个值记录第一个好看的景点，当第二个离他越来越远，这个景点的好看程度也一直下降 var maxScoreSightseeingPair = function(values) { let maxScore = 0, firstSight = 0, secondSight = 1 for(let i = 0; i \u003c values.length - 1; i++) { // 如果第一个景点不够好看，无法支持这个距离，更新 if(values[firstSight] \u003c= values[i]) { // 更新第一个景点（第一个因为太远被抛弃了） firstSight = i secondSight = firstSight + 1 } // 每次循环，第一个景点的吸引力就下降一点 values[firstSight]-- // maxScore维护最大值 maxScore = Math.max(maxScore, (values[firstSight] + values[secondSight])) // 一直在往后找第二个景点 secondSight++ } return maxScore ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"413.等差数列划分 思路： 每个等差数列内的子数列，都是等差数列 不是别的等差数列的子数列的等差数列😂,之间不会有交集 var numberOfArithmeticSlices = function(nums) { if(nums.length \u003c 3) return 0 let res = 0, len = 2 for(let i = 1; i \u003c nums.length - 1; i++) { if((nums[i] - nums[i-1]) === (nums[i+1] - nums[i])) { len++ } else { if(len \u003e= 3) { res = res + (len-1) * (len-2) / 2 } len = 2 } if(i === nums.length - 2) { if(len \u003e= 3) { res = res + (len-1) * (len-2) /2 } } } return res }; 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：64ms，击败了88.75%的用户 内存消耗：37.6MB，击败了58.73%的用户 官方题解 var numberOfArithmeticSlices = function(nums) { const n = nums.length; if (n === 1) { return 0; } let d = nums[0] - nums[1], t = 0; let ans = 0; // 因为等差数列的长度至少为 3，所以可以从 i=2 开始枚举 for (let i = 2; i \u003c n; ++i) { if (nums[i - 1] - nums[i] === d) { ++t; } else { d = nums[i - 1] - nums[i]; t = 0; } ans += t; } return ans; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"53.最大子序和 思路： 若只有一个元素，直接返回 从前往后遍历并求和，若sum\u003c0，则sum归零（前面的元素都不要了） 到后面遇到了负数，但是这个负数加进来也不足以使sum\u003c0，则从这个负数开始往后看，它和后面的元素依此相加，得到一个newSum，一大于0就把newSum加上。 官方题解： 动态规划 var maxSubArray = function(nums) { let pre = 0, maxAns = nums[0]; nums.forEach((x) =\u003e { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); }); return maxAns; }; foreach：对数组的每个元素执行一次给定的函数。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:5","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"918. 环形子数组的最大和 思路： 处理思想和最大子序和基本一致，唯一区别要考虑到环 可以分为两种情况考虑，第一种是不需要越过边界，则和最大子序和一样 第二种是越过了边界，这是只需要求出数组的总和，再减去最小子序和，就是越过环的结果 最后在处理结果时还需要考虑全为负数的情况 var maxSubarraySumCircular = function(nums) { let max = nums[0], min = nums[0], preMax = nums[0], preMax = nums[0], sum = nums[0] for(let i = 1; i \u003c nums.length; i++) { preMax = Math.max(nums[i], (preMax + nums[i])) preMin = Math.min(nums[i], (preMin + nums[i])) max = Math.max(preMax, max) min = Math.min(preMin, min) sum += nums[i] } return (max \u003c 0) ? max : Math.max(max, sum - min) } 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：84ms，击败了80.75%的用户 内存消耗：43.6MB，击败了78.73%的用户 官方题解 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:6","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"70. 爬楼梯 思路： 爬到某一级台阶的前一步，必定落在上一级或者上上级。 所以爬到某一台阶的方法数，等于爬到上一级和上上级的方法数之和。 var climbStairs = function(n) { if(n \u003c= 2){ return n; } let i1 = 1, i2 = 2, temp = 0; for(let i = 3; i \u003c= n; i++){ temp = i1 + i2; i1 = i2; i2 = temp; } return temp; } 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：64ms，击败了94.33%的用户 内存消耗：37.7MB，击败了30.68%的用户 官方题解 /* 方法一，动态规划 */ var climbStairs = function(n) { let p = 0, q = 0, r = 1; for (let i = 1; i \u003c= n; ++i) { p = q; q = r; r = p + q; } return r; }; /* 方法二，通项公式 */ var climbStairs = function(n) { const sqrt5 = Math.sqrt(5); const fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1); return Math.round(fibn / sqrt5); }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:7","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"198. 打家劫舍 思路： 小偷身处第 i 间房子时，知道自己在 “ 只偷到(k - 2)间时最多能偷到的钱 i1 ” 和 “ 只偷到(k - 1)间时最多能偷到的钱 i2 ” 第 i 间房子的钱加上 i1 比 i2 大的话，就偷，然后到了下一间房子后，i1 变成了之前的 i2 ， i2 变成了现在的sum 如果小，就不偷，直接到下一间房子，此时 i1 变为 i2， i2 则不变 var rob = function(nums) { let len = nums.length; if(len === 1) return nums[0]; if(len === 2) return Math.max(nums[0], nums[1]); let i1 = nums[0], i2 = Math.max(nums[0], nums[1]); let sum = 0; for(let i = 2; i \u003c len; i++){ if((nums[i] + i1) \u003e i2){ sum = nums[i] + i1; i1 = i2; i2 = sum; } else{ sum = i2; i1 = i2; } } return sum; }; 执行用时：68ms，击败了84.07%的用户 内存消耗：37.7MB，击败了44.61%的用户 时间复杂度：O(n) 空间复杂度：O(1) 官方题解 class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int length = nums.length; if (length == 1) { return nums[0]; } int first = nums[0], second = Math.max(nums[0], nums[1]); for (int i = 2; i \u003c length; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:8","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"二分法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"35.搜索插入位置 思路： 二分查找法的基础变式 如果查找到了，直接返回； 如果没找到，返回left(right+1)，也就是当前“光标”所在位置 var searchInsert = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, mid; while(left \u003c= right){ mid = parseInt(left + (right-left) / 2); if(nums[mid] \u003e target){ right = mid - 1; } else if(nums[mid] \u003c target){ left = mid + 1; } else{ return mid; //找到了就直接返回索引值 } } return left; //若没找到，则返回目前“光标”位置，该位置前面的数都小于target，后面则都更大 }; 执行用时：68ms，击败了94.68%的用户 内存消耗：39.1MB，击败了12.19%的用户 时间复杂度：O(logn) 空间复杂度：O(1) 官方题解： var searchInsert = function(nums, target) { const n = nums.length; let left = 0, right = n - 1, ans = n; while (left \u003c= right) { let mid = ((right - left) \u003e\u003e 1) + left; if (target \u003c= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; }; 和自己思路类似，自己的觉得更简洁直白 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"34. 在排序数组中查找元素的第一个和最后一个位置 思路： 用二分法，找一个target 如果没找到，则直接返回-1，-1 找到了的话，从mid开始两头找start和end var searchRange = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, start = -1, end = -1; let mid = parseInt(left + (right - left) / 2); while(left \u003c= right){ if(nums[mid] \u003e target){ right = mid - 1; mid = parseInt(left + (right - left) / 2); } else if(nums[mid] \u003c target){ left = mid + 1; mid = parseInt(left + (right - left) / 2); } else{ break; /* 找到了 */ } } /* 如果是因为left大于right而跳出的循环，则证明没有找到 */ /* 如果left仍未大于right，则证明找到了，需要继续找 */ if(left \u003e right){ return [start,end]; /* 直接返回[-1,-1] */ } let i = 0, j = 0; while(++i){ if(nums[mid-i] != target || (mid-i) \u003c left){ start = mid - i + 1; break; } } while(++j){ if(nums[mid+j] != target || (mid+j) \u003e right){ end = mid + j - 1; break; } } return [start,end]; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：68ms，击败了94.12%的用户 内存消耗：39.9MB，击败了12.97%的用户 陷入了误区，找到mid后使用了线性查找，导致时间复杂度来到了O(n)而不是O(logn)！！正确的做法是继续二分查找！！！ 改进版 var searchRange = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, start = -1, end = -1; let mid = parseInt(left + (right - left) / 2); while(left \u003c= right){ if(nums[mid] \u003e target){ right = mid - 1; mid = parseInt(left + (right - left) / 2); } else if(nums[mid] \u003c target){ left = mid + 1; mid = parseInt(left + (right - left) / 2); } else{ break; /* 找到了 */ } } /* 如果是因为left大于right而跳出的循环，则证明没有找到 */ /* 如果left仍未大于right，则证明找到了，需要继续找 */ if(left \u003e right){ return [start,end]; /* 直接返回[-1,-1] */ } 官方题解 const binarySearch = (nums, target, lower) =\u003e { let left = 0, right = nums.length - 1, ans = nums.length; while (left \u003c= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] \u003e target || (lower \u0026\u0026 nums[mid] \u003e= target)) { right = mid - 1; ans = mid; } else { left = mid + 1; } } return ans; } var searchRange = function(nums, target) { let ans = [-1, -1]; const leftIdx = binarySearch(nums, target, true); const rightIdx = binarySearch(nums, target, false) - 1; if (leftIdx \u003c= rightIdx \u0026\u0026 rightIdx \u003c nums.length \u0026\u0026 nums[leftIdx] === target \u0026\u0026 nums[rightIdx] === target) { ans = [leftIdx, rightIdx]; } return ans; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"4. 寻找两个正序数组的中位数 思路： 归并排序，根据长度返回中位数 var findMedianSortedArrays = function(nums1, nums2) { let len1 = nums1.length, len2 = nums2.length; let res = 1.0, i = 0, j = 0; let nums = []; while(i \u003c len1 || j \u003c len2) { if(i \u003e= len1) { nums.push(nums2[j++]); } else if(j \u003e= len2) { nums.push(nums1[i++]); } else { if(nums1[i] \u003e= nums2[j]) { nums.push(nums2[j++]); } else { nums.push(nums1[i++]); } } } let len = nums.length; if(len % 2) { res = nums[Math.floor(len / 2)]; } else { res = (nums[len / 2] + nums[len / 2 - 1]) / 2 } return res; }; 时间复杂度：O(m+n) 空间复杂度：O(m+n) 执行用时：124ms，击败了65.19%的用户 内存消耗：43.2MB，击败了63.96%的用户 官方题解： 题目要求：时间复杂度O(log(m+n))。 该题可以转化为，求两个有序数组中第k小的数，其中k为(m+n)/2或者(m+n)/2+1 要找到第k小的元素，我们可以比较nums1[k / 2 - 1]和nums2[k / 2 - 1]，所以对于nums1[k / 2 - 1]和nums2[k / 2 - 1]中的较小值，最多只会有(k-2)个元素比它小，那么它不可能是第k小的元素。 此处k / 2为整数除法( Math.floor() ) 此时可以归纳三种情况： nums1[k / 2 - 1] \u003c nums2[k / 2 - 1]，则可以排除nums1[1] 到nums1[k / 2 - 1] nums2[k / 2 - 1] \u003c nums1[k / 2 - 1]，则可以排除nums2[1] 到nums2[k / 2 - 1] nums1[k / 2 - 1] == nums2[k / 2 - 1]，可以并入第一种情况 所以在比较后，我们可以排除k / 2个不可能是第k小的数，意味着查找的范围已经缩小了一半 下一步就是在排除后的新数组上继续二分查找，并且根据我们排除的数的个数，来减小k的值 有三种特殊情况需要处理： 越界。则取该数组最后一个数字，同时注意k不能直接减半 若一个数组为空，直接返回另一个数组第k小的数字 若k=1，直接返回两数组首元素较小值 优化后： ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"栈 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:3:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"剑指offer 06 从尾到头打印链表 思路： 遍历链表，依此在头部添加val var reversePrint = function(head) { let res = new Array(); while(head!==null){ res.unshift(head.val); head = head.next; } return res; }; 时间复杂度：O(n) 空间复杂度：O(n) 执行用时：80ms，击败了94.21%的用户 内存消耗：39.4MB，击败了94.03%的用户 官方题解 栈 ​ 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:3:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"树 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:4:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"671. 二叉树中第二小的节点(https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/) 思路： 在这个特殊的二叉树中，子节点的元素均大于等于父节点元素的值。 所以只要自顶往下，在某一层遇到了比根节点大，且是这一层最小的，那就是所要的节点。 如果一直没找到，直到所有节点遍历完了，也就是所有叶节点也和根节点的值一样，返回-1； 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解 var findSecondMinimumValue = function(root){ let ans = -1; const rootValue = root.val; const dfs = (node) =\u003e { if(node === null){ return; } if(ans !== -1 \u0026\u0026 node.val \u003e= ans){ return; } if(node.val \u003e rootValue){ ans = node.val; } dfs(node.left); dfs(node.right); } dfs(root); return ans; } **const dfs = (node) =\u003e {} ** =\u003e : 箭头函数，相当于匿名函数，且简化了函数定义 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:4:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"BFS和DFS ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:5:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"200. 岛屿数量 思路 遍历grid，当遇到1，将其置0，将其上下左右的1置0，将其上下左右的1的上下左右的1置零…… var numIslands = function(grid) { let res = 0 const bfs = (i, j) =\u003e { if(i \u003c 0 || j \u003c 0 || i \u003e= grid.length || j \u003e= grid[0].length || grid[i][j] === '0') { return } grid[i][j] = '0' bfs(i + 1, j) bfs(i - 1, j) bfs(i, j + 1) bfs(i, j - 1) } for(let i = 0; i \u003c grid.length; i++) { for(let j = 0; j \u003c grid[0].length; j++) { if(grid[i][j] === '1') { res++ bfs(i, j) } } } return res }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：84ms，击败了52.76%的用户 内存消耗：40.4MB，击败了49.33%的用户 官方题解 1.广度优先搜索BFS class Solution: def numIslands(self, grid: [[str]]) -\u003e int: def bfs(grid, i, j): queue = [[i, j]] while queue: [i, j] = queue.pop(0) if 0 \u003c= i \u003c len(grid) and 0 \u003c= j \u003c len(grid[0]) and grid[i][j] == '1': grid[i][j] = '0' queue += [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]] count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '0': continue bfs(grid, i, j) count += 1 return count 2.深度优先搜索DFS class Solution: def numIslands(self, grid: [[str]]) -\u003e int: def dfs(grid, i, j): if not 0 \u003c= i \u003c len(grid) or not 0 \u003c= j \u003c len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' dfs(grid, i + 1, j) dfs(grid, i, j + 1) dfs(grid, i - 1, j) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:5:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"摩尔投票法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:6:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"面试题17.10.主要元素 思路： 若数组里只有一个数字，直接返回； 对数组进行排序后，若两个相差一半长度的元素相等，则该元素就是主要元素； 若遍历到一半还没出现，则证明没有主要元素。 var majorityElement = function(nums) { l = parseInt(nums.length/2); if(!l){ return nums[0]; } nums.sort(); for(let i = 0; i \u003c= l; i++){ if(nums[i] == nums[i+l]){ return nums[i]; } } return -1; }; 时间复杂度：O(nlogn)。排序复杂度超出了要求 空间复杂度：O(1)，没有用到多余的空间 执行用时：72ms，击败了94.35%的用户 内存消耗：42.2MB，击败了10.63%的用户 官方题解： Boyer-Moore投票算法 Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。 该题中表现为：遍历到x时，若count为0，则先将x的值赋给candidate；接下去若遇到不相同的，count–，遇到相同的，count++，若count为0，重新赋值。因此遍历一遍过后，如果数组nums 中存在主要元素，则candidate 即为主要元素，否则candidate 可能为数组中的任意一个元素。 因此需要二次遍历，看candidate出现的次数是否大于l/2。 【主要元素出现次数大于其他元素出现次数之和】 【== 和 === 的区别： == 会先将两边的值进行强制类型转换】 null == undefined //true null === undefined //false 55 == '55' //true 55 === '55' //false //因此推荐使用=== var majorityElement = function(nums) { let candidate = -1; //候选主要元素，初始可以是任意值 let count = 0; //候选主要元素出现的次数 for (const num of nums) { if (count === 0) { candidate = num; } if (num === candidate) { count++; } else { count--; } } count = 0; const length = nums.length; for (const num of nums) { if (num === candidate) { count++; } } return count * 2 \u003e length ? candidate : -1; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:6:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"双指针 || 滑动窗口 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"3. 无重复字符的最长字串 思路 最初的思路是，用两重循环，以数组每个元素为起点都做一次最大长度，保留最大 后面发现这样会超时(O(N^2)) 改进成：遇到一个重复元素，则将pre中的该重复元素及其之前的元素截取掉 var lengthOfLongestSubstring = function(s) { let pre = [], counts = 0; let len = s.length; for(let i = 0; i \u003c len; i++){ let index = pre.indexOf(s[i]); if(index !== -1){ pre.splice(0,(index + 1)); //截取数组，把前面的重复元素及其之前的元素删掉 } pre.push(s[i]); counts = Math.max(counts,pre.length); } return counts; }; 时间复杂度：O(n)，遍历一次 空间复杂度：O(∣Σ∣)，最坏情况全不重复，则最长是所有字符的合集128 执行用时：76ms，击败了99.90%的用户 内存消耗：41.4MB，击败了71.54%的用户 官方题解 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i \u003c n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 \u003c n \u0026\u0026 !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }; 该做法称为“滑动窗口” 使用两个指针表示字符串的某个子串（窗口）的左右边界 每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，记下长度 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"26.删除有序数组中的重复元素 思路： 因为数组是有序的，所以遍历数组，当某元素和前一个元素不等，则代表它没出现过，把他放到第n个位置，n为出现过的元素个数 var removeDuplicates = function(nums) { let len = nums.length; let res = 0; for(let i=0; i\u003clen; i++){ if(nums[i+1] != nums[i]){ res++; nums[res] = nums[i+1]; } } return res; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解： 快慢指针，实际思想与自己无异 var removeDuplicates = function(nums) { const n = nums.length; if (n === 0) { return 0; } let fast = 1, slow = 1; while (fast \u003c n) { if (nums[fast] !== nums[fast - 1]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"27.移除指定元素 思路： 跟26题几乎一样，不一样的只是res的起点 var removeElement = function(nums, val) { let res = 0; let len = nums.length; for(let i=0; i\u003clen; i++){ if(nums[i] !== val){ nums[res++] = nums[i]; } } return res; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：64ms，击败了99.51%的用户 内存消耗：38MB，击败了32.95%的用户 官方题解： 除了快慢指针，还可以使用左右指针，在val元素数量小时很有效，避免了需要保留的元素的重复赋值操作。 var removeElement = function(nums, val) { let left = 0, right = nums.length; while (left \u003c right) { if (nums[left] === val) { nums[left] = nums[right - 1]; right--; } else { left++; } } return left; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"剑指offer52 两个链表的第一个公共节点 官方题解 var getIntersectionNode = function(headA, headB) { if(headA===null || headB===null){ return null; } /* 有一个为空，则没有交集 */ let pA = headA; let pB = headB; while(pA!==pB){ /* 当他们没有相遇 */ pA = (pA===null) ? headB : pA.next; pB = (pB===null) ? headA : pB.next; } return pA; }; 有点没看懂问什么＋刚搬完寝室无心学习，直接看官方题解了 也属于双指针题目，但特殊的是，由于公共节点离两个头结点的位置是不同的，所以只遍历一遍自身是不够的，需要遍历完自身（若此时还没找到），再去从另一个的头结点处开始遍历，当两边都这么做，就能保证：若有公共节点，则同时停在公共节点处，也就意味着可以返回这个节点。若没有，则会同时处于null（两边都刚好遍历了lenA+lenB） ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"141. 环形链表 思路 val值有限定范围 小聪明，但值得注意的是，面试时应先问清楚面试官题目细节，如果刻意透露了限定条件，则利用反而会加分 var hasCycle = function(head) { while(head){ if(head.val==100001){ return true; } else{ head.val = 100001; } head = head.next; } return false; }; 快慢指针，快的一次走两步，慢的一次走一步，快的能反过来追上慢的就有环 var hasCycle = function(head) { if(head==null || head.next==null){ //没环 return false; } let fast = head.next, slow = head; while(fast){ //如果没环，fast会先到尾 if(fast == slow){ return true; } if(fast.next==null){ return false; } fast = fast.next.next; slow = slow.next; } return false; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解 哈希表，用集合存储访问过的节点 快慢指针 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:5","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"611. 有效三角形的个数 思路 暴力 var triangleNumber = function(nums) { nums.sort((a, b) =\u003e a - b); /* sort方法仅适用于字符串，对数字需要这样操作 */ let len = nums.length; let res = 0; for(let i = 0; i \u003c len - 2; i++){ if(nums[i] \u003c= 0){ continue; /* 三角形边长都是正数 */ } for(let j = i + 1; j \u003c len - 1; j++){ for(let k = j + 1; k \u003c len; k++){ if(nums[i] + nums[j] \u003e nums[k]){ res++; } else{ break; } } } } return res; }; 时间复杂度：O(N3) 执行用时：852ms，击败了23.08%的用户 内存消耗：39.4MB，击败了70.33%的用户 官方题解 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:6","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"881. 救生艇 思路： 重点是每艘船只能载1或2人 排序，最轻的和最重的加，若不大于limit，左边指针后移一位 每次循环都将右指针前移一位，船数也加一 var numRescueBoats = function(people, limit) { let res = 0; people.sort((a,b) =\u003e (a-b)); let left = 0, right = people.length - 1; while(left \u003c= right) { if(people[left] + people[right] \u003c= limit) { left++; } right--; res++; } return res; }; 时间复杂度：O(nlogn) 排序 空间复杂度：O(1) 执行用时：152ms，击败了93.16%的用户 内存消耗：45.5MB，击败了36.32%的用户 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:7","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"15. 三数之和 思路： 此题的重点是，不能存在重复的三元组 要找到和为0的三元组，自然地想到需要先进行排序。排序后找第一个元素，这个元素的特点是不能和前一个元素相等，这也就保证了每个三元组的最小值不会相等，初步保证不会重复 接下去的操作类似于之前的两数之和题目，使用双指针来寻找，对于左指针指向的元素，拥有和对第一个元素一样的约束，这样也保证了第二个元素不会在第二个位置重复使用 当前两个确定后，由于和是0是固定的，第三个只需要正常寻找就可以 var threeSum = function(nums) { let res = []; nums.sort((a,b)=\u003e(a-b)); // 排序数组 for(let i = 0; i \u003c nums.length - 2; i++) { // 最后两个数不可能是三元组内第一个元素 if(i \u003e 0 \u0026\u0026 nums[i-1] === nums[i]) continue; // 确保第一个位置不重复 let first = nums[i]; let left = i + 1, right = nums.length - 1; while(left \u003c right) { let second = nums[left], third = nums[right]; if(first + second + third === 0) { res.push([first, second, third]); // 确保第二个位置不重复 while(1) { left++; if(nums[left] !== nums[left-1] || left \u003e= right) { break; } } } else if(first + second + third \u003c 0) left++; else right--; } } return res; }; 时间复杂度：O(n^2) 空间复杂度：O(logn) 执行用时：136ms，击败了83.01%的用户 内存消耗：6MB，击败了34.90%的用户 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:8","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"基础线性表 || 矩阵 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"2. 两数相加 思路 用carry表示进位 head代表头结点，尾结点往后走到l1、l2都为空 如果用一个为空，另一个还未到结束，则空的那部分都是0 var addTwoNumbers = function(l1, l2) { let carry = 0; /* 第一次一定没有进位 */ let head = null, tail = null; while(l1 || l2){ const num1 = l1 ? l1.val : 0; const num2 = l2 ? l2.val : 0; const sum = num1 + num2 + carry; if(!head){ head = tail = new ListNode(sum % 10); } else{ tail.next = new ListNode(sum % 10); tail = tail.next; } carry = (sum \u003e= 10) ? 1 : 0; if(l1){ l1 = l1.next; } if(l2){ l2=l2.next; } } if(carry == 1){ tail.next = new ListNode(1); tail = tail.next; } return head; }; 时间复杂度：O(max(m,n)) 空间复杂度：O(1) 执行用时：96ms，击败了99.90%的用户 内存消耗：43.2MB，击败了32.54%的用户 官方题解 一样 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"21.合并两个有序链表 思路： 创建结点head和tail 先判断是否都不为空，若有一个为空则返回另一个，都为空则直接返回空结点 都不为空的话，head指向小的那个list，然后进入while循环，根据val值决定tail延伸方向，有一个为空即跳出循环 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ struct ListNode *head, *tail; if(l1 \u0026\u0026 l2){ if(l1-\u003eval \u003c l2-\u003eval){ head = l1; l1 = l1-\u003enext; } else{ head = l2; l2 = l2-\u003enext; } tail = head; while(l1 \u0026\u0026 l2){ if(l1-\u003eval\u003cl2-\u003eval){ tail-\u003enext = l1; l1 = l1-\u003enext; } else{ tail-\u003enext = l2; l2 = l2-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = l1?l1:l2; } else if(l1){ return l1; } else if(l2){ return l2; } return head; } 时间复杂度：O(n+m) 空间复杂度：O(n+m) 执行用时：4ms，击败了90.26%的用户 内存消耗：6MB，击败了59.92%的用户 官方递归解法： struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-\u003eval \u003c l2-\u003eval){ l1-\u003enext = mergeTwoLists(l1-\u003enext,l2); return l1; }else{ l2-\u003enext = mergeTwoLists(l1,l2-\u003enext); return l2; } } 递归： 必须要有边界条件，否则递归无法停止将会出错 递归函数通过不断调用自身，直至遇到边界条件后进行回溯，返回最终答案。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"448.找到消失的数字 思路： 数字大小都在区间[1,n]内，项数范围是[0,n-1] 则每个元素的绝对值减去1，就代表其中一个项的位置 把该位置的元素变为负值 则仍未正数的元素的下标，就是代表没有出现的数字 - 1 var findDisappearedNumbers = function(nums) { len = nums.length; //获取数组长度 var res = new Array(); //存放答案的新数组 for(let i=0;i\u003clen;i++){ let num = Math.abs(nums[i]) - 1; //项数 if(nums[num] \u003e 0){ nums[num] *= -1; //包含的项变负 } } for(let i=0;i\u003clen;i++){ if(nums[i]\u003e0){ res.push(i+1); //添加正数 } } return res; }; 时间复杂度：O(n) 空间复杂度：符合题目要求，除了返回的数组以外不占用其他空间 执行用时：112ms，击败了97.43%的用户 内存消耗：45.2MB，击败了99.32%的用户 官方题解的做法： 每遇到一次x，就让nums[x-1]加上n，最后数组里仍处在[1,n]范围内的项，下标加一就是消失的数字。 var findDisappearedNumbers = function(nums) { const n = nums.length; for (const num of nums) { const x = (num - 1) % n; // %n很重要 nums[x] += n; } const ret = []; for (const [i, num] of nums.entries()) { if (num \u003c= n) { ret.push(i + 1); } } return ret; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"54. 螺旋矩阵 思路： 一层层剥开矩阵，用矩阵的四个边界控制，每走一圈（每剥开一层），矩阵缩小一次 var spiralOrder = function(matrix) { const rows = matrix.length; /* 行数 */ const columns = matrix[0].length; /* 列数 */ let res = []; if(rows==0 || columns==0){ return res; } let left = 0, right = columns - 1, top = 0, bottom = rows - 1; while(left\u003c=right \u0026\u0026 top\u003c=bottom){ for(let j=left; j\u003c=right; j++){ res.push(matrix[top][j]); } for(let i=top+1; i\u003c=bottom; i++){ res.push(matrix[i][right]); } if(left\u003cright \u0026\u0026 top\u003cbottom){ for(let j=right-1; j\u003eleft; j--){ res.push(matrix[bottom][j]); } for(let i=bottom; i\u003etop; i--){ res.push(matrix[i][left]); } } [left,right,top,bottom] = [left + 1, right - 1, top + 1, bottom - 1]; } return res; }; 时间复杂度：O(mn)，遍历矩阵 空间复杂度：O(1)，除了返回的数组，没有用到多余空间 执行用时：60ms，击败了99.00%的用户 内存消耗：37.7MB，击败了48.38%的用户 官方题解： 一样 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"贪心 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:9:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1736. 替换隐藏数字得到的最晚时间 思路: 从第一位开始判断：因为第一位最重要，直接if else枚举 var maximumTime = function(time) { const arr = Array.from(time); //Array.from:从一个类似数组或可迭代对象创建一个新的、浅拷贝的数组实例 if(arr[0]=='?'){ if(arr[1]\u003c=4 || arr[1]=='?'){ arr[0] = 2; } else{ arr[0] = 1; } } if(arr[1]=='?'){ if(arr[0]=='?' || arr[1]==2){ arr[1] = 4; } else{ arr[1] = 9; } } if(arr[3]=='?'){ arr[3] = 5; } if(arr[4]=='?'){ arr[4] = 9; } return arr.join(''); //用join方法来将各元素连接 }; 时间复杂度：O(1) 空间复杂度：O(1) 执行用时：72ms，击败了90.00%的用户 内存消耗：37.8MB，击败了84.00%的用户 官方题解 var maximumTime = function(time) { const arr = Array.from(time); if (arr[0] === '?') { arr[0] = ('4' \u003c= arr[1] \u0026\u0026 arr[1] \u003c= '9') ? '1' : '2'; } if (arr[1] === '?') { arr[1] = (arr[0] == '2') ? '3' : '9'; } if (arr[3] === '?') { arr[3] = '5'; } if (arr[4] === '?') { arr[4] = '9'; } return arr.join(''); }; 思路一致，官方代码利用正则表达式，更加简洁 贪心算法：是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优算法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:9:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"哈希表 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"705. 设计哈希集合 var MyHashSet = function() { this.BASE = 769; // 哈希函数用的取模方法，选取一个较大质数 this.data = new Array(this.BASE).fill(0).map(() =\u003e new Array()); }; MyHashSet.prototype.add = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { return; // 已经存在，不添加 } } it.push(key); }; MyHashSet.prototype.remove = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { it.splice(i, 1); // 删除 return; } } }; MyHashSet.prototype.contains = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { return true; } } return false; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"706. 设计哈希映射 var MyHashMap = function() { this.BASE = 769; this.data = new Array(this.BASE).fill(0).map(() =\u003e new Array()); }; MyHashMap.prototype.put = function(key, value) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { it[1] = value; return; } } this.data[h].push([key, value]); }; MyHashMap.prototype.get = function(key) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { return it[1]; } } return -1 }; MyHashMap.prototype.remove = function(key) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { this.data[h].splice(this.data[h].indexOf(it), 1); return; } } }; MyHashMap.prototype.hash = function(key) { return key % this.BASE; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1.两数之和 思路： 暴力，双重循环 哈希表 var twoSum = function(nums, target) { let hashMap = {}; for(let i = 0; i \u003c nums.length; i++){ if(hashMap[target - nums[i]] !== undefined){ return [i, hashMap[target - nums[i]]]; } hashMap[nums[i]] = i; //存放的是该元素的索引值 } return []; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"128. 最长连续子序列 思路： 因为时间复杂度要求为O(n)，所以不能使用排序算法。而很自然就想到应该使用哈希表来解决这个问题let hashNums = new Set(nums) 得到这样一个集合后，对于在数组内的元素，我们查找它的左邻居(比它小1的数字)是否在集合里，若在则长度加一，并保存长度然后从它的右邻居开始找，直到它的右邻居不在集合里 var longestConsecutive = function(nums) { res = 0 let myHash = new Set(nums) for(let num of myHash) { if(!myHash.has(num - 1)) { let currentNum = num let currentLen = 1 while(myHash.has(currentNum + 1)) { currentNum++ currentLen++ } res = Math.max(res, currentLen) } } return res }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"}]