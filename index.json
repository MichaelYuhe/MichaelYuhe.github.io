[{"categories":["面经"],"content":"蚂蚁前端二面 总时长十六分钟，与一面形成鲜明对比😆 聊天 高中怎么学的 平常喜欢干啥 为什么选前端 没有反问的机会，十五分钟直接结束让我等后面的hr面 ","date":"2022-03-02","objectID":"https://MichaelYuhe.github.io/%E8%9A%82%E8%9A%81%E5%89%8D%E7%AB%AF%E4%BA%8C%E9%9D%A2/:1:0","tags":["面试"],"title":"蚂蚁前端实习_二面","uri":"https://MichaelYuhe.github.io/%E8%9A%82%E8%9A%81%E5%89%8D%E7%AB%AF%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"蚂蚁前端一面 总时长一百分钟，三道coding四十分钟，面试六十分钟 Coding 数组交集 比较版本号 URL参数 实现一个类，有一些处理URL的方法 基础知识 网络 http和https 加密流程 数字证书为什么可信 http版本 http3听过吗 版本区别 JS Promise async await React hooks TS 泛型 React中使用TS JS转TS 实习 干了什么 日志治理详细讲了 反问 实习生做哪些工作 聊天 ","date":"2022-03-01","objectID":"https://MichaelYuhe.github.io/%E8%9A%82%E8%9A%81%E5%89%8D%E7%AB%AF%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"蚂蚁前端实习_一面","uri":"https://MichaelYuhe.github.io/%E8%9A%82%E8%9A%81%E5%89%8D%E7%AB%AF%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"钉钉一面 项目 小游戏讲一下 小游戏生命周期 做了什么工作 音乐播放器 写一个音乐播放器组件的思路 和后端交互的具体流程，具体设计思路 添加音乐怎么做的 技术 计算机网络 HTTP和HTTPS的区别 TCP讲一下 三次握手 如何实现一个TCP 如何基于TCP写一个协议 状态码 Vue 生命周期 为什么要有生命周期 生命周期干了啥 如何实现一个生命周期 双向绑定 如何实现一个双向绑定 设计发布订阅的思路 JavaScript 事件委托 typeof讲一下 数组遍历方法 foreach和map区别 为什么react的jsx用map this讲一下 数组去重，多讲几种 柯里化 什么是纯函数，什么是函数式编程 CSS 居中 flex 具体用法 justify-content是哪个方向 选择器优先级 哪些属性不可继承，哪些可以 算法 在线写代码，金额转千分位 其他 学习路线 为什么学前端 反问 对我的建议 面试官很好，耐心地仔细地讲了快十分钟 不能只关注功能，要关注背后的原理；学react； 反馈给上面，可能有二面 总结 感觉面试官很看重基础和编程思想，自己这方面是最薄弱的，因为学习时间也就半年 ","date":"2022-02-25","objectID":"https://MichaelYuhe.github.io/%E9%92%89%E9%92%89%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"钉钉前端实习_一面","uri":"https://MichaelYuhe.github.io/%E9%92%89%E9%92%89%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"阿里云二面 没想过有一天自己看过的书的作者来面试自己… 待我入个正支持一下😂 没有技术，纯聊天 学习路线 HTML和CSS的重点是什么？ JS的重点是什么？ 答了单线程，事件机制，操作DOM 因为自己没学过其他语言，不明白JS相对其他语言的最大区别 TS和JS的区别 具体区别 为什么大型应用要用TS TS的缺点 实习相关 做的工作 工作流程 对发布代码这一套流程的思考 对业务的理解 前端工程师的价值体现 小游戏经历 GitHub链接 完了要被发现我有多菜了😂 职业生涯规划 反问 原来打算再问建议的，紧张忘了 实习地点和时间 ","date":"2022-02-23","objectID":"https://MichaelYuhe.github.io/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%8C%E9%9D%A2/:1:0","tags":["面试"],"title":"阿里云OPENAPI前端实习_二面","uri":"https://MichaelYuhe.github.io/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%8C%E9%9D%A2/"},{"categories":["面试"],"content":"备战暑期实习 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:0:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"计算机网络 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"TCP三次握手四次挥手 三次握手 三次握手，指的就是建立一个TCP链接时，需要客户端和服务器共发送三个包，主要作用是确认双方的收发能力正常、指定自己的初始化序列号，为后面的可靠性传输做准备 第一次握手，客户端给服务端发一个SYN报文，其中包含客户端的初始化序列号ISN，客户端变为SYN_SENT状态。作用：服务端得出结论，客户端的发送能力和服务端的接收能力正常 第二次握手，服务端接收到客户端发来的SYN报文后，以自己的SYN报文作为应答，并将客户端的ISN+1作为ACK的值。服务端变为SYN_RCVD状态。作用：客户端得出结论，客户端的收发能力、服务端的收发能力正常 第三次握手，客户端收到SYN报文后，发送一个ACK报文，值是服务端的ISN+1。客户端变为ESTABLISHED状态；服务端接收到ACK报文后，也变成ESTABLISHED状态，双方成功建立了链接。作用：服务端知道客户端的接收能力和服务端的发送能力正常 如果是两次握手，会发生什么？ 服务端不知道客户端的接收能力和自己的发送能力是否正常 客户端可能会因为网络阻塞等原因，发送多个请求报文，浪费服务器资源 四次挥手 第一次挥手，客户端发送一个FIN报文，报文中指定一个序列号，客户端处于FIN_WAIT1状态，停止发送数据，等待服务端确认 第二次挥手，服务端收到FIN后，发送ACK报文，且将客户端报文的序列号+1作为ACK报文的序列号，服务端变为CLOSE_WAIT状态 第三次挥手，如果服务端也想断开，服务端也发送一个FIN报文，同样指定了一个序列号，服务端变为LAST_ACK状态 第四次挥手，客户端收到FIN，一样以ACK报文应答，变为TIME_WAIT状态，等待一段时间，确认服务端接收到自己的ACK报文，变成CLOSED状态；服务端只要接收到ACK，就变成CLOSED 第四次挥手中为什么要等待？ TIME_WAIT状态，等待两个传输时间，确保服务端已经收到自己的ACK报文了。如果服务端没收到，它会重发FIN报文 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"HTTP常见请求头 字段名 说明 示例 Accept 能够接受的回应内容类型（Content-Types） Accept: text/plain Accept-Charset 能够接受的字符集 Accept-Charset: utf-8 Accept-Encoding 能够接受的编码方式列表 Accept-Encoding: gzip, deflate Accept-Language 能够接受的回应内容的自然语言列表 Accept-Language: en-US Authorization 用于超文本传输协议的认证的认证信息 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 Cache-Control: no-cache Connection 该浏览器想要优先使用的连接类型 Connection: keep-alive Connection: Upgrade Cookie 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie Cookie: $Version=1; Skin=new; Content-Length 以 八位字节数组 （8位的字节）表示的请求体的长度 Content-Length: 348 Content-Type 请求体的 多媒体类型 Content-Type: application/x-www-form-urlencoded Date 发送该消息的日期和时间 Date: Tue, 15 Nov 1994 08:12:31 GMT Expect 表明客户端要求服务器做出特定的行为 Expect: 100-continue Host 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 Host: en.wikipedia.org:80 Host: en.wikipedia.org If-Match 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 允许在对应的内容未被修改的情况下返回304未修改 If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT If-None-Match 允许在对应的内容未被修改的情况下返回304未修改 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 If-Range: “737060cd8c284d8af7ad3082f209582d” Range 仅请求某个实体的一部分 Range: bytes=500-999 User-Agent 浏览器的浏览器身份标识字符串 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 Origin 发起一个针对 跨来源资源共享 的请求 Origin: http://www.example-social-network.com ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"HTTP常见请求方法 GET：向服务器请求数据 POST：将实体提交到指定资源，通常造成服务器资源的修改 PUT：上传文件，更新数据 DELETE：删除服务器上的对象 HEAD：获取报文首部，与GET相比，不返回报文的主体部分 OPTIONS：询问支持的请求方法，用与跨域请求 CONNECT：要求建立隧道，使用隧道进行TCP通信 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"HTTP报文 请求报文 请求行 请求方法，URL，HTTP协议版本 请求头 由关键字对组成，每行一对 空行 请求体 POST和PUT等请求携带的数据 响应报文 响应行 网络协议，状态码，状态码原因 响应头 关键字对组成，每行一对 空行 响应体 服务器响应的数据 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:4","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"HTTPS和HTTP HTTP Hyper Text Transfer Protocol，超文本传输协议。它传输的数据不是计算机底层的二进制包，而是完整的数据，如HTML文件、图片、查询结果等等，能够被上层应用所识别。以明文方式发送内容，不提供任何加密保护。 特点如下 支持客户/服务器模式 简单快速：客户只需向服务器传送请求方法和请求路径 灵活：允许传送任何类型的数据，数据类型由Content-Type标注 无连接：每次连接只处理一个请求（后面出现了keep-alive解决该问题） 无状态：无法根据之前的状态来对应地处理本次请求 HTTPS HTTPS的出现是为了解决HTTP的不安全性 HTTPS = HTTP + SSL/TLS 流程如下 客户端通过URL访问服务端，建立SSL连接 服务端将证书信息传送给客户端 客户端和服务器开始协商SSL的安全等级 客户端的浏览器根据双方协商好的安全等级，建立会话密钥，用密钥对公钥加密，传回服务端 服务端用自己的私钥解密出会话密钥 服务端利用会话密钥加密和客户端的通信 区别 HTTPS更安全 默认端口不同：HTTP是80，HTTPS是443 HTTPS需要进行加密和多次握手，性能不如HTTP HTTPS需要证书，证书功能越强大花费也越大 SSL加密 在HTTPS的加密中，采用的是对称加密+非对称加密，也就是混合加密 非对称加密解决密钥交换问题 发送密文的一方使用对方的公钥进行加密处理，然后对方用自己的私钥拿来解密 数字证书 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场 服务器的运营人员申请数字证书，机构会对已申请的公钥做一个数字签名，服务器在通信时就把这份数字证书也一起发给客户端 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:5","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"HTTP版本 HTTP1.0 与服务器只保持短暂的连接，每次请求都需要和服务器建立一个TCP连接 想要建立长连接要手动设置keep-alive HTTP1.1 到了1.1版本，默认支持长连接，建立一次连接，多次请求均由这个连接完成 引入了更多缓存控制策略 添加了一些新的请求方法，比如put，delete，options HTTP2.0 多路复用 HTTP2复用TCP连接，意味着在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按照顺序一一对应，避免了队头堵塞 二进制分帧 采用二进制格式传输数据，解析更高效 首部压缩 在客户端和服务器之间使用首部表来跟踪和存储之前发送的键值对，对于相同的数据不再通过每次请求和响应发送 服务器推送 引入了服务器推送，允许服务器推送资源给客户端 总结 HTTP1.0： 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接 HTTP1.1： 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用 在同一个TCP连接里面，客户端可以同时发送多个请求 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着 新增了一些请求方法 新增了一些请求头和响应头 HTTP2.0： 采用二进制格式而非文本格式 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行 使用报头压缩，降低开销 服务器推送 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:6","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"URL 组成部分 以http://www.aspxfans.com:8080/news/index.asp?boardID=5\u0026ID=24618\u0026page=1#name为例 协议：该URL协议就是http，后面的//为分隔符 域名：该URL域名为www.aspxfans.com，一个URL中，也可以使用IP地址来作为域名 端口：跟在域名后的就是端口，域名和端口间用:作为分隔符。端口不是必须的，若省略，则为默认端口（80、443…） 虚拟目录：域名后的第一个'/‘到最后一个’/‘为止。也不是一个必须的部分 文件名：最后一个’/‘到’?‘为止。若没有’?'，就是到'#'。也不是必须的部分 参数：'?‘到’#'，多个参数用'\u0026‘分隔 锚：'#‘到最后，非必须 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:7","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"UDP和TCP TCP面向连接，需要进行三次握手四次挥手，UDP不需要 TCP提供可靠服务，采用流量控制、编号与确认、计时器等手段保证数据无差错；UDP尽可能地传输数据，但不保证数据完整性 TCP面向字节流，会把应用层的报文分解为多个字节流，在目的站再重新装配；UDP直接发送应用层报文，接收方只需要去掉报文首部以后，原封不动地上交给上层应用 TCP只能点对点全双工通信 TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景。 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:8","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"网络模型 应用层：DNS、HTTP、SMTP等等 传输层：TCP、UDP 网络层：IP层 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:9","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"DNS 是什么 Domain Names System，域名系统，是进行域名和相对应的IP地址的转换的服务器 查询过程 首先搜索浏览器的DNS缓存，缓存中维护了一张域名与IP地址对应的表 若没有命中，则继续搜索操作系统的DNS缓存 若还是没有命中，操作系统就将域名发送到本地域名服务器，本地域名服务器递归查询自己的DNS缓存，成功则返回 若还没有命中，本地服务器就向上级服务器进行迭代查询 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址 本地域名服务器将IP地址返回给操作系统，同时加入自己的缓存 操作系统返回给浏览器，同时加入自己的缓存 浏览器得到IP地址，同时缓存 协议 DNS占用53端口，同时使用UDP和TCP 在区域传输的时候使用TCP 在域名解析的时候使用UDP ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:10","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"CDN Content Delivery Network，内容分发网络，简单来说，CDN就是根据用户的位置来分配最近的资源 用户在上网时就无需访问源站，而只需要访问最近的一个CDN节点，也叫边缘节点，实质上就是一个缓存了源站资源的代理服务器 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:11","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"状态码 1 表示请求已被接收，需要继续处理，属于临时响应，只包含状态行和某些响应头信息 100：通知客户端部分请求已被服务器接收，应当继续发送剩余部分 101：服务器根据客户端的请求切换协议，主要用于websocket或http升级 2 表示成功 200：成功，请求所希望的响应头或数据体将随此响应返回 201：已创建，请求成功且服务器创建了新的资源 204：无内容，服务器成功处理请求但没有返回任何内容 206：部分内容，服务器成功处理了部分请求 3 表示重定向 301：永久移动，请求的资源已经永久移动到新位置 302：临时移动，以后仍继续用原来地址请求 305：告知请求者应使用代理 4 表示请求错误 400：错误请求，语法错误 401：未授权，请求要求身份验证 403：禁止 404：找不到请求的资源 405：方法被禁用 408：请求超时 5 表示服务器错误 500：服务器内部错误 502：错误网关 503：服务不可用，一般是超载或者停机维护 505：HTTP版本不支持 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:12","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"GET和POST GET方法请求一个指定资源，该方法只被用于获取数据 POST方法用于将实体提交到指定的资源，会导致服务器的状态变化或副作用 区别 GET在浏览器回退时是无害的，但POST会再次提交请求 GET请求会被浏览器主动缓存，POST则需要手动设置 GET请求只能进行URL编码，POST支持多种编码方式 GET请求的请求参数会被完整地保留在浏览器历史记录，POST则不会 GET请求在URL中传送的参数有长度限制，POST没有 GET只接受ASCII字符，POST没有限制 GET的参数直接暴露在URL上，更不安全，不能拿来传递敏感信息，POST的参数放在Request body中 对于GET请求，浏览器会把http header和data一起发送，服务器响应200 对于POST，浏览器先发送header，服务器响应100，再发送data，服务器响应200 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:13","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"输入URL回车后发生什么 简单来说，发生以下几步 URL解析 DNS查询 TCP连接 通过DNS查询确定了IP地址后，经历三次握手建立TCP连接 HTTP请求 在已经建立了的TCP连接的基础上进行通信，浏览器发送HTTP请求到目标服务器 响应请求 服务器响应客户端的请求，发回资源 页面渲染 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:14","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"WebSocket HTML5提供的一种浏览器与服务器进行全双工通信的网络技术，属于应用层。 基于TCP传输协议，并复用HTTP的握手通道，浏览器和服务器只需要一次握手，就可以创建持久性的连接，进行双向数据传输 最大特点：服务器可以主动向客户端推送消息 原理：客户端向服务器notify一个带有接收者ID(recipients IDs)的event，服务器接收后通知所有active的客户端，只有ID在recipients IDs序列中的客户端才会处理这个事件 支持双向通信，有更强的实时性 支持多种类型的数据 建立在TCP协议之上，服务端的实现较为容易 数据格式轻量，性能开销小 没有同源限制，客户端可以和任何服务器通信 与HTTP有良好兼容性 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:1:15","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"CSS ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"单位 CSS单位 相对长度单位 em、ex、ch、rem、vw、vh、vmin、vmax、% 绝对长度单位 cm、mm、in、px、pt、pc px 表示像素，每个像素点都是大小相同的 em 相对于当前对象内文本的字体尺寸，默认1em = 16px em会继承父级元素的字体大小 rem 相对于根元素font-size的值，常用于做自适应、移动端适配 vh，vw 把窗口高宽分为100等分 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"选择器 优先级 内联 \u003e ID选择器 \u003e 类选择器 \u003e 标签选择器 1000 100 10 1 继承属性 字体属性 文本属性 元素可见性 表格布局 列表属性 引用属性 光标 特殊：a标签的字体颜色无法继承，h标签字体大小无法继承 无继承属性 display 盒子的属性 背景属性 定位属性 轮廓属性 生成内容属性 页面样式属性 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"盒模型 定义：当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的CSS基础框盒模型，将所有的元素表示为一个个的矩形盒子。 盒子模型分为两种 W3C标准盒模型 IE怪异盒模型 标准盒模型 width和height只包含内容宽高，不包含padding和border 怪异盒模型 width和height除了内容宽高，还包括了padding和border ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"BFC Blocking Formatting Context，块级格式化上下文，是页面中的一块渲染区域，拥有自己独立的渲染规则。 BFC的目的就是形成一个相对与外界完全独立的空间 内部的盒子会在垂直方向上一个接一个地放置 对于同一个BFC，两个相邻盒子的margin会发生塌陷，与方向无关 计算BFC高度时，浮动的子元素也参与计算 每个元素的左外边距与包含块的左边界相接触 BFC的区域不会与float的元素区域重叠 容器里的子元素不会影响到外面的元素，反之亦然 触发条件 根元素，即HTML元素 浮动元素 overflow属性不为visible display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position的值为absolute或fixed 应用场景 防止margin塌陷 简单来说，如果两个相邻的元素发生了margin的塌陷，就在其中一个元素外包裹一层容器，并使该容器触发BFC，那么这两个相邻的元素就不属于同一个BFC，也就不会出现外边距塌陷的情况了 清除内部浮动 想要计算浮动元素的高度，就需要触发BFC 自适应多栏布局 触发BFC 一般情况下，要触发BFC，只需修改overflow属性 overflow: hidden; ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:4","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"居中 水平居中 对于行内元素： text-align: center; 对于块级元素： // 自动边距 { margin: 0 auto; } // flex布局 { display: flex; justify-content: center; } // 绝对定位 { position: absolute; left: 50%; transform: translate(-50%, 0); } 垂直居中 对于行内元素： .parent { height: h; } .child { line-height: h; } 对于块级元素： 绝对定位 { position: absolute; top: 50%; transform: translate(0, -50%); } { position: absolute; top: 0; bottom: 0; margin: auto 0; } { position: absolute; top: 50%; height: h; margin-top: -0.5h; } flex { display: flex; align-items: center; } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:5","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"flex布局 Flexible Box，简称flex，意为弹性布局 容器中存在两条轴，主轴和交叉轴，二者垂直。容器中的元素默认沿主轴排列，可以通过flex-direction来决定主轴，默认是row 属性 .container { display: flex; flex-direction: row | row-reverse | column | column-reverse; } .container { flex-wrap: nowrap | wrap | wrap-reverse; } justify-content：项目在主轴上的对齐方式 .container { justify-content: flex-start | flex-end | center | space-between | space-around; } align-items：项目在交叉轴上的对齐方式 .container { align-items: flex-start | flex-end | center | baseline | stretch; } 复合属性flex flex属性是flex-grow，flex-shrink，flex-basis的简写，默认为0 1 auto ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:6","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"CSS画三角形 原理：边框实际上是个梯形 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:7","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"性能优化 内联首屏关键CSS 内联关键CSS，可以使浏览器下载完html后就立即渲染，使渲染时间提前。 较大的CSS文件就不应该使用内联 异步加载CSS 资源压缩 用webpack、rollup等模块化工具，压缩CSS代码 合理使用选择器 不要过多嵌套选择器。因为CSS匹配规则是从右往左，先找到xx，排除祖先不是xx，再以此类推 id选择器可以不再嵌套其他的 通配符和属性选择器避免使用 减少使用昂贵的属性 box-shadow，border-radius等等 不要使用@import 对可以继承的属性不要重复编写 小的icon图片转为base64编码 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:8","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"回流、重绘 回流 布局引擎根据各种样式，计算盒子在页面上的大小和位置 重绘 计算好位置和大小后，根据盒子特性进行绘制 渲染过程 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:9","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"隐藏页面元素 display设置为none 元素彻底消失，会触发回流和重绘，不占据空间不触发事件 visibility设置为hidden 元素不可见，仍占据页面空间，不会触发回流，无法响应点击事件 opacity设置为0 元素不可见，仍占据页面空间，不会触发回流，仍可以响应点击事件 height/width设置为0 元素不可见，会触发回流和重绘，不占据空间不触发事件 position设置为absolute，将其移出可视区域 transform: scale(0,0);，将元素缩放为0，仍占据位置，但不会响应绑定的监听事件 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:10","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"link和@import的区别 link是XHTML标签，除了加载CSS，还可以定义RSS等其他事务；@import只能加载CSS link是在页面载入时同时加载，@import在页面完全载入后加载 link无兼容问题 link支持使用JS控制DOM去改变样式，@import不支持 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:11","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"两栏布局和三栏布局 两栏布局 将页面分割成左右宽度不等的两列，宽度较小的列（次要布局元素）设为固定宽度，另一列（主要布局元素）填充满剩余空间 方法一，浮动 使用float，左浮左边栏 右边栏使用margin-left撑开固定的宽度 为父级元素添加BFC 方法二，flex布局 该方法要注意的是，flex布局中，align-items属性的默认值是stretch，导致了列等高的效果，若想让两个盒子高度自动，需要设置align-items: flex-start; \u003cstyle\u003e .box { display: flex; } .left { width: 100px; } .right { flex: 1; } \u003c/style\u003e \u003cdiv class=\"box\"\u003e \u003cdiv class=\"left\"\u003e左边栏\u003c/div\u003e \u003cdiv class=\"right\"\u003e主要内容区\u003c/div\u003e \u003c/div\u003e 三栏布局 三栏布局有很多种实现方法 方法一，两边float，中间margin撑开。该方法需要注意的是，html结构中，中间部分需要放在最后，否则右侧将会被挤到下方。同样，由于利用了浮动，父级元素需要添加BFC。这种方式存在缺陷：主体内容最后加载 方法二，两边absolute，中间margin。需要注意父元素需要用相对定位。 方法三，flex布局。类似于上述两栏布局。 双飞翼 圣杯 注意点： 要先渲染middle，middle写前面 理解负边距的作用 \u003cdiv class=\"header\"\u003eheader\u003c/div\u003e \u003cdiv class=\"content\"\u003e \u003cdiv class=\"middle\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"left\"\u003eleft\u003c/div\u003e \u003cdiv class=\"right\"\u003eright\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"footer\"\u003efooter\u003c/div\u003e .header { width: 100%; height: 30px; background: red; } .content { overflow: hidden; padding: 0 100px; } .footer { width: 100%; height: 30px; background: red; } .middle { position: relative; width: 100%; float: left; height: 100px; background: rebeccapurple; } .left { position: relative; width: 100px; height: 100px; float: left; left: -100px; margin-left: -100%; background: steelblue; } .right { position: relative; width: 100px; height: 100px; float: left; right: -100px; margin-left: -100px; background: steelblue; } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:12","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"动画 transition animation 二者区别 transition是过渡属性，强调的是过渡，需要一个触发事件，比如焦点、点击等，才执行动画。只需设置开始帧和结束帧 animation是动画属性，设定好时间后可以自己执行，且可以循环一个动画，可以设置多个关键帧(@keyframe) ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:13","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"position static 默认值，没有定位，出现在正常文档流，会忽略z-index或top等声明 relative 相对定位，相对其原来的位置进行定位，位置通过top等属性规定 absolute 绝对定位，相对于static定位以外的第一个父元素进行定位 fixed 固定定位，指定元素相对于屏幕可视窗口的位置来指定元素位置，位置在滚动时不会改变 sticky 粘性定位，依赖于用户的滚动，在relative和fixed间切换 fixed和absolute的区别 根元素不同：fixed的根元素是浏览器，absolute的是第一个非static的父元素 absolute会滚动，fixed不会 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:2:14","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"浏览器 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:3:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"浏览器内部多个标签页通信 实现多标签页通信，本质上都是通过中介者模式 websocket：标签页向服务器发数据，服务器向其他标签页转发 localStorage：对localStroage进行监听 postMessage ShareWorker ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:3:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"浏览器安全 XSS CSRF 网络劫持 DNS劫持 DNS强制解析：通过修改运营商的本地DNS记录，引导用户流量到缓存服务器 302：通过监控网络出口的流量，分析判断哪些内容是否可以劫持处理；对劫持的内存发起302跳转的回复，引导用户获取内容 HTTP劫持 由于http明文传输，所以响应内容可能被修改(添加广告) 解决 DNS劫持涉嫌违法，已被监管；http劫持就全站https，运营商无法获取明文，就无法劫持响应内容 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:3:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"路由 为什么要使用路由 现在都使用AJAX异步请求完成页面的无缝刷新，导致请求时浏览器的URL不会有任何变化 hash模式 利用window.location.hash属性以及窗口的onhashchange事件，监听浏览器的hash地址变化，执行相应的js动态切换网页内容 hash指地址中#号以及后面的内容，也称散列值，锚点 hash不随着请求发到服务器端，所以改变hash不会重载 监听窗口的onhashchange事件，通过window.location.hash属性来获取和设置hash值 hash变化会直接反映到浏览器地址栏 history模式 URL中没有#，使用传统的路由分发模式：用户输入一个URL时，服务器会接收这个请求，并解析URL，然后做出相应的逻辑处理 window.history指向History对象，代表当前窗口的浏览历史 可以通过history.length得出当前的窗口一共访问过几个网址 出于安全，浏览器不允许脚本读取这些地址，但允许地址之间导航 前进和后退其实就是对History对象进行操作 history模式有一个缺点，就是当改变页面地址后强制刷新浏览器，如果后端没有做好相应的准备就会报错404。因为刷新后，是拿当前的地址去请求服务器的，如果服务器没有相应的资源，就会返回404 如何解决这个缺点 nginx代理 如果是vue项目，增加一个简单的回退路由，如果URL不匹配任何静态资源，服务器就提供与index.html相同的页面资源。比如使用firebase模拟后端时，修改firebase.json文件即可 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:3:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"缓存 缓存位置 一共三种，按优先级排序 Service Worker：运行在主线程之外，缓存是持续性的 Memory Cache：内存缓存，效率最高，但持续性短，随着内存的释放而释放 Disk Cache：读取速度慢，但容量和时效性优 强缓存 使用强缓策略时，只要判断有效就直接使用，不需要向服务器确认 Expires 服务器在响应头添加Expires属性，指定资源的过期时间 使用绝对时间，在这个时间前都可以直接使用该缓存 Cache-Control no-cache，表示每次请求都要校验缓存是否过期 max-age，表示多久内不用重新请求资源 优先级高于Expires 协商缓存 如果缓存里的资源是新鲜的，则返回304，否则返回200 Last-Modified / If-Modified-Since Etag / If-None-Match 不同的刷新方式 刷新按钮/F5：服务器对文件检查新鲜度 Ctrl+F5：相当于清除了缓存 地址栏回车：正常流程 本地存储 本地存储共有三种方式，coookie，localStorage和sessionStorage 三者的异同 特性 cookie localStorage sessionStorage 生命周期 一般由服务器端生成，会设置失效时间。若没有设置，则默认关闭浏览器时清除 除非手动清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 5M 5M 与服务器端通信 每次都会被携带在HTTP请求头部中，若使用cookie保存过多数据会带来性能问题 仅在客户端保存，不与服务器端进行通信 仅在客户端保存，不与服务器端进行通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:3:4","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"跨域 来源 跨域问题的来源，在于浏览器为了安全引入的同源策略。 同源：协议、主机名、端口都相同 仅浏览器有跨域限制，服务端之间并不受影响 同源策略限制了什么 主要目的在于保证用户的信息安全，只是对js脚本的限制，比如一般的img等请求都不会有这个限制，因为这些操作不会通过响应结果来进行可能出现安全问题的操作 当前域下的js脚本不能访问其他域的cookie、localStorage和indexDB 当前域下的js脚本不能操作、访问其他域下的DOM 当前域下ajax无法发送跨域请求 如何判定 解决方案 CORS CORS是目前最主流的跨域解决方案，方案依赖服务端在响应头添加Access-Control-Allow-*头，告知浏览器端应通过此请求。优势在于前端并不需要作出改动 CORS将请求分为简单请求和需预检请求 简单请求：请求方法为GET, HEAD, POST，请求头为Accept,Accept-Language,Content-Language,Content-Type。 对于简单请求，浏览器就直接发出CORS请求，在请求的头信息中增加一个Origin字段，说明本次请求来自哪个源，服务器根据这个值来决定是否同意这次请求 如果同意，返回的响应就会多出一些信息头；不同意，会返回一个正常的HTTP响应，但是上面没有Access-Control-Allow-Origin等信息。该错误无法通过状态码识别（可能还是200） 预检请求：当一个请求不满足简单请求的条件时，浏览器就自动向服务端发出一个OPTIONS请求，通过服务端响应判定请求是否被允许 请求头除了包含Origin字段，还会包含所用的方法字段以及将会额外发送的头信息字段。服务器判断这些字段后决定是否通过 在CORS请求中，如果想要传递Cookie，就需要满足以下条件 设置withCredentials为true 设置Access-Control-Allow-Credentials为true 设置Access-Control-Allow-Origin为非***** 反向代理 依赖同源的服务端做一个转发处理，将跨域请求转换为同源请求 前端只需要切换接口 JSONP 利用浏览器加载JavaScript资源文件时不受同源策略限制，即\u003cscript\u003e标签没有跨域限制，而实现跨域获取数据，具体流程如下 全局注册一个函数 构造一个请求URL 生成一个\u003cscript\u003e并把src设置为上一步的URL，插入到文档中 服务端构造一个JavaScript函数调用表达式并返回 浏览器加载并执行以上代码 JSONP的缺点 只支持GET 不安全，易受XSS攻击 Post Message 即在两个 origin 下分别部署一套页面 A 与 B，A 页面通过 iframe 加载 B 页面并监听消息，B 页面发送消息。 windouw.name 主要是利用 window.name 页面跳转不改变的特性实现跨域，即 iframe 加载一个跨域页面，设置 window.name，跳转到同域页面，可以通过 $('iframe').contentWindow.name 拿到跨域页面的数据。 nginx代理跨域 实质和CORS原理一样 WebSocket ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:3:5","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Webpack ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:4:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"什么是Webpack 一个用于现代JavaScript应用程序的静态模块打包工具 静态模块，指的是开发阶段可以被webpack直接引用的资源，即可以直接被获取打包进bundle.js的资源 在webpack处理应用程序的时候，会在内部构建一个依赖图，依赖图对应映射到项目所需的每个模块，不再局限于js文件 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:4:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Webpack能做什么 编译代码能力，提高效率，提高兼容性 模块整合能力，提高性能和可维护性，解决频繁请求文件问题 模块化能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源的加载都可以通过代码控制 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:4:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"手写JS系列 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"instanceof function myInstanceof (target, Fn) { if(target === null || typeof target !== 'object') { return false } let proto = target.__proto__ let prototype = Fn.prototype while(1) { if(proto === prototype) { return true } if(proto === null) { return false } proto = proto.__proto__ } } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"new new都做了些什么？ 创建一个空对象 为创建出的空对象添加属性__proto__，把该属性链接到构造函数的原型对象 将该对象作为this的上下文 如果该函数没有返回对象，则返回this function objectFactory () { let obj = new Object() // 创建空对象 Constructor = [].shift.call(arguments) // 构造函数 obj.__proto__ = Constructor.prototype // 链接 let res = Constructor.apply(obj, arguments) return typeof res === 'object' ? res : obj } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"setTimeout实现setInterval function mySetInterval(fn, interval) { // 设置递归函数，模拟定时器执行。 function callback() { fn(); setTimeout(callback, interval); } // 启动定时器 setTimeout(callback, interval); } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"bind，call和apply call call()方法在使用一个指定的this值和若干个指定的参数值的前提下，调用某个函数或方法 Function.prototype.myCall = function (context) { context = context || window context.fn = this let args = [...arguments].slice(1) let res = context.fn(...args) delete context.fn return res } apply Function.prototype.myApply = function (context, arr) { context = context || window context.fn = this let res = null if (!arr) { res = context.fn() } else { res = context.fn(...arr) } delete context.fn return res } bind bind()方法会创建一个新函数，当这个新函数被调用时，bind()的第一个参数会作为运行时的this，之后的一系列参数将会在传递的实参前传入作为它的参数 Function.prototype.myBind = function (context) { if(typeof this !== 'function') { throw new Error('Not callable') } let self = this let args = [...arguments].slice(1) let fNOP = function () {} let fBound = function () { let bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)) } fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:4","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"防抖和节流 防抖 n秒后才执行该事件，如果n秒内重复触发，则重新计时 function debounce(func, wait) { let timeout = null return function () { let context = this // 保留上下文 let args = arguments // 保留参数 // 若已存在定时器，则需要重置定时器 if(timeout) { clearTimeout(timeout) timeout = null } // 设置定时器，在指定时间后执行函数 timeout = setTimeout(() =\u003e { func.apply(context, args) }, wait) } } 节流 n秒内只运行一次，若n秒内重复触发也没用 function throttle(func, delay) { let curTime = Date.now() // 记录当前时间戳 return function() { let context = this let args = arguments let nowTime = Date.now() // 超过delay则执行函数 if(nowTime - curTime \u003e= delay) { curTime = Date.now() return func.apply(context, args) } } } 应用场景 防抖，主要应用在连续的事件，但只需要触发一次的场景 搜索框的输入：用户停止输入后才显示建议 输入的校验 窗口大小的调整，只有当调整完成后，才计算新的大小并渲染 文本编辑器实时保存，如飞书、notion 节流，间隔一段时间执行一次回调 滚动，每隔一秒计算一次位置信息 播放进度条 搜索联想（也可以做成防抖） 要点 防抖，重在防止抖动。所以n秒内重复触发需要清零，代码关键在于clearTimeout 节流，重在控制流量。所以n秒内只可以触发一次，重在开关锁，timer = timeOut 或者 = null ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:5","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"浅拷贝 如果是基本数据类型，就直接拷贝值；如果是引用数据类型，直接拷贝内存地址 Object.assign() 接受的第一个参数是目标对象，其余参数是源对象 同名属性会覆盖 若第一个参数不是对象，则会先把它转为对象，所以第一个参数不能是null或undefined 扩展运算符 let cloneObj = {...obj} 数组浅拷贝 slice不加参数，可以实现数组浅拷贝 concat不加参数，可以实现数组浅拷贝 手写一个浅拷贝 function shadowCopy(obj) { if(!obj || typeof obj !== 'object') { return } let cloneObj = Array.isArray(obj) ? [] : {} for(let key in obj) { if(obj.hasOwnProperty(key)) cloneObj[key] = object[key] } return cloneObj } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:6","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"深拷贝 与浅拷贝不同，对于一个新的引用类型，深拷贝会先创建一个引用类型，然后将相应的值赋给它，意味着内存地址不同 JSON.stringify() 原理就是利用stringify将对象序列化，再用parse反序列化 但是拷贝的对象如果含有函数，symbol或者undefined等，拷贝时它们会消失 let obj2 = JSON.parse(JSON.stringify(obj1)) 手写一个深拷贝 function deepCopy(obj) { if(!obj || typeof obj !== 'object') { return } let cloneObj = Array.isArray(obj) ? [] : {} for(let key of obj) { if(obj.hasOwnProperty(key)) cloneObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key] } return cloneObj } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:7","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"数组的各种方法 push Array.prototype.myPush = function() { for(let i = 0; i \u003c arguments.length; i++) { this[this.length] = arguments[i] } // push方法返回push后的长度 return this.length } map Array.prototpe.myMap = function (func) { if(typeof func !== 'function') { throw new Error('Type Error') } // map会返回一个新数组 let res = [] for(let i = 0; i \u003c this.length; i++) { res.push(func(this[i])) // 如果是forEach // this[i] = func(this[i]) } return res } filter Array.prototype._filter = function(func) { if (typeof func !== \"function\") { throw Error('Type Error'); } let res = []; for (let i = 0, len = this.length; i \u003c len; i++) { func(this[i]) \u0026\u0026 res.push(this[i]); } return res; } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:8","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"数组拍平 先总结Array.prototype.flat()的特性和用法 返回的是新数组，对原数组没有影响 不传参时默认拉平一层，可以传整数表明要拉平的层数，Infinity为完全拉平，小于等于0为不拉平 会跳过空位 要实现一个数组拍平函数，要做到的是以下事情 遍历数组 判断数组元素是否是数组 如果是数组，拉平一层 可以根据这个思路，开始手写出第一版代码 function myFlat (arr) { let arrRes = [] // 存放拍平的数组 arr.map(item =\u003e { if(Array.isArray(item)) { arrRes = arrRes.concat(myFlat(item)) // arrRes = arrRes.concat([].concat(...item)) } else { arrRes.push(item) } }) } 该版本中，使用递归调用/扩展运算符的方法，实现拍平数组，但完成的是Array.prototype.flat(Infinity)，会把任何数组拍平至一维。要想达到通过参数控制的效果，需要进一步控制递归条件 function myFlat(arr, depth) { let res = [] arr.map(item =\u003e { Array.isArray(item) \u0026\u0026 depth \u003e 1 ? res = res.concat(myFlat(item, depth - 1)) : res.push(item) }) return res } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:5:9","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"JavaScript ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Promise Promise是什么 Promise是异步编程的一种解决方案，ES6将其写进了语言标准，统一了用法 所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 从语法上，Promise是一个对象，可以从它获取异步操作的消息 Promise对象的特点 对象状态不受外界影响。Promise对象有三个状态，pending，fulfilled，rejected。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise名称的由来：承诺 一旦状态改变，就不可再变，任何时候都可以拿到这个结果。Promise的状态改变只有两种可能：pending到fulfilled或rejected。只要这两种情况发生，就称为定型，resolved 优缺点 优点 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，解决了回调地狱 可以支持多个并发的请求，获取并发请求中的数据 提供统一的接口，使得控制异步操作更容易 缺点 无法取消Promise，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，内部抛出的错误不会反映到外部 处于pending状态时，无法得知目前进展到了哪个阶段 基本用法 ES6规定，Promise对象是一个构造函数，用来生成Promise实例 Promise接收一个函数作为参数，该函数的两个参数分别是resolve和reject resolve函数的作用：将Promise的状态变成fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去 reject函数的作用：将Promise的状态变成rejected，在异步操作失败时调用，并将报出的错误传递出去 const myPromise = new Promise(function(resolve, reject) { if(/* 异步操作成功 */) { resolve(value) } else { reject(error) } }) Promise实例生成以后，可以用then方法分别指定fulfilled和rejected状态的回调函数 then方法接收两个回调函数作为参数，第一个回调函数 myPromise.then(function(value) { // success }, function(error) { // failure }) 手写基本的Promise class myPromise { // 定义三种状态 static PENDING = '准备态' static FULFILLED = '完成态' static REJECTED = '拒绝态' constructor(func) { // 默认状态 this.status = myPromise.PENDING // 执行结果 this.result = null // 保存回调函数 this.resolveCallbacks = [] this.rejectCallbacks = [] try { // 绑定this再调用 func(this.resolve.bind(this), this.reject.bind(this)) } catch (error) { // 报错的话要reject this.reject(error) } } resolve(result) { setTimeout(() =\u003e { if (this.status === myPromise.PENDING) { this.status = myPromise.FULFILLED this.result = result this.resolveCallbacks.forEach(callback =\u003e { callback(result) }) } }); } reject(result) { setTimeout(() =\u003e { if (this.status === myPromise.PENDING) { this.status = myPromise.REJECTED this.result = result this.rejectCallbacks.forEach(callback =\u003e { callback(result) }) } }); } then(onFULFILLED, onREJECTED) { // 为了实现链式调用 // then返回一个promise实例 return new myPromise((resolve, reject) =\u003e { // then传入的两个参数需要是函数 onFULFILLED = typeof onFULFILLED === 'function' ? onFULFILLED : () =\u003e { } onREJECTED = typeof onREJECTED === 'function' ? onREJECTED : () =\u003e { } if (this.status === myPromise.PENDING) { this.resolveCallbacks.push(onFULFILLED) this.rejectCallbacks.push(onREJECTED) } if (this.status === myPromise.FULFILLED) { setTimeout(() =\u003e { onFULFILLED(this.result) }); } if (this.status === myPromise.REJECTED) { setTimeout(() =\u003e { onREJECTED(this.result) }); } }) } } const promise = new myPromise((resolve, reject) =\u003e { resolve('成功') }) promise.then( resolve =\u003e { console.log(resolve) }, reject =\u003e { console.log(reject) } ) ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"数据类型 基本类型 number string boolean undefined null symbol Symbol Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用 作用 元编程，更改原生js的行为 作为key使用，用Reflect.ownKeys()拿到所用key属性 引用类型 复杂类型统称Object Object Array Function Date RegExp Map Set 判断数据类型的方法 typeof typeof返回一个字符串，表示未经计算的操作数的类型 可以用来判断一个变量是否存在，即typeof是不是为undefined 缺点：对于引用类型，只有function能被识别，其他都只能识别为object instanceof instanceof用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上 缺点：不能正确判断基本数据类型 Object.prototype.toString.call 统一返回[object xxx]格式的字符串 通用检测方法 结合以上方法，可以写出通用的数据检测方法 function getType(obj) { let type = typeof obj // 基本数据类型可以直接返回 if(type !== 'object') { return type } // 正则处理 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1') } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"原型和原型链 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"闭包 闭包，指有权访问另一个函数作用域中变量的函数 创建闭包最常见的方式是在函数内创建另一个函数，创建的新函数可以访问到当前函数的局部变量 无论何时何地，如果将函数作为返回值，就会看到闭包在这些函数中的应用，例如防抖节流就是经典的闭包 用途 使我们在函数外部可以访问到函数内部的变量，可以创建私有变量 使已经运行结束的函数上下文中的变量继续保留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:4","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"作用域和作用域链 作用域 全局作用域 最外层函数和最外层函数外面定义的变量拥有全局作用域 未定义而直接赋值的变量拥有全局作用域 所有window对象的属性拥有全局作用域 过多全局作用域变量会污染全局命名空间，引起命名冲突 函数作用域 声明在函数内部的变量 内层作用域可以访问外层作用域，反之不行 块级作用域 let和const声明或由大括号包裹的代码片段 循环中适合绑定块级作用域 作用域链 在当前作用域中查找所需变量，但该作用域没有这个变量，则它就是自由变量，就需要依次向上级作用域查找，直到访问到window对象，一层层的关系就是作用域链 保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数 作用域链的本质就是一个指向变量对象的指针列表，变量对象是一个包含了执行环境中所有变量和函数的对象。 作用域链的前端始终是当前执行上下文的对象。后端始终是全局对象 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:5","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"事件模型 定义 JS中的事件，可以理解为在HTML文档或者浏览器中发生的一种交互操作，使得网页具备交互性，比如加载事件，鼠标事件等等 事件流 事件流都会经历三个阶段 事件捕获 处于目标 事件冒泡 三种模型 原始事件模型 直接绑定（HTML或JS），绑定速度快 只支持冒泡，不支持捕获 同一个类型的事件只可以绑定一次。后绑定的会覆盖先绑定的。 标准事件模型 共有三个过程，事件捕获阶段：事件从document一直往下传到目标元素，依次检查经过的节点是否绑定了事件监听函数，有则执行；事件处理阶段：事件到达目标节点并触发监听函数；事件冒泡阶段：事件从目标元素一直往上传到document，依次检查经过的节点是否绑定了事件监听函数，有则执行。 addEventListener(eventType, handler, useCapture) useCapture用于指定是否在捕获阶段进行处理，默认为false IE事件模型（基本已废弃） 只有两个阶段：事件处理和事件冒泡 attachEvent(eventType, handler) 如何阻止事件冒泡 event.stopPropagation() ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:6","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"事件代理 通俗地来说，事件代理，就是把一个元素响应事件的函数委托给另一个元素，事件委托在冒泡阶段完成。 事件委托把一个或一组元素的事件委托到它的父节点或者更外层的节点上，真正绑定事件的成了外层元素 优点 减少需要的内存，提升整体性能 动态绑定，减少重复的工作 局限性 focus, blur等没有冒泡机制，无法进行委托 mousemove, mouseout等事件，虽然有冒泡阶段，但只能通过不断通过位置去计算定位，对性能消耗高，也不适合事件委托 如果全用事件代理，可能会出现事件误判 应用 有一个列表，有大量表项，需要在点击表项时响应一个事件 如果要为每个表项都绑定上一个事件，内存消耗非常大 const lis = document.getElementByTagName('li') for (const li of lis) { li.onClick = function (e) { console.log(e.target.innerHTML) } } 这时就可以利用事件代理，把事件绑定在ul元素上，执行事件的时候再去匹配目标元素 document.getElementById('ul').addEventListener('click', (e) =\u003e { // 兼容性处理 const event = e || window.event const target = event.target || event.srcElement // 判断是否匹配目标元素 if(target.nodeName.toLocalLowerCase === 'li') { console.log(target.innerHTML) } } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:7","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"事件循环 事件循环是什么 JS是一个单线程的语言，实现单线程非阻塞的方式就是事件循环 在JS中，所有的任务都可以分为同步任务和异步任务，同步任务将直接进入主线程执行，异步任务推入任务队列。当主线程的任务清空，就去任务队列读取任务 宏任务和微任务 宏任务：script脚本的执行，setTimeout，setInterval，setImmediate 微任务：promise的回调，node中的nextTick等 Event Loop 执行同步任务 执行完所有同步任务，执行栈为空，检查是否有异步任务 执行所有微任务 开始下一轮Event Loop，执行宏任务中的异步代码 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:8","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"变量提升与函数提升 包括变量和函数在内的所有声明都在代码被执行前首先处理(仅针对var) 定义声明是在编译阶段进行的 赋值声明会被留在原地等待执行阶段 JavaScript 引擎并不总是按照代码的顺序来进行解析。在编译阶段，无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，这个过程被称为提升。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 变量提升 使用var声明的变量存在变量提升 name = 'xyh' var name console.log(name) // xyh 上面这个例子就很好地体现了变量提升 从上往下看，我们先添加了全局变量name，window.name = ‘xyh’ 然后我们再次声明了name 最后我们打印出的结果却不是未初始化的undefined而是xyh ES6新增的const和let可以规避变量提升 函数提升 函数字面量不会被提升 优先级 函数提升的优先级高于变量提升 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:9","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"数组的遍历方法 方法 是否改变原数组 特点 forEach() 取决于元素的数据类型 数组方法，没有返回值，是否会改变原数组取决于数组元素的类型是基本类型还是引用类型 map() 否 数组方法，不改变原数组，有返回值，可链式调用 filter() 否 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 for…of 否 for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 every() 和 some() 否 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. find() 和 findIndex() 否 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 reduce() 和 reduceRight() 否 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:10","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"数字精度丢失 为什么在JavaScript中，0.1 + 0.2 !== 0.3？ 这是因为，在JavaScript中，是用浮点数的格式来存储数字的，采用的是IEEE754规范，这样的存储结构的优点是可以归一化处理整数和小数，节省存储空间 计算时要从十进制转到二进制，而比如0.1，转成二进制是除不尽的，由于精度的问题就会出现误差 解决方案 function strip(num, precision) { return +parseFloat(num.toPrecision(precision)) } ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:11","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"this指向 绝大多数情况下，函数的调用方式决定了this的指向 在函数执行过程中，this一旦被确定了就不可以再更改 绑定规则 默认绑定 非严格模式下，this默认绑定到全局对象 隐式绑定 函数可以作为某个对象的方法来调用，此时this自然就指向上一级对象 new绑定 通过new生成一个实例对象，此时this就指向这个实例对象 显示修改 apply，call，bind可以显示修改this的指向 箭头函数 ES6中的箭头函数，让我们能在代码书写的时候就确定好this的指向，即编译时绑定this ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:12","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"ES6 var，let和const 使用var声明的变量存在变量提升 使用var可以对一个变量进行多次声明 函数内使用var，则该变量是局部的 暂时性死区：只要块级作用域里存在let、const命令，这个区域就不再受外部影响：在let或const声明该变量前，它都是不可用的。只有等到声明变量的那一行代码出现，才可以获取和使用该变量 var a = 123 if(true) { a = 'ABC' // Reference Error let a } const必须初始化，且变量值不能再修改 Set和Map 共同点：都可以存储不重复的值 不同点：集合Set以[值, 值]方式存储，字典Map以[键, 值]方式存储 Set 类似于数组，但是成员的值是唯一的 常见方法 add()，添加某个值，返回Set本身 delete()，删除某个值，返回一个布尔值表示是否成功删除 has()，判断是否包含某元素 clear()，清楚成员 for…in 和 for…of 的区别 for…of是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构，比如对象、数组，并且返回各项的值，和ES3中的for…in区别如下 for…of遍历获取的是对象的键值value，for…in获取的是键名key for…in会遍历对象的整个原型链，性能很差不推荐使用 对于数组的遍历，for…in会返回数组中所有可枚举的属性，for…of只会返回下标对应的属性值 一般使用for…of 箭头函数 更加简洁 没有自己的this，只会在自己的上一层作用域继承this，所以箭头函数中的this在定义时就确定，之后不会改变，即使使用call和apply 不能作为构造函数使用 没有自己的arguments 没有prototype 不能作为Generator函数 Proxy 定义：用于定义基本操作的自定义行为 本质：修改程序默认行为，相当于在编程语言层面上修改，属于元编程 用法： Proxy为构造函数，它用来生成Proxy实例 let proxy = new Proxy(target, handler) target表示的是要拦截的目标对象，它可以是一个任何类型的对象，也可以是另一个代理 handler以函数作为属性的对象，各属性中的函数分别定义了执行各种操作时代理的行为 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:6:13","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Typescript ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:7:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"是什么 TypeScript是JavaScript的超集，支持ES6语法，支持面向对象编程的概念。 它是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误。 扩展了JavaScript的语法，现有的JavaScript程序可以不作改变地在TypeScript中工作。 是为大型应用开发设计的语言，编译阶段仍需要编译成纯JavaScript。 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:7:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"特性 类型批注和检查 类型推断 类型擦除：编译过程中批注的内容和接口会在运行时擦除 接口：定义数据的类型 interface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 } 枚举：用于取值被限定在一定范围内的场景 Mixin：可以接受任意类型的值 泛型：写代码时使用一些以后才指定的类型 名字空间：名字只在该区域有效，其他区域可以重复使用该名字 元组：合并不同类型的对象，相当于一个可以装不同类型数据的数组 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:7:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"数据类型 boolean number string array let arr: string[] = ['ss', 'pp'] let arr: Array\u003cnumber\u003e = [1, 2] tuple：元组类型 let tupleArr: [number, string, boolen] = [12., '34', false] enum any null, undefined void，表示该方法没有返回值 never，是其他类型的子类型，可以赋值给任何类型，代表从来不会出现的值。一般来指定那些总是会抛出异常、无限循环。返回never的函数必须存在无法达到的终点 object ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:7:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"React ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:8:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Vue ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Vue3和Vue2的区别 Proxy替代defineProperty Object.defineProperty() 该方法直接在对象上定义一个新属性或者修改现有属性，返回该对象 实现响应式的途径是通过get和set两个属性 缺点： 检测不到对象属性的新增和删除 数组的一些方法无法监听到 需要对每个属性遍历监听，如果是嵌套对象需要深层监听，带来性能问题 Proxy 监听是针对一个对象的，对这个对象的所有操作都会进入监听，就可以完整代理所有属性了 缺点：兼容性差 Composition API替代Options API Options API Composition API 优势 逻辑复用 类型推断 代码更易压缩 减少this指向不明的情况 性能提升 Treeshaking ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"双向数据绑定 Vue采用的是基于数据劫持的双向数据绑定 利用Proxy或者Objcet.defineProperty等方法，生成Observer对对象/对象属性进行劫持，在属性发生变化后就可以通知订阅者 解析器Compiler解析模板中的指令Directive，收集指令所依赖的方法和数据，等待数据变化后渲染 Watcher属于Observer和Compiler的桥梁。将接收到的Observer产生的数据变化，根据Compiler提供的指令，来进行视图的渲染，使得数据变化反映在视图变化上 Object.defineProperty 在Vue2中，数据劫持用的是Object.defineProperty。它的作用就是劫持对象的属性。通常对属性的getter和setter进行劫持，就能够在属性变化时进行特定的相应的操作。 缺点：对某些属性进行操作时无法拦截。比如对于数组而言，大多操作都无法拦截，除非自己手动重写数组的方法 Proxy Vue3中，改用Proxy来进行数据劫持 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"MVVM 定义 MVVM：Model，View，ViewModel Model代表数据模型，数据和业务逻辑都在Model里定义 View代表UI视图，负责数据的展示 ViewModel负责监听Model的数据变化并控制视图的更新，处理用户的交互操作 Model和View并无直接关联，Model和ViewModel之间有数据双向绑定的关系。MVVM框架使得开发者只需要专注于数据的维护操作，而不需要自己去操作DOM 优点 分离了视图和模型，降低代码耦合度，提高重用性。一个ViewModel可以绑定许多不同的view 提高可测性。ViewModel的存在可以帮助开发者更好地编写测试代码 自动更新DOM。利用双向绑定，数据更新后视图就会自动更新，不需要手动操作DOM 缺点 不好调试。看到界面发生异常时，不知道是View还是Model出了问题。双向数据绑定还会使一个位置的bug传递到其他位置，更难定位出原始为止。数据绑定的声明是指令式地写在View中，这些内容无法打断点debug Model过大。模块很大时，如果不释放内存就会占用过高内存，降低性能 维护成本高 Vue中的MVVM MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -\u003e 视图更新；视图交互变化(input) -\u003e 数据model变更的双向绑定效果。 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:3","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"为什么data是函数而不是对象 一句话，函数返回的对象内存地址并不相同 vue组件可能会有多个实例，采用函数可以返回一个全新的data，每个实例的数据就不会被其他实例的污染 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:4","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"组件通信 props传递数据 适用场景：父组件传递数据给子组件 子组件设置一个props属性，定义接收父组件传来的参数 父组件在子组件标签中使用字面量来传值 $emit触发自定义事件 适用场景：子组件传递数据给父组件 子组件通过$emit触发自定义事件，第一个参数为事件名，第二个参数为传递的值 父组件绑定监听器，拿到传递的值 EventBus 适用场景：兄弟组件传值 创建一个中央事件总线 兄弟组件通过$emit触发自定义事件，通过$on监听自定义事件 vuex 适用场景：复杂关系的组件数据传递 相当于一个用来存储共享变量的容器 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:5","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"v-show和v-if 共同点 作用效果相同，都是控制元素是否在页面上显示 区别 控制手段不同 v-show隐藏元素时，为该元素添加了display: none，dom元素依旧存在； v-if则是直接添加或删除这个dom 编译过程不同 v-if切换有一个局部编译/卸载的过程，v-show只是基于css切换 编译条件不同 v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销 生命周期不同 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed v-show切换时，不会触发组件的生命周期 性能消耗不同 v-if有更高的切换消耗，v-show有更高的初始渲染消耗（因为不管初始条件是什么，v-show控制的元素都会被渲染） 使用场景不同 非常频繁地切换，使用v-show；条件很少改变，就用v-if ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:6","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"computed和watch computed computed是计算属性的，会根据所依赖的数据动态显示最新的计算结果，该结果将会被缓存起来。当依赖的数据发生改变，才重新调用getter来计算最新的结果。设计初衷是为了使模板中的逻辑运算更简单：复杂的计算逻辑放到computed中去计算 应用场景 重复使用数据或者复杂费时的运算 若需要的数据依赖于其他数据，可以设计为computed中 和methods的区别 computed是响应式的，只有依赖发生改变才重新求值，而methods每次调用都会重新求值，不是响应式的 computed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get/set变成可读写属性, 但是methods中的成员没有这样的 watch watch是一个对data的数据监听回调，当依赖的data的数据变化，会执行回调，回调中会传入newVal和oldVal两个参数 Vue实例会在实例化的时候调用$watch()，遍历watch对象的每一个属性 使用场景 当data中的某个数据变化时，需要做一些操作；或是需要在数据变化时执行异步或者开销大的操作 二者异同 相同点 都是观察页面数据变化的 不同点 computed只有当依赖数据变化时才计算，没变化就直接读取缓存 watch每次都要执行函数，更适合用于数据变化时的异步操作。更多的是起到观察的作用 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:7","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"插槽Slot Slot是Vue的内容分发机制，组件内部的模板引擎使用Slot元素作为承载分发内容的出口 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:8","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"保存当前页面的状态 组件将被卸载的情况 保存在localStorage或者sessionStorage 在组件被销毁前，将当前组件的state通过JSON.stringify()保存下来 优点： 兼容性好 简单快捷 缺点： 状态是通过JSON.stringify()保存的，相当于是深拷贝，如果状态里有特殊情况，比如Date、RegExp等，就会得到字符串而非原来的值 路由传值 组件不会被卸载 单页面渲染 要切换的组件作为子组件全屏渲染，父组件正常储存页面状态 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:9","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Vue3和Vue2的区别 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:10","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"生命周期 beforeCreate：数据观测和初始化事件都没有开始，此时无法访问到data，computed，watch和methods上的数据 created：实例创建完成，但此时渲染的节点还没有挂载到DOM，无法访问$el属性 beforeMount：在挂载前被调用，render函数首次调用。模板编译完成，根据data的数据和模板生成html mounted：用上一步编译好的html来替换el指向的DOM对象，渲染到html页面。此过程中进行ajax交互 beforeUpdate：响应式数据更新时调用，此时虽然数据更新了，但是真实DOM还没有被渲染 updated：DOM已经根据响应式数据的变化更新了。应该避免在此期间更改状态。服务器端渲染期间不可调用 beforeDestroy：销毁前调用，这一步实例仍然完全可用 destroyed：调用后，Vue实例指示的所有东西会被解绑，所有事件监听被移除，所有子实例被销毁。服务器端渲染期间不可调用 对于keep-alive包裹的组件，有独有的生命周期activated和deactivated，切换时不会销毁，而是缓存到内存中 生命周期顺序 加载渲染过程： ​ 1.父组件beforeCreate ​ 2.父组件 created ​ 3.父组件 beforeMount ​ 4.子组件 beforeCreate ​ 5.子组件 created ​ 6.子组件 beforeMount ​ 7.子组件 mounted ​ 8.父组件 mounted 更新过程： 父组件 beforeUpdate 子组件 beforeUpdate 子组件 updated 父组件 updated 销毁过程： 父组件 beforeDestroy 子组件 beforeDestroy 子组件 destroyed 父组件 destoryed 请求异步数据 推荐在created钩子函数中调用异步请求 可以更快地获取到服务端的数据，减少页面加载时间，提升用户体验 SSR不支持beforeMount和mounted钩子函数，放在created中助于一致性 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:11","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"v-for和v-if为什么不应连用 因为v-for的优先级比v-if高，所以如果将v-for和v-if应用在同一个元素上，每次渲染都会先循环，才进行条件判断，浪费大量性能 为避免出现这种情况，在v-for元素外再嵌套一层，在该层应用v-if 如果条件出现在循环内部，可以通过computed提前过滤那些不需要渲染的元素 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:12","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"keep-alive keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们 它可以设置以下属性 include：名称匹配则缓存 exclude：名称匹配则不缓存 max：最多缓存多少组件实例 基本用法 \u003ckeep-alive include=\"a, b\"\u003e \u003ccomponent :is=\"view\"\u003e\u003c/component\u003e \u003c/keep-alive\u003e ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:13","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"vue-router vue-router中的懒加载 方法一，箭头函数+动态import（重点） const List = () =\u003e import('@/components/list.vue') const router = new VueRouter({ routes: [ { path: '/list', component: List } ] }) 方法二，箭头函数+动态require const router = new Router({ routes: [ { path: '/list', component: resolve =\u003e require(['@/components/list'], resolve) } ] }) $route和$router的区别 $route是路由信息对象，包括了path，params，hash，query，name等路由信息参数 $router是路由实例，包括了路由的跳转方法和钩子函数 history模式 使用的是传统的路由分发模式 特点 URL没有#号，更好看 需要后台配置支持，否则可能返回404 会出现在HTTP请求中 原理 hash模式 开发中默认的模式就是hash模式 特点 hash值会出现在URL里面，但不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值不会重载页面 兼容性好，低版本的IE也支持 被称为前端路由，是SPA的标配 原理 监听onhashchange()事件 window.onhashchange = function (event) { console.log(event.oldURL, event.newURL) let hash = location.hash.slice(1) } hash值的变化对应的URL都会被浏览器记录下来，这样浏览器就能够实现页面的前进和后退 replace和push的区别 this.$router.push() 跳转到指定URL，同时向URL栈添加一个新的记录，点击回退会返回上个页面 参数可以是一个字符串路径，或者一个描述地址的对象 this.$router.push('/index') this.$router.push({path: '/index', query: {name: '123'}}) this.$router.replace() 跳转到指定URL，替换history栈中最后一个记录，点击回退会返回至上上个页面 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:14","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"Vuex 是什么 Vuex就是一个专门为Vue应用开发的状态管理模式。 它的核心是store，也就是一个容器，包含着应用中的各种state，它的状态存储是响应式的 action和mutation的区别 mutation的操作，是一系列的同步函数，用来修改state的变量的状态。使用时需要通过commit来提交需要操作的内容。每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)，该回调函数就是实际上进行状态更改的地方，会接受state作为第一个参数 action类似于mutation，但仍有不同点 action可以包含任意的异步操作 action提交的是mutation，action无法直接变更状态 总结二者的区别 mutation专注修改state，是修改state的唯一途径。action处理业务代码和异步请求 视图更新时，先触发action，再触发mutation mutation的参数是state，action则是context，是state的父级 Vuex和localStorage的区别 Vuex储存在内存中，localStorage则以文件形式存储在本地。所以读取vuex中的数据比较快 Vuex用于组件间共享状态，localStorage一般在跨页面传递数据时使用 Vuex是响应式的 刷新时Vuex存储的值会丢失 Vuex和一个单纯的全局对象相比有什么优点 Vuex状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 Vuex限制不能直接改变store中的状态，更方便追踪状态变化 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:9:15","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"关键思想 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:10:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"虚拟DOM 什么是虚拟DOM 本质上来说，虚拟DOM其实就是一个JavaScript对象。将页面抽象成JS对象的形式，使跨平台渲染成为可能，同时还能有效减少页面渲染的次数，减少修改DOM的重绘重排次数 虚拟DOM是对DOM的抽象，是一个更加轻量级的对DOM的描述 为什么要用虚拟DOM 保证性能下限，在不进行手动优化的情况下也提供较好的性能 渲染时： 真实DOM：生成HTML字符串，重建所有DOM元素 虚拟DOM：生成vNode + Diff + 必要的DOM更新 跨平台 本质就是JS对象，可以很方便地跨平台操作，比如服务端渲染等 虚拟DOM性能 首次渲染大量DOM时，因为多了一层虚拟DOM的计算，会比较慢 只是保证了性能下限，如果对真实DOM操作注意优化，真实DOM性能上限更高 Diff算法原理 首先对比节点本身，判断是否为同一节点，如果不同，删除并创建新节点替换 如果是相同节点，进行patchVNode，判断怎么处理这个节点的子节点 如果新的没有子节点，旧的有，就直接移除 如果都有，就进行updateChildren，判断如何对他们的子节点操作 匹配时找到相同子节点就递归比较子节点 只对同层的子节点进行比较而放弃了跨级的比较 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:10:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"AJAX AJAX的全称，是Asynchronous JavaScript and XML，指的是通过JavaScript的异步通信，从服务器获取XML文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页 创建AJAX请求 创建一个XMLHttpRequest对象 在该对象上使用open方法创建一个HTTP请求，所需参数有请求方法、请求地址、是否异步以及认证信息 发送请求前，可以为这个对象添加一些信息以及监听函数 对象的属性和监听函数设置完成后，最后调用sent方法发送请求 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:10:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"性能优化 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:11:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"图片懒加载 方法一 拿到所有的图片DOM 遍历判断是否在可视区域内 若是，则设置图片的src属性 绑定window的scroll事件，对其进行监听（需要节流来控制scroll） 方法二 有一个新的API，IntersectionObserver，可以自动观察元素是否可见，即交叉观察器 var io = new IntersectionObserver(callback, option) // 开始观察 io.observe(document.getElementById('example')) // 停止观察 io.unobserve(element) // 关闭观察器 io.disconnect() ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:11:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"分包加载 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:11:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"其他 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:12:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"前端新技术的了解 Web3.0 WebGL Serverless Three.js 微前端 Typescript NodeJS 移动端 Flutter 元宇宙 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:12:1","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"最近在研究的东西 想学Flutter 区块链相关 聊天室 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:12:2","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面试"],"content":"自我介绍 面试官好，我是夏宇航，福建泉州人，来自浙江大学信息与电子工程学院，现在在读大三。 我的专业是信息工程，学校并不会教授前端方面的相关课程。我是从去年七月开始系统性地自学前端的，学习途径主要就是看网络上的教学视频，阅读一些技术书籍，以及自己写一些小项目来巩固学到的知识。比如简单的todolist和音乐播放器 除此之外，我还有过微信小游戏的开发经历，当时是和朋友五人组队参加了腾讯举办的高校小程序开发大赛，我们的小游戏Greenet获得了全国二等奖，期间开发、看着自己的程序一点点完善地展现出来的乐趣和成就感，也是我决定走上前端之路的主要原因之一 实习经历的话，大三上学期时有过一段在有赞的实习，是在资产前端部门，做的工作是维护内部平台以及内部工具的开发，实习期间感觉得到了很多锻炼和提升，希望在下一段实习也能在提升、充实自己的同时，做一些有趣有意义的工作 以上就是我的自我介绍 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/:13:0","tags":["知识点"],"title":"备战暑期实习","uri":"https://MichaelYuhe.github.io/%E5%A4%87%E6%88%98%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"},{"categories":["面经"],"content":"网易雷火二面 项目 实习干了啥，怎么做的 略 怎么想到做微信小游戏 难点 讲了3d和零基础 音乐播放器的后端怎么做的 现成的.. 原生音视频控制方法知道哪些 play和pause哈哈哈 技术 跨域 扯了很久 vue-router 两种模式的区别 哪种不会发请求 用原生的哪个东西监听变化 replace和push 对前沿技术的了解 web3，flutter，区块链 CSS动画 兼容性怎么解决 前缀 自己最近在研究啥 说了寒假的聊天室，说了区块链，说了Flutter 为什么去研究区块链 因为很热门很赚钱 Git讲讲 基本流程 tag 钩子 自动校验commit规范 其他 实习时间 日常随时去，一周四天 暑期六月考完可以去，全勤 来实习想做啥；为什么 不想做内部工具，想做产品做游戏 因为比较有意思 反问 建议 打好基础，比如vue底层原理 根据兴趣自由发展 部门做什么 各个游戏的前端部分 游戏助手app 天音（有意思 h5小游戏 微信小游戏 总结 总流程30分钟 虽然技术一些细的东西没答上来，但面试官好像都很理解，也没有刁难，体验很好 ","date":"2022-02-21","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E4%BA%8C%E9%9D%A2/:0:1","tags":["面试"],"title":"网易雷火前端实习_二面","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"网易雷火一面 自我介绍 移动端自适应 小游戏性能优化 分包加载预加载 模型怎么优化 cocos内部怎么自适应，原理 webpack CSS动画 垂直居中，水平居中 this指向 构造函数的this 箭头函数的this 箭头函数和普通函数的区别 可不可以构造函数，为什么 this arguments Promise setTimeout 宏任务微任务 事件循环 为什么不可以完全精确到1ms vue双向数据绑定 详细讲讲vue干了啥 vue3的区别 defineProperty具体做了啥，怎么做的 数据库连接 用的什么库，什么框架 博客 md怎么转html 用什么打包的 反问 部门主要做什么工作 游戏官网和活动页面制作 内部前端工程化 小游戏开发 ","date":"2022-02-14","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"网易雷火前端实习_一面","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"阿里云OpenAPI一面 绩点，排名，相关课程 面试官：你们绩点也太高了，这才百分三十几吗 自我介绍，要求介绍自己的优势 说自己学习能力强，上手快 简单介绍一下各种排序 名称和复杂度就可以了 详细介绍快排 时间复杂度的情况，时间复杂度和什么有关 数组的各种方法 slice和splice 哪些改变原数组 尽可能多说 React的hooks 说自己只用过useState和useEffect Node.js 用什么框架，文件操作用过吗 算法 两题都是快慢指针，秒了 DFS和BFS 数据结构 区别 用途 填充颜色用哪个 Flex布局讲一下 居中 space-between和space-around的区别 COCOS架构 。。。 小游戏亮点 讲了环保理念 反问 做的是IT自动化，开放api的整个生命周期的管理 对我有什么建议 “整体面下来，在大家的横向比较中，你的前端经验算是比较丰富的，也比较有逻辑性” “需要有一棵属于自己的前端知识树，查缺补漏” ","date":"2022-02-14","objectID":"https://MichaelYuhe.github.io/%E9%98%BF%E9%87%8C%E4%BA%91openapi%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"阿里云OPENAPI前端实习_一面","uri":"https://MichaelYuhe.github.io/%E9%98%BF%E9%87%8C%E4%BA%91openapi%E4%B8%80%E9%9D%A2/"},{"categories":["生活"],"content":"实习总结 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:0","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"写在前面 11.16进入入职，1.15离职，不算考试周，刚好凑足了两个月。交完电脑工牌，签了离职文件，最后和大家合照，就正式离开这第一个收留我的公司，离开两个月间朝夕相处的大家。 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:1","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"实习干了什么 两个月时间，做的工作有限。 支付运营平台搜索体验优化。 本来的搜索体验很差，UI也挺离谱。入职第二天就接需求优化这个体验。把搜索改为了全局聚焦搜索框，增加了快捷键，美观、快捷，顺便修复了一点遗留的bug。 小猫咪组件升级 小猫咪用的还是好几年前的zent6，需要把组件库升级到zent9。跨越了三个大版本，有一些破坏性的改动，“牵一发而动全身”，升级组件不像自己想象的那么简单。比如filter、selector等涉及到数据的组件，组件库升级过程中需要把原来定义的数据结构、函数也做相应的修改。对没有学过react和typescript的我是一个挺大的挑战。 对接V2应用日志 简单地换个接口，换套参数，加上token来对接V2天网。然后根据天网的搜索来改进前端的输入和体验 后端应用日志治理 这个任务花费了最长的时间。本来小猫咪只支持前端应用的日志治理。首先说后端部分。后端部分，需要每天自动获取一次token，然后携带token发送请求，获取对应应用的天网日志。拿到天网日志以后，对日志进行治理，根据前端所设定的规则来匹配，匹配到得则数量累加，若有日志没有匹配到则计入unknown。统计完成后，存入线上的数据库，同时还需要支持对这些日志的状态的管理。前端部分的话，最主要的就是在增添机器人配置时，支持用户自定义配置一些规则，规则用正则匹配，如果是tag则使用对象相等的方法，用户可以拖拽改变规则的优先级。 机器人自动通知错误信息 治理完了日志，还是不够完美：想看错误信息一样要自己登录小猫咪去看。为了解决这个问题，在配置机器人时可选填入机器人url，支持飞书机器人和企业微信机器人，利用飞书和企业微信的api，将每日报错的信息统计，在次日九点发送到对应的群组，方便大家应用日志治理。 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:2","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"思考 实习期间，除了coding这种基础能力的提升，最主要的还是接触到了生产环境的工作流程，有许多的思考。 扩展性。写出的程序应该具有扩展性，不能只是局限于眼前的功能，还要考虑到程序的扩展性，是否能只是单纯地修改几个参数就能扩展到其他应用，解决其他需要求？ 低耦合性。大型的应用，数据往往很多很杂，一处改动可能会影响到很多地方。写代码时要注意尽量保持低耦合。 多人协作。首先，需要保持良好的注释习惯。大型应用不可能一个人独立开发，退一万步，离职了也有人会来接受，良好的注释习惯就能帮助其他人阅读自己的代码。接手的都是0注释的代码，给我整蒙了。其次，规范commit。不要乱提commit，方便回溯。 先确定需求再写代码，可以省下许多无用功，提高效率。 ","date":"2022-01-15","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/:1:3","tags":["实习","生活"],"title":"实习总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"实习一月小结 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:0","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"写在前面 抱着试试看＋练习面试的想法，冲刺了几天面经，参与了几家公司的面试。只能说基础太不扎实了，许多js的基本问题都不能回答出来。 最后，经过三轮技术面＋HR面，拿到了人生第一份offer——有赞前端实习生。对于这个offer还是很满意的~ 毕竟学习前端算上来也就三个多月，再者有赞的前端实力还是很强的，于是就接受了这个offer（虽然钱少了点，200 + 50饭补） 11.16，正式入职有赞。开启了一段全新的旅程。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:1","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"入职体验 入职第一天，大家就一起出去吃了顿饭，介绍了一下自己，也初步认识了大家。大家给我的第一印象都很好，热情、随和，让我消去了刚入职的迷茫和些许焦虑、慌张。组里除了我还有两个实习生，小有和小赞😂 第一天，领取了Macbook Pro；第二天，领取了显示器；真香！不得不说，显示器的体验实在太好了~ 至于mac和windows，见仁见智，我还是比较喜欢windows。 第一天配置好了环境，本以为接下来的几天就是让我自己熟悉代码摸索摸索，没想到直接来了一个小需求😂 —— 支付运营平台的搜索样式优化。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:2","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"第一个任务 从gitLab拉来代码，庞大的代码量让人头疼，React，TypeScript，不好意思没有学过；还有闻所未闻的njk等东西，定位代码就花了一小段时间，需要改的代码都在njk模板里。 还好，需求本身并不难。在前人代码的基础上进行一些小的修改和优化即可。代码古老，用的还是JavaScript直接操作DOM的方法。也好，给没学过React和TypeScript的我一些缓冲时间。 一顿操作猛如虎，当天下午就做好了初版。虽然只是初版，但可能是为了让我熟悉熟悉发布流程，有伴直接教我如何发布自己刚刚的修改。不得不说，这一套发布流程还是蛮复杂的。单是搞懂各种环境的区别、ZanProxy的配置、各种平台的使用、Code Review、Merge Request等等等等。一个月的工作过后，现在可以说从Git小白变成已经掌握了Git的各种常见操作，也可以利用Git来进行协作开发。合过分支、解决过冲突…… 自测没发现什么问题，直接提交发布单发布到了生产环境。结果因为快捷键设置得不合理，刚发布没多久就有人在群里提出了问题。回滚。再提交，又有问题。回滚。 这么简单的东西，回滚了两次😂 最后自己认真地重新修改了一下，也删除了冗余代码，修复了一个前人遗留的bug，样式也做了更细节的优化，如圆角和颜色等，经过各页面详细的自测，再提交发布单，终于没有问题，也得到了比较好的反馈。 简单总结一下，第一个任务没有什么技术上的难度，但是收获了一些经验和教训。比如，在这种已经维护了好几年的大型项目中修改或者增加功能时，不能只看到自己的那一部分，牵一发而动全身，需要考虑到已有的代码和逻辑。再就是不能像自己搞项目一样随意提交代码，毕竟做的东西是给许多人使用的，稍有不慎就会影响到很多人的体验。 任务中学到的CSS小技巧： 当Icon库里没有你想要的图标、公司又不允许引用外部样式时，就需要自己网上搜寻或制作一个PNG图标，放到图床上使用。而本次任务中的搜索图标就是这种形式来引用的。但当搜索激活时，要求有图标从灰色变成白色的效果，难道我要传两张PNG图标，一灰一白？这不合理，而且这样无法达到完美的过渡效果，灰色直接切到白色会比较生硬。其实可以通过CSS来直接改变PNG图片的颜色。 filter: brightness(90); brightness的数值设置为100，亮度调到最高，自然就是白色；设成0，就是黑色。原理就不在此细讲了，贴个链接。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:3","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"第二个任务 接下来接的任务就是和小猫咪平台有关的。小猫咪是我们部门开发的一个机器人，可以抓取日志，提醒相应负责人，也可以设置值班顺序，在企业微信群里自动艾特并通知对应人员……是一个功能比较完善了的机器人，现在公司希望我们将其做成可自定义配置的，让所有部门都可以很方便的接入使用。 目前小猫咪只能读取天网V1的日志，然而日志已经在全面迁移到V2，2022年将不再维护V1的日志，这个功能再不改就会失效。 于是接到了一个需求：让小猫咪接入天网V2的日志系统。 要解决一个需求，需要先调研这个需求能否完成。找到对应负责人，加了天网服务群，天网API群等等，调研结果是小猫咪有能力实时获得天网日志，但数量庞大，无法存储在自身数据库。 接下来就是实现获取天网V2的日志。实现也很简单，就是一个基础的网络请求，拿到的数据做一定的解析即可。 说来惭愧，这竟是我第一次做ajax网络请求…… 好在功能很快就顺利完成了。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:4","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"第三个任务 接下来的任务就比较困难了一点：给小猫咪全面升级zent9。zent是有赞自己研发的React组件库，小猫咪是三年前开发的，使用的还是zent6，现在需要进行升级。 然而升级组件库并没有想象中的简单。对于那些只改变了样式的组件，比如按钮、提示框等等，一键升级就完事。 但对于一些“破坏性升级”的组件，就比较麻烦。例如，zent9重写了各个选择器，如基本的select，还有时间选择器DatePicker等一系列衍生组件。由于重写组件，内部逻辑被改变了，数据接口和返回的数据都得做相应更改。加上全面TS化，有更严格的类型检查，从没接触过TS的我，最开始是真的一脸懵逼。花大半天时间，学习了解了TypeScript，就开始着手进行升级。 升级过程中，也对React的单向数据流有了更深的理解。（以前好像也理解过 三天时间，和另一位实习生，也是大三，两个人合作全面升级了小猫咪的zent版本，顺带还升级了各种依赖和TS的版本，对一些样式也做了优化。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:5","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"满月 不知不觉，写了四次周报了。也意味着在有赞已经实习满一个月了。 一个月以来，似乎也没干什么活，主要还是在熟悉代码熟悉流程，带薪学习React和TS😂 最主要的感受：我一定要找955的大外企😂 在有赞，每周三五是六点下班，其他都是九点下班；早上十点前到就可以，晚一点也没事；中午也有午休时间。实际工作时长确实不多，但有一种公司把自己拴住了的感觉。九点下班以后，也很难再有自己的生活。 可能是现在比较累吧。又要实习，又要兼顾学校的课程。要是正式工作了，可能周末就可以好好放松，而不是像现在，周末恶补学校课程和作业…… 没时间学英语，没时间刷Leetcode，不禁怀疑自己做出了错误的选择。想出国，或是进外企，除了前端的技术能力，一样很看重英语和算法能力。而这两个能力自己都比较缺乏。 同时，没有时间做自己的项目。以前没有实习时，虽然比较没有方向比较迷茫，但可以自由学习各种知识，想做什么就去做什么。现在了解了更多新的技术，例如区块链，也有许多项目想法，但都没有时间去做。还想学吉他，想学投资，想好好享受校园生活，想天天练球，想旅游，想学摄影，想学英语…… 下学期是否还要实习，需要好好思考一下了。 是珍惜校园时光，自由地学习；还是继续实习，为简历增色，便于找到更好的工作…… 得好好思考一下自己真正想要的东西了。 先赶大作业去了。 ","date":"2021-12-09","objectID":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/:1:6","tags":["实习","生活"],"title":"实习一月总结","uri":"https://MichaelYuhe.github.io/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"},{"categories":["面经"],"content":"滴滴日常实习一面 10月30日 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"自我介绍 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:1","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"项目 小游戏的难点，做了些什么，登陆相关 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:2","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"CSS 盒模型 怎么居中，尽可能多方法 flex布局讲一下 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:3","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Javascript reduce用过吗 数组的map和forEach的区别 数据类型和判断方法，typeof和instanceof的区别 打乱一个数组 var、let、const ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:4","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Vue 双向绑定原理，具体到源码 组件通信方式 data为什么是函数不是对象 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:5","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"总结 一些简单的问题都没答好，感觉面试官已经放了点水了，但没想到我仍是没答对。以及简历的“阅读过Vue部分源码就是在给自己挖坑” 面试官建议：项目经验已经足够了，现在需要巩固基础和做一些单纯技术导向的项目，努力在一个项目用到尽可能多的东西。 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:6","tags":["面试"],"title":"滴滴日常实习_一面","uri":"https://MichaelYuhe.github.io/%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"有赞日常实习二面 11月4号 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:0","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"自我介绍 然后问了专业相关，聊到下学期才上计网，于是“那我计网只问你一些基础的吧” ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:1","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"计算机网络 讲一下HTTP，讲一下和HTTPS的区别 DNS查询 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:2","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"JavaScript this相关，问的很细，很久，比如什么时候会导致this传错了，然后出了一些例题等等，还出了会报莫名其妙错的例题 数据类型，判断方法，问的很细，很久，比如改写toString，比如中途改变原型链 讲一下数字精度丢失，那我们怎么让0.1 + 0.2 === 0.3 异步的理解，async和await，底层原理，还有什么是异步的，引到并发并行，单线程，事件循环 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:3","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"Vue 对比传统开发有什么好处 讲一下双向绑定，讲一下双向绑定的缺点 操作真实DOM和虚拟DOM哪个快，为什么，数据量大时呢，数据量小时呢，不涉及重排重绘时呢，为什么呢 挂载发生了什么 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:4","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"项目 怎么和后端API交互的 todo实现了些什么 微信小游戏和其他前端项目的区别，登录怎么做的 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:5","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"HTML5 新特性 异步加载 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:6","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"其他 遇到不明报错该怎么做（搜索…） ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:7","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"反问 去做什么：他们部门是支付收银相关，但风险大的工作不会给实习生，去是做一些公司内部看的数据平台 学习建议：买书看，自己实习的时候可以边做项目，实现一些想法 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/:1:8","tags":["面试"],"title":"有赞前端实习_二面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%BA%8C%E9%9D%A2/"},{"categories":["面经"],"content":"有赞日常实习一面 11月2日 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:0","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"线上笔试 直播写代码 网站：showMeTheCode，有赞自己的平台 1、字符串相加 忘记处理最后一步的进位 /** * 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和 * * tips: 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 * * 示例输入: '197880986', '5112281222' * 示例输出: '5310162208' * */ var addStrings = function (num1, num2) { // code here let len1 = num1.length, len2 = num2.length let carry = 0, sum = 0 let res = [] while (len1 || len2) { if (len1 \u0026\u0026 len2) { sum = parseInt(num1[--len1]) + parseInt(num2[--len2]) + carry } else if (len1) { sum = carry + parseInt(num1[--len1]) } else { sum = carry + parseInt(num2[--len2]) } carry = 0 res.unshift(sum % 10) if (sum \u003e= 10) { carry = 1 } } return res.join('') }; console.log('result --\u003e ' + addStrings('197880986', '5112281222')); console.log('want ----\u003e ' + '5310162208'); console.log('[equal] -\u003e ' + (addStrings('197880986', '5112281222') === '5310162208')); 2、两个对象快速相等 /** * fastEqual 两个对象快速相等 * * 示例输入: a = { arr: [1, 2], num: 12 } b = { arr: [1, 2], num: 12 } * * 示例输出: true * * tips: 不需要考虑太多边界情况, 优先保证执行效率, 输入 a / b 可以是任意数据类型 */ function fastEqual(obj1, obj2) { // code here var o1 = obj1 instanceof Object; var o2 = obj2 instanceof Object; // 两个简单的判断 if (!o1 || !o2){ return obj1 === obj2 } if(Object.keys(obj1).length !== Object.keys(obj2).length){ return false; } // 循环看属性 for(var o in obj1){ var t1 = obj1[o] instanceof Object; var t2 = obj2[o] instanceof Object; // 如果都还是对象 if(t1\u0026\u0026t2){ if(!fastEqual(obj1[o],obj2[o])) { return false } } else if(obj1[o] !== obj2[o]){ return false; } } return true; } 3、解析URL 没有解码，callback输出错误 /** * 解析 URL 中的 Query String，返回一个对象 */ // 返回值示例： // { // name: 'coder', // age: '20'. // callback: 'https://youzan.com?name=test' // } const testURL = 'https://www.youzan.com?name=coder\u0026age=20\u0026callback=https%3A%2F%2Fyouzan.com%3Fname%3Dtest'; function parseQueryString(url) { // code here let res = {} // 分割 if (url.indexOf('?') === -1) { return res } let query = url.split('?')[1].split('\u0026') query.forEach((item) =\u003e { let temp = item.split('=') // 解码 res[temp[0]] = decodeURIComponent(temp[1]) }) return res; } console.log(\"====== QueryString Parser ======\") console.log(\"should --\u003e \" + JSON.stringify({ name: 'coder', age: '20', callback: 'https://youzan.com?name=test' })); console.log(\"[result] --\u003e \" + JSON.stringify(parseQueryString(testURL))); 总结：三道题都大概做出来了，但是都不完美 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:1","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"计算机网络 XSS、CSRF 讲讲非简单请求和简单请求 // 简单请求：同时满足两个条件 // 请求头是 HEAD,POST,GET（讲漏了POST） // 头信息不超出 Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain // 非简单请求的CORS请求，会在通信之前增加一个预检请求 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:2","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"浏览器 跨域，具体用过哪些，上线了还可以devServer吗 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:3","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Vue computed和watch的区别 vue-router的模式 ，底层原理 生命周期（父子组件间） ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:4","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"CSS position各种属性及其特点 居中 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:5","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"Javascript 基本数据类型有哪几种 ，Symbol的具体作用 怎么判断是不是数组 // 答出来的 Object.prototype.toString.call(arr) Array.isArray(arr) arr instanceof Array // 其他的方法 arr.__proto__ === Array.prototype arr.constructor === Array async、await讲一下，和forEach连用会发生什么 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:6","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"其他 为什么选择前端 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:7","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["面经"],"content":"面试官的建议 学习网络相关的知识，包括网络安全 ","date":"2021-11-05","objectID":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/:1:8","tags":["面试"],"title":"有赞前端实习_一面","uri":"https://MichaelYuhe.github.io/%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0_%E4%B8%80%E9%9D%A2/"},{"categories":["计算机网络"],"content":"Web前端安全之XSS和CSRF ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:0","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"写在前面 昨晚（2021 / 11 / 2），面试有赞实习，面试官提问了XSS和CSRF，从没了解过的我只能尴尬地回答：“不好意思，我没有了解过相关的知识”。那么什么是XSS和CSRF，今天就必须给他搞懂了！ ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:1","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"XSS XSS是什么 跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。XSS 在 2017 年被认为 7 种最常见的 Web 应用程序漏洞之一。这种攻击的主要目的是窃取其他用户的身份数据——cookie、会话令牌和其他信息。在大多数情况下，这种攻击是用来窃取其他人的 cookie。 大多数情况下，这种攻击是通过 Javascript 和 HTML 完成的。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 XSS攻击的类型 存储型 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 DOM型 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 如何防范XSS 现在，我们已经了解了XSS攻击的两大要素 攻击者提交恶意代码 浏览器执行恶意代码 我们就可以针对这两大要素进行防护 输入过滤 输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。但对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。 预防存储型和反射型 存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。对此有两种解决方案 纯前端渲染 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 HTML转义 使用转义库，在不同的上下文里应用不同的转义规则。 预防DOM型 DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，\u003ca\u003e 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，一定要避免在字符串中拼接不可靠数据 其他通用措施 Content Security Policy 输入内容长度控制 禁止JavaScript读取cookie 验证码，防止脚本模拟用户 如何检测XSS 使用通用 XSS 攻击字符串手动检测 XSS 漏洞。 使用扫描工具自动检测 XSS 漏洞。 总结 很难通过技术手段完全避免XSS攻击，但要遵守以下原则来避免漏洞的产生 利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 \u003c%= data %\u003e 而不是 \u003c%- data %\u003e； 在 doT.js 中，尽量使用 {{! data }} 而不是 {{= data }}； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。 避免内联事件 尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。 ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:2","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"CSRF 什么是CSRF CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 CSEF攻击的类型 GET类型 POST类型 链接类型 如何防范CSRF CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 我们已经了解到： CSRF（通常）发生在第三方域名。 CSRF攻击者不能获取到Cookie等信息，只是使用。 我们可以针对这两点来制定防护策略： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重Cookie验证 总结 CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。 CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。 保证页面的幂等性，后端接口不要在GET页面中做用户操作。 ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:3","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["计算机网络"],"content":"附录 一个有趣的练习XSS攻击的网站 ","date":"2021-11-03","objectID":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/:1:4","tags":["网络安全"],"title":"Web前端安全之XSS和CSRF","uri":"https://MichaelYuhe.github.io/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"categories":["知识点"],"content":"面试专用 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:0","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Web前端面试——面试官系列 简介 为语音打卡社群(JS每日一题)维护的前端面试题库，包含不限于Vue面试题，React面试题，JS面试题，HTTP面试题，工程化面试题，CSS面试题，算法面试题，大厂面试题，高频面试题 特点 资源很全，囊括了各个方面的知识点 阅读体验良好 语言通俗易懂 但会有一些小错误，需要自己注意 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:1","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"前端面试2021及答案 简介 个人按专题整理的面试题，均附上了答案和重要指数 特点 给每一项都进行了重要程度的评级 缺点是有些知识点讲的不够详细，但都会附上一些更详细的链接 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:2","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"前端面试真题 简介 一个介绍面试真题和经验的飞书文档 特点 以飞书文档的形式整理，可以管理个人进度 分模块、分题集 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:1:3","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"技术博客 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:2:0","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"冴羽的个人博客 ⭐ 简介 大佬的个人博客，包含四个系列，JavaScript深入系列、JavaScript专题系列、ES6系列、React系列。 特点 语言精练严谨 Javascript深入系列yyds 大佬人很好，会回答留言里的问题 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:2:1","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"阮一峰的网络日志 简介 ES6入门教程的作者，阮一峰大佬的个人博客，十分经典，除了有一些知识的讲解，也有许多好的分享 特点 能把知识点描述得通俗易懂且全面 现在在做科技爱好者周刊，每周五推送值得分享的科技内容 可以去看他开源的《ECMAScript6入门》作为ES6的入门学习资料 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:2:2","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"CSS \u0026 UI ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:0","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Uigradients 获取渐变色代码，提高背景逼格专用！ ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:1","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"CSSBattle 使用尽量简洁优美的CSS来完成任务！ ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:2","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"dribbble 一个汇聚许多优美的web设计的网站，独立开发时的UI灵感来源。 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:3","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Neumorphism 自动生成优雅的CSS代码，可以手动调节大小、圆角等参数。 Dunmmyimage 生成占位图。 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:4","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["知识点"],"content":"Navnav+ 许多优秀精美的CSS小组件 ","date":"2021-10-29","objectID":"https://MichaelYuhe.github.io/resources/:3:5","tags":["面试"],"title":"那些好用的前端学习网站/文档/博客","uri":"https://MichaelYuhe.github.io/resources/"},{"categories":["Program"],"content":"Node.js初体验 — nodemailer的使用 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:0","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"写在前面 需求：给自己的todo应用添加一个邮件提醒的功能，当创建了任务则会发送邮件至指定邮箱 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:1","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"历程 作为一个Node.js小白，其他网络的知识也几乎没接触过，踩了许多的坑。 首先，经网上查找，找到了nodemailer这个库，兴致勃勃地下载，根据官方文档配置使用，在本地node环境中成功发送了测试邮件。 但当我把它放到我基于vue框架的todo应用中时，运行却报错了。nodemailer**仅可以在node环境中使用！**也就意味着项目需要前后端分离，并且需要前端与后端的交互。 没错，就是这个问题，一个简单的前后端交互困扰了我一整天。 最开始，自信满满的我，由于想把自己的项目都部署上线，本就有购买服务器的想法，直接去腾讯云购买了一个轻量应用服务器。将服务器配置了Node.js的应用镜像，将之前在本地node环境中运行的代码部署在服务器上直接运行，成功发送邮件至指定邮箱。 接着，就是分析逻辑：我要做的事情，无非就是向服务器上传邮件具体内容到服务器，同时发起发送邮件的请求，达到前端填写内容，按下发送按钮，服务端即可发送邮件的效果。 要能够向服务器发起请求，显然首先要能够访问到该服务器。在vue中引入了axios（没错这也是我第一次使用它），向服务器发起一个简单的get请求，结果却抛出了错误 has been blocked by CORS policy。 这是由于请求是跨域进行的。跨域的原因和解决方案后续将在另一篇文章知识点总结中提到，此处仅关注这个需求。 Vue就自带了一个使用代理来解决跨域的方案。代理的作用：监测本地的接口，当接口为需要访问外网的接口时，代理替你访问这个接口并把返回值返回给当前网页 为方便测试，在本地起了一个node服务。 // app.js const express = require('express'); const app = express(); const email = require('./email'); app.get('/', (req, res) =\u003e { res.send('Hello') }) app.use('/email', email); // 监听端口3000 app.listen(3000, () =\u003e console.log('Service start at port 3000...')) // email.js const express = require('express'); const email = express.Router(); // 创建express路由 const nodemailer = require('nodemailer'); // 导入nodemailer const transporter = nodemailer.createTransport({ // 以qq邮箱为例 service: 'QQ', port: 465, secureConnection: true, auth: { user: '2312744987@qq.com', pass: '自行获取（SMTP授权码，而非邮箱密码）', } }); email.get('/', (req, res) =\u003e { const { to, html, subject } = req.query; // 将请求解构 const from = '\"XYH\"\u003c2312744987@qq.com\u003e'; const mailOptions = { from, to, subject, html, }; transporter.sendMail(mailOptions, (error, info) =\u003e { if (error) return console.log(error); console.log(info); }); }); module.exports = email; 在终端中输入命令 node app.js，即可在本地主机的3000端口启动服务。 那么在Vue中，如何配置代理呢？ 来到我们项目中的vue.config.js文件，添加以下代码。 devServer: { proxy: { 'test': { target: 'http://localhost:4000', changeOrigin: true, logLevel: 'debug', pathRewrite: {'^/test' : '/'} } } }, 那么当我们访问/api/xxxx接口时，webpack会识别到它是对外的接口，并访问target，将结果返回。接下来编写请求代码。 axios({ url: \"test/email\", method: \"get\", params: { to: \"xiayuhang1106@gmail.com\", subject: \"A New Task\", html: `\u003ch2\u003e${this.title}\u003c/h2\u003e \u003cp\u003econtent\u003cp/\u003e`, }, }) .then((res) =\u003e console.log(res)) .catch((err) =\u003e console.log(err)); 上述代码发送了一个携带参数的axios请求，请求发送至配置好的代理端口的email中，请求发送电子邮件。 点击发送后，服务端打印出邮件信息，代表发送成功。 查看我们的邮箱，也可以看到该新到达的热乎的邮件。 下一步，就是在服务器端复现这个功能，省去每次都需要自己在本地启动服务的步骤。 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:2","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"结语 这是第一次真正意义上的接触Node.js，前前后后摸索了一天半，也学习到了很多知识：跨域、Linux基本操作、服务器部署、axios等。最后也成功实现了发送邮件的功能，虽然不太实用，后期需要想办法修改为定时发送的服务，到了设定时间前一天再发送邮件提醒。 不得不感慨真的是学无止境呀。还有许多东西需要自己去慢慢学习。 ","date":"2021-10-27","objectID":"https://MichaelYuhe.github.io/email/:1:3","tags":["Node.js"],"title":"Node.js初体验","uri":"https://MichaelYuhe.github.io/email/"},{"categories":["Program"],"content":"年轻人的第一个项目 Vusic ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:0","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"项目简介 Vusic是一个使用Vue3作为框架的在线音乐播放器，目前仅适配了移动端，桌面版的适配工作正在进行中。后端采用QQ音乐API来获取歌曲等数据。 以下是Vusic各界面截图及功能介绍。 播放界面 【待补充】 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:1","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"开发中学到了什么 Composition API的使用 Vue3中新增了Composition API，代替之前的Options API，在逻辑、功能较多时，能使代码更简洁，有效降低耦合度，实现同一功能的代码分离到单独的文件，通过setup()调用以及返回到模板中，不需要再把所有data、所有methods等等都挤在同一个文件中。 代码复用和模块化的思想 当有一段代码需要用到多次，不应该复制粘贴，而是需要学会将其封装起来，以方便复用。 要将大的项目模块化，更有助于我们的开发。在进行项目的开发之前，根据设计图和设计框架进行分析抽象，通过对结构和功能的划分来划分出具体的相应的模块。 学会封装一些基础的组件作为基本的模块，其他组件可能就只需要由已经封装好的基础组件拼装而成，不需要重新编写界面和逻辑。就如本项目中的音乐列表界面，可以从排行榜、歌手详情、推荐歌单等等进入，皆是他们的子路由，封装成基础组件，就减少了许多重复的工作。 而同一模块的代码和文件应该统一存放在一个文件夹中，方便代码的管理。 Sass的使用 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库有助于更好地组织管理样式文件，以及更高效地开发项目。 后端接口的使用及数据的处理 后端数据由QQ音乐API获取 // 对 axios get 请求的封装 function get(url, params) { return axios.get(url, { headers: { referer: 'https://y.qq.com/', origin: 'https://y.qq.com/' }, params: Object.assign({}, commonParams, params) }) } // 对 axios post 请求的封装 function post(url, params) { return axios.post(url, params, { headers: { referer: 'https://y.qq.com/', origin: 'https://y.qq.com/', 'Content-Type': 'application/x-www-form-urlencoded' } }) } 性能优化 keep-alive 使用Vue的keep-alive，缓存访问过的路由，有效地避免切换路由时重复多余的网络请求。 \u003crouter-view v-slot=\"{ Component }\"\u003e \u003ckeep-alive\u003e \u003ccomponent :is=\"Component\"/\u003e \u003c/keep-alive\u003e \u003c/router-view\u003e 异步加载路由组件 用工厂模式导入路由组件，使路由组件达到按需加载的效果。 const Singer = () =\u003e import('@/views/Singer'/* webpackChunkName: \"singer\" */) 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令 本项目中，创建了三个自定义指令。v-lazy和v-loading和v-no-result 注册指令： 使用Vue.directive('command name')来全局注册指令 钩子函数 一个指令定义对象可以提供以下几个钩子函数 bind：只调用一次，在指令第一次绑定到元素时调用 inserted：被绑定元素插入父节点时调用 update：所在组件的VNode更新时调用 componentUpdated：指令所在组件的VNode和其子VNode全部更新后调用 unbind：只调用一次，解绑时调用 钩子函数参数 el：指令所绑定的元素，可以用它来操作DOM binding：一个包含传递给钩子的参数的对象。有许多可用的参数，包括name，value，oldValue，expression，arg和modifiers。 vnode：Vue编译生成的虚拟节点 oldVnode：上一个虚拟节点 自定义指令实例： 以本项目中自定义组件为例。由于几个自定义指令的逻辑大体相同，将其封装为createLoadingLikeDirective文件。 // 创造自定义指令 export default function createLoadingLikeDirective(Comp) { return { mounted(el, binding) { const app = createApp(Comp) const instance = app.mount(document.createElement('div')) const name = Comp.name if (!el[name]) { el[name] = {} } el[name].instance = instance const title = binding.arg if (typeof title !== 'undefined') { instance.setTitle(title) } if (binding.value) { append(el) } }, updated(el, binding) { const title = binding.arg const name = Comp.name if (typeof title !== 'undefined') { el[name].instance.setTitle(title) } if (binding.value !== binding.oldValue) { binding.value ? append(el) : remove(el) } } } function append(el) { const name = Comp.name const style = getComputedStyle(el) if (['absolute', 'fixed', 'relative'].indexOf(style.position) === -1) { appendClass(el, relativeCls) } el.appendChild(el[name].instance.$el) } function remove(el) { const name = Comp.name removeClass(el, relativeCls) el.removeChild(el[name].instance.$el) } } ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:2","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"开发中的难点 【待补充】 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:3","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"todos 支持创建歌单 Material you设计 主题的切换 自动取色功能 ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:4","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["Program"],"content":"下一阶段该做的事情 开发新的项目。项目选题：Material Vue（Vue项目样式改变的组件）/ 自定义生成头像的网站 / 记账工具； 学习计算机网络的知识 深入学习JavaScript ","date":"2021-10-20","objectID":"https://MichaelYuhe.github.io/vusic/:1:5","tags":["Vue"],"title":"Vusic","uri":"https://MichaelYuhe.github.io/vusic/"},{"categories":["知识点"],"content":"知识点总结 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:0:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"Javascript ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下闭包 闭包的定义 闭包是指那些能够访问自由变量的函数。 那么什么是自由变量？自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 可以看出，闭包 = 函数 + 函数能够访问的自由变量 所以，从技术的角度讲，所有的JavaScript函数都是闭包。 从实际出发： 即使创建它的执行上下文已经被销毁了，但它还是存在； 在其中引用了自由变量 var data = [] for(var i = 0; i \u003c 3; i++) { data[i] = function() { console.log(i) } } data[0]() // 3 data[1]() // 3 data[2]() // 3 // 使用闭包 var data = [] for(var i = 0; i \u003c 3; i++) { data[i] = (function(i) { return function() { console.log(i) } }) } data[0]() // 0 data[1]() // 1 data[2]() // 2 // var改成let也可以 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"原型和原型链 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下继承 1.原型链继承 function Parent() { this.name = 'Michael' } Parent.prototype.getName = function() { console.log(this.name) } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.getName() // 'Michael' 缺陷： 引用类型的属性被所有实例共享 function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { } Child.prototype = new Parent() var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+', 'Lily'] 在创建Child实例时不能向Parent传参 2.借用构造函数（经典继承） function Parent() { this.names = ['Michael', 'Milk+'] } function Child() { Parent.call(this) } var child1 = new Child() child1.names.push('Lily') console.log(child1.names) // ['Michael', 'Milk+', 'Lily'] var child2 = new Child() console.log(child2.names) // ['Michael', 'Milk+'] 优点： 避免了引用类型的属性被所有实例共享 可以在Child中向Parent传参 function Parent (name) { this.name = name } function Child (name) { Parent.call(this, name) } var child1 = new Child('kevin') console.log(child1.name);// kevin var child2 = new Child('daisy') console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法 3.组合继承 function Parent() { this.name = name this.colors = ['black', 'pink'] } Parent.prototype.getName = function() { console.log(this.name) } function Child(name, age) { Parent.call(this, name) this.age = age } Child.prototype = new Parent() Child.prototype.constructor = Child var child1 = new Child('Lily', 18) child1.colors.push('blue') console.log(child1.name) // Lily console.log(child1.age) // 18 console.log(child1.colors) // ['black', 'pink', 'blue'] var child2 = new Child('Mike', 22) console.log(child2.name) // Mike console.log(child2.age) // 22 console.log(child2.colors) // ['black', 'pink'] 优点： 融合了原型链继承和经典继承的优点，是JavaScript中最常用的继承方式 缺点： 调用了两次父构造函数 4.原型式继承 function createObj(o) { function F() {} F.prototype = o return new F() } 缺点： 和原型链继承一样，包含引用类型的属性值始终都会共享相应的值 var person = { name: 'Mike', friends: ['Lily', 'Daisy'] } var person1 = createObj(person) var person2 = createObj(person) person1.name = 'person1' console.log(person2.name) // Mike person1.friends.push('Cole') console.log(person2.friends) // ['Lily', 'Daisy', 'Cole'] 此处修改person1.name的值，可以看到person2.name并未改变，并非因为二者有独立的name值，而是因为是给person1添加了name值，而非修改原型上的name值 5.寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 function createObj(o) { var clone = Object.create(o) clone.sayName = function() { console.log('hi') } return clone } 缺点： 和经典继承一样，每次创建对象都会创建一次方法 6.寄生组合式继承 引用类型最理想的继承范式 function object(o) { function F() {} F.prototype = o; return new F(); } function prototype(child, parent) { var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype; } // 使用的时候： prototype(Child, Parent); ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"跨域原理和解决方案 什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 而我们常说的跨域是狭义上的，是由浏览器同源策略限制的一类请求场景。浏览器的同源策略会导致跨域。 同源策略 同源：协议、域名和端口都相同。 同源策略限制以下行为 无法读取cookie，localStorage和indexDB 无法获得DOM和js对象 不能发送AJAX请求 跨域解决方案 1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"JS是单线程还是多线程的？ JavaScript是单线程的： JS的一大特点就是单线程。也就是说，同一时间只能做一件事。这是因为JavaScript是脚本语言，是为处理页面中用户的交互以及操作DOM产生的，所以若其是多线程，会带来很复杂的同步问题。所以为了避免复杂性，JavaScript一诞生起就是单线程，已经成为了这门语言的核心特征。 既然JavaScript是单线程的，那么它怎么执行异步的代码？ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。但JS引擎执行异步代码并不需要等待，是因为有消息队列和事件循环。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"事件循环 JavaScript是一门单线程的语言，但不意味着单线程就会阻塞，实现单线程不阻塞的方法就是事件循环。 所有的任务都会分为同步和异步，同步直接放到主线程执行，异步任务进入任务队列，主线程的任务执行完了，就来消息队列取一个任务推到主线程执行。然后异步任务还可以细分成宏任务和微任务。每次执行一个宏任务，然后如果遇到微任务就把它放到微任务的任务队列。这个宏任务执行完了以后，就去看微任务队列，把里面所有微任务执行完。 常见宏任务：setTimeout,setInterval,setImmediate; 常见微任务：Promise.then() ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:6","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"JS中new具体做了些什么？ new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例 new会进行哪些操作？ 创建一个简单的空的JavaScript对象，即{ } 为步骤一创建出的对象添加属性__proto__ ，将该属性链接至构造函数的原型对象 将步骤一创建的对象作为this的上下文 如果该函数没有返回对象，则返回this ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:7","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"手写new function objectFactory() { // 新建一个对象 var obj = new Object() Constructor = [].shift.call(arguments) // 将obj的原型指向构造函数 obj.__proto__ = Constructor.prototype // 使用 apply，改变构造函数 this 的指向到新建的对象res var res = Constructor.apply(obj, arguments) return typeof res === 'object' ? res : obj } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:8","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"立即执行函数 IIFE(Immediately Invoked Function Expression),在定义后立即执行的JavaScript函数 (function() { statements;})(); 第一部分是包围在()里的一个匿名函数，该函数拥有独立的块级作用域，避免了外界访问此IIFE的变量，也不会污染全局作用域。 第二部分再次使用()创建了一个立即执行函数表达式，JavaScript引擎到此将直接执行函数。 将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:9","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"浮点数精度 数字类型 ECMAScript中的Number类型使用IEEE754标准，全称 IEEE 二进制浮点数算术标准，来表示整数和浮点数值。 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。 浮点数转二进制 先看0.75转二进制 $0.75 = a * 2^{-1} + b * 2^{-2} + c * 2^{-3} …$ 两边同时乘2， $1 + 0.5 = a * 2^{0} + b * 2^{-1} + …$ 得出a = 1，剩下的再乘2 $1 = b * 2^{0} + c * 2^{-1} + …$ 得出b = 1，其余为0 所以$0.75_{10} = 0.11_{2}$ 但并非每一个小数都这么好计算，就比如$0.1 = 0.00011001100110011…$ 是无限循环的 浮点数的存储 即使有些浮点数转成二进制是无限循环的，但我们仍需要存储它。在IEEE754中，一个浮点数表示方法为 $Value = sign * exponent * fraction$ 比如说，0.1的二进制表示，就是$1 * 2^{-4} * 1.1001100110011…$ 当只做二进制科学计数法的表示，value可以更具体。$Value = (-1)^{sign} * (1 + fraction) * 2^{exponent}$ $(-1)^{sign}$表示符号位，sign为0为正数。再看$(1 + fraction)$，前面的1是共有的，不用存储，只需要存储1.xxxxx中的xxxxx。最后看$2^{exponent}$真正存储时，并不会直接存exponent，而是存$exponent + bias$。 所以要存储一个浮点数，只需存储sign、fraction、(exponent + bias)这三个值。其中sign用到一位，(exponent + bias)用到11位，fraction用到剩下的52位 所以当0.1这样的数被存储下来时，就已经发生了精度丢失。 浮点数的运算 五个步骤：对阶、尾数运算、规格化、舍入处理、溢出判断 两次存储时的精度丢失加上一次运算时的精度丢失，导致$0.1 + 0.2 !== 0.3$ ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:10","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"深拷贝和浅拷贝 浅拷贝 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址，即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 // 浅拷贝的实现 // 1. 遍历复制 function shallowClone(obj) { let newObj = {} for(let prop in obj) { if(obj.hasOwnProperty(prop)) { newObj[prop] = obj[prop] } } return newObj } // 2. Object.assign() 深拷贝 深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 // 手写循环递归 function deepClone(obj, hash = new WeakMap()) { if (!obj) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (typeof obj !== \"object\") return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:11","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下Promise Promise是什么 Promise是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大。他解决异步操作的优点： 链式操作减低了编码难度 代码可读性明显增强 Promise的状态 pending（进行中） fulfilled（已成功） rejected（已失败） Promise的状态不受外界的影响，只有异步操作的结果可以决定状态 状态改变是不可逆的 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:12","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"CSS ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"双栏布局和三栏布局 双栏布局 双栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在 实现思路 使用float左浮左边栏；右边的自适应栏用margin-left撑开内容块；为父级添加BFC（如overflow: hidden），防止下方元素飞到上方内容。 使用flex弹性布局。父元素添加display: flex左边设置定宽，右边设置flex: 1或者width: 100% 三栏布局 两边使用float，中间使用margin 两边使用absolute，中间使用margin 两边使用float，并设置负的margin display: table | flex | grid ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"BFC Block Formatting Contexts (块级格式化上下文)。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"水平居中 对于行内元素： text-align: center; 对于块级元素 { margin: 0 auto; } { display: flex; justify-content: center; } { position: absolute; left: 50%; transform: translate(-50%, 0); } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"垂直居中 对于行内元素 .parent { height: h; } .child { line-height: h; } 对于块级元素 table，元素高度可以动态改变 .parent { display: table; } .child { display: table-cell; vertical-align: middle; } flex，内容块宽高任意；可以用于更复杂高级的布局技术 .parent { display: flex; align-items: center; } 绝对定位 .son { position: absolute; top: 50%; transform: translate(0, -50%); } .son { position: absolute; top: 0; bottom: 0; margin: auto 0; } /* 适用于所有浏览器 */ .son { position: absolute; top: 50%; height: 高度; margin-top: -0.5高度; } ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"HTML \u0026 浏览器 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"讲一下DOM树 什么是DOM？ 从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。 简而言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容 DOM的作用？ 页面的视角，生成页面的基本结构 Javascript脚本视角，提供脚本操作的接口 安全视角，是一道安全防线，一些不安全的内容在DOM解析阶段就被拒绝 DOM怎么生成的？ 渲染引擎内部，有一个叫HTML解析器的模块，负责将HTML字节流转换成DOM，网络进程加载了多少数据，解析器便解析多少数据 第一阶段，通过分词器将字节流转换成Token，分为Tag Token和文本Token 第二阶段（将Token解析为DOM节点）和第三阶段（将DOM节点添加到DOM树）是同时进行的 HTML解析器维护了一个Token栈结构，根据转换的Token来维护这个栈，进行出栈入栈的操作 DOM解析中的影响因素 遇到JavaScript脚本时，需要暂停整个DOM的解析，先执行JavaScript代码。原因：Javascript脚本可能更改原有的节点 可以通过预解析操作：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件 来优化 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"路由 为什么要使用路由 单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。 hash模式 使用window.location.hash属性以及窗口的onhashchange事件，实现监听浏览器地址hash值变换，执行相应的js来切换网页 hash指的是地址中#号以及后面的字符，也称散列值。 散列值并不随请求发送到服务器端，所以改变hash不会重载页面 当散列值改变，通过window.location.hash属性获取和设置hash值 window.location.hash的变化会直接反映到浏览器地址栏 history模式 window.history属性指向History对象，代表当前窗口的浏览历史。History对象保存了当前窗口访问过的所有页面网址，通过history.length可以知道当前窗口访问过几个网址。 方法：history.back(); history.forward(); history.go(); history.pushState(); history.replaceState() ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"跨页面通信 同源页面 广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent 共享存储模式：Shared Worker / IndexedDB / cookie 口口相传模式：window.open + window.opener 基于服务端：Websocket / Comet / SSE 非同源页面 嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"缓存机制 浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"本地存储 本地存储共有三种方式，coookie，localStorage和sessionStorage 三者的异同 特性 cookie localStorage sessionStorage 生命周期 一般由服务器端生成，会设置失效时间。若没有设置，则默认关闭浏览器时清除 除非手动清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 5M 5M 与服务器端通信 每次都会被携带在HTTP请求头部中，若使用cookie保存过多数据会带来性能问题 仅在客户端保存，不与服务器端进行通信 仅在客户端保存，不与服务器端进行通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景 cookie：存储用户登录信息。针对登陆过的用户，服务器端会在他登陆时在cookie中插入一段加密过的唯一辨识单一用户的辨识码。cookie还需要指定作用域，不可以跨域调用。 localStorage可以用来夸页面传递参数，代替了cookie保存用户购物车信息的工作。sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。 安全性 并非所有数据都适合保存在上述三者中。只要打开控制台，就可以随意修改他们的值。所以重要的数据需要保存在服务器端而非客户端。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"计算机网络 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"HTTP常见状态码 1xx代表信息相应；2xx代表成功相应；3xx代表重定向；4xx代表客户端响应；5xx代表服务端响应。 100 Continue ：表明到目前为止所有内容都是可行的，客户端可以继续请求 101 Switching Protocol：指示服务器正在切换协议 200 OK：请求成功，具体含义取决于请求的方法 204 Not Content：服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。 205 Reset Content：服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。如用户输入表单，提交后清空表单。 206 Partial Content：服务器已经成功处理了部分 GET 请求。迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 301 Move Permanently：被请求的资源已经永久移到了新位置。拥有编辑功能的客户端会自动把请求的地址修改为服务器返回的地址。 302 Found：临时重定向，以后应该继续按原地址发送请求。 304 Not Modified：客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器返回这个状态码。禁止包含消息体，因此始终以消息头后的第一个空行结尾。 400 Bad Request：语义有误，服务器无法理解；请求参数有误。 401 Unauthorized：当前请求需要用户验证。 403 Forbidden：服务器已经理解请求，但是拒绝执行。 404 Not Found：请求失败，请求需要的资源在服务器上未被发现。 500 Interval Server Error：服务器遇到不知道该如何处理的情况。 503 Service Unavailable：服务器没有准备好处理请求，常见原因是服务器因维护或重载而停机。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"TCP三次握手和四次挥手 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"TCP和UDP的区别 UDP 用户数据包协议，一个简单的面向数据的通信协议，对于应用层传递下来的报文，它只会简单地加上首部，就交给网络层，不会做合并或者拆分的工作。特点如下 不提供复杂的控制机制，利用IP提供面向无连接的通信服务 传输过程中若出现了丢包，UDP也不会重发 包的到达顺序错乱了的话，UDP也无法纠正 无法进行流量控制等避免网络堵塞的行为 首部8个字节 发送端只负责将数据发送到网络，接收端从消息队列读取 支持一对一、一对多、多对一和多对多的交互通信 TCP 传输控制协议，是一种可靠的、面向字节流的通信协议，把应用层传递下来的数据看做是无结构的字节流来发送。，会根据当前网络的堵塞情况来确定每个报文段的大小。 充分地实现了数据传输时的各种控制功能，可以进行重发控制、顺序控制 作为一种面向连接的服务，只有在确认通信对端的存在后才会发数据，控制通信流量的浪费 建立连接3次握手、断开连接四次挥手 根据TCP的机制，在IP这种无连接的网络上也能实现高可靠性的通信。 首部20字节 只能点对点全双工通信 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"https和http的区别 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"七层网络模型 应用层 该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务；在应用层交互的数据单元称为报文。应用层协议：HTTPS、DNS、SMTP等 表示层 表示层的作用是使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异 会话层 会话层就是负责建立、管理和终止表示层实体之间的通信会话。提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法 传输层 主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。主要的传输层协议是TCP和UDP 网络层 在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。 链路层 在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧 物理层 和软件关系不大，确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性） ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"性能 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"重排和重绘 重排重绘是什么？ 重排：也叫回流，当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排 添加或者删除可见的DOM元素 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 “重绘\"不一定会出现\"重排”，“重排\"必然会出现\"重绘” ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"优化方法 尽可能减少重排的次数和范围：重排的性能花销跟渲染树有多少节点需要重新构建有关系，我们应尽量以局部布局的方式组织HTML 分离读写操作，防止多次拿值触发渲染 样式集中改变 缓存布局信息 离线改变DOM position可以多用absolute和fixed，这样不用考虑他对其他元素的影响 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"白屏 概念 白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。 白屏期间发生了什么？ DNS Lookup 浏览器会先对页面进行域名解析，获取到服务器的IP地址后，进而和服务器进行通信。 建立TCP请求连接 服务端处理响应 在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。 客户端下载、解析、渲染显示页面 白屏优化 针对白屏期间的环节进行逐一优化 DNS缓存优化、DNS预加载、稳定可靠的DNS服务器 TCP网络链路优化 服务端处理优化 尽可能精简HTML、CSS代码和结构。合理放置JS代码 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"Vue ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"对keep-alive的理解 keep-alive是什么 keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM，包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。它可以设置一些属性 include 字符串或者正则表达式，只有名称匹配的组件才会被缓存 exclude 和上面的相反，名称匹配的不被缓存 max 最多可以缓存多少组件 keep-alive基本用法 \u003ckeep-alive\u003e \u003ccomponent :is=\"view\"\u003e\u003c/component\u003e \u003c/keep-alive\u003e 设置了keep-alive缓存的组件，会多出两个生命周期钩子（activated与deactivated） 使用场景 当我们在某些场景下不想让页面重新加载时我们可以使用keepalive 例如，当我们从首页切换到歌手页，再切换到收藏页面，再返回歌手页，我们不想每次切换页面都发送一次请求，就使用keep-alive将其缓存。 原理分析 源码位置：src/core/components/keep-alive.js ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"通信方式 通过 props 传递 通过 $emit 触发自定义事件 使用 ref EventBus $parent 或 root attrs 与 listeners Provide 与 Inject Vuex ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:2","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"理解双向数据绑定 双向绑定由三个部分组成：数据层（Model）、视图层（View）、业务逻辑层（ViewModel）。其中最重要的是那个ViewModel，主要职责是数据变化后更新视图，视图变化后更新数据。包含两部分，监听器和解析器。监听器用来监听所有数据的属性，解析器对每个元素节点的指令进行扫描和解析，根据指令模板替换数据,以及绑定相应的更新函数。 简单来说，利用Object.defineProperty()，结合订阅-发布模式，对数据属性的getter和setter进行劫持。Vue3中抛弃了defineProperty()，改为Proxy Proxy相比Object.defineProperty()的优势 Object.defineProperty()虽然可以做到监听对象属性，但是存在着一些缺点。 检测不到对象属性的添加和删除 数组API无法监听到，所以在Vue2中对数组API进行了重写 需要对每个属性进行遍历监听，如果是嵌套对象，需要深层监听，造成性能问题 而Proxy直接可以劫持整个对象，并返回一个新对象，我们只需要操作新对象就可以达到响应式目的。 Proxy的缺点：兼容性差，不兼容IE，而Object.defineProperty()可以兼容到IE9 Vue里的双向绑定流程 初始化，对data执行相应化处理，该过程发生在监听器 同时编译模板，找到里面动态绑定的数据，然后获取、初始化视图层，发生在解析器里 然后定义更新函数和一个Watcher，Watcher来观察数据是否变化了，如果变化就调用更新函数 然后因为某些data会出现多次，就要有多个watcher来观测他，所以对每一个data就准备一个管家来管理那些watcher 如果data变了，就先找他对应的管家，然后通知里面的每一个观察者watcher ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:3","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"computed和watch computed computed设计的初衷是为了使模板中的逻辑运算更简单, 在模板中有很多复杂的数据计算的话, 可以把该计算逻辑放到computed中 computed是计算属性的，会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。 应用场景： 一些重复使用的数据或复杂及费时的运算，可以放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取。 如果需要的数据依赖于其他的数据, 我们可以把该数据设计为computed中。 computed和methods的区别 computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值。而methods不是响应式的，每次调用都会重新求值 omputed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get / set变成可读写属性, 但是methods中的成员没有这样的。 watch watch是一个对data数据的监听回调, 当依赖的数据变化时, 会执行回调。在回调中，会传入newVal和oldVal两个参数。 Vue实例会在实例化时调用$watch()，遍历watch对象的每一个属性。 应用场景： 当在data中的某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时. 我们就可以使用watch来进行监听 watch和computed的异同 相同：都是观测页面数据变化的 不同：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。watch每次都需要执行函数。watch更适用于数据变化时的异步操作。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:4","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"Vue3新特性 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:5","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"diff算法 是什么 diff 算法是一种通过同层的树节点进行比较的高效算法，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较。 它有两个特点 比较只会在相同层级进行，不会跨级比较 在具体某一层的diff比较中，循环从两边向中间比较 原理分析 数据发生改变，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 先看patch。接收四个参数，第一个是旧节点oldVnode，第二个是新节点vnode。 没有新节点，那么直接把旧的删光，触发旧节点的destroy钩子 没有旧节点，直接生成新的就可以了，createElm 通过sameNode判断两个节点一不一样，一样的话直接patchVnode，不一样的话创建新节点，删除旧节点 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:6","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"操作系统 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:0","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["知识点"],"content":"进程和线程的区别： 进程，是程序的依次执行过程，是程序在执行过程中分配和管理资源的基本单位，每个进程都有自己的地址空间，至少有五种状态：初始态，执行态，等待状态，就绪状态，终止状态。 线程，是CPU调度和分派的基本单位，可以和同一进程下的其他线程共享全部资源 二者联系：线程是进程中的一部分，一个进程可以有多个线程，但一个线程只能存在于一个进程中。 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 ","date":"2021-10-08","objectID":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:1","tags":["面试"],"title":"知识点总结","uri":"https://MichaelYuhe.github.io/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["Program"],"content":"Vuex使用小结 ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:0","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"写在前面 虽如官方文档所说：“如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex”。没错，我的应用就是够简单的那个😂 但随着深入学习，迟早也需要掌握Vuex的使用，何不现在就用上他呢？ ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:1","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。（摘自Vue3官方文档） 该状态自管理应用包含三部分 state，状态，驱动应用的数据源 view，视图，以声明方式将state映射到视图 actions，操作，响应在视图上的用户输入导致的状态变化 Vuex可以帮助我们更好地管理共享状态 ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:2","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"开始使用Vuex 引入 npm i install vuex 在src文件夹下新建store目录，在其中新建index.js文件 import { createStore } from \"vuex\" export default createStore({ state: {}, mutations: {}, actions: {}, modules: {} }) 实例 往state中存入我们所需要共享的数据和操作 state: { isLogin: false, configs: [ { title: \"theme\", property: true, id: 1 }, { title: \"enableDelete\", property: true, id: 2 } ] }, mutations: { login(state) { state.isLogin = true } } 存放好了数据，该怎么查看、使用和更改这些数据呢？ 要调用这些数据，需要通过store.state来获取 // 任意组件/视图下 console.log(this.$store.state.isLogin) 我们不能直接更改数据，需要通过提交mutation的方式来改变。例如，当我们点击了登录按钮 methods: { login() { this.$store.commit('login') } // 当需要同时传递数据 this.$store.commit('mutationName', data1, data2) } ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:3","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"解决页面刷新数据丢失问题 store里的数据是保存在运行内存中的，每当页面刷新，就会重载Vue实例，store里的数据就会被重新赋值初始化。 要解决这个问题，就需要想办法把数据存储在本地（localStorage, sessionStorage, cookie三者之一中）。三者区别 由于创建的是单页面应用，操作只是在一个页面跳转路由，因此选择sessionStorage. 具体操作： 在页面初始化和每次更新时，读取sessionStorage的数据存储到store中，使用Vuex的replaceState方法来替换store的根状态 在beforeunload方法中，将store.state存储到sessionStorage. // App.vue created() { //在页面加载时读取sessionStorage里的状态信息 if (sessionStorage.getItem(\"store\")) { this.$store.replaceState( Object.assign( {}, this.$store.state, JSON.parse(sessionStorage.getItem(\"store\")) ) ); } //在页面刷新时将vuex里的信息保存到sessionStorage里 window.addEventListener(\"beforeunload\", () =\u003e { sessionStorage.setItem(\"store\", JSON.stringify(this.$store.state)); }); }, ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:4","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"数据更新页面不更新的问题 解决完数据丢失的问题，又遇到了更新数据页面不随之更新的问题。从底层出发进行分析。 原来的代码如下 // 组件中 data() { return { currentCategory: this.$store.state.currentCategory } } methods: { changeCategory(name) { this.$store.commit('changeCategory', name) console.log(this.$store.state.currentCategory) // 成功更新 console.log(this.currentCategory) // 未更新 } } // store.js mutations: { changeCategory(state, name) { state.currentCategory = name } } 在提交了更新以后，通过控制台查看输出，可以发现store.js里的变量已经成功更新，但组件内的data并没有再次获取更新后的值。这就牵扯到Vue的生命周期。 data() { return { val: 'hello vue' } } beforeCreated() { console.log(this.val) //undefined } created() { console.log(this.val) // hello vue } 不难发现data的赋值，是在created()中进行的。 而Vuex的state数据改变，并不会触发组件的刷新，组件也就无法获取到改变的值，直到手动进行刷新为止。该如何解决这个问题呢？ 最简单的方法，是在组件中直接使用state中的数据，而不是用自建data作为中间变量。 第二个方法，就是在提交数据的时候进行强制刷新操作，迫使组件重新获取store的值 methods: { changeCategory(name) { this.$store.commit('changeCategory', name) console.log(this.$store.state.currentCategory) // 成功更新 console.log(this.currentCategory) // 未更新 this.$forceUpdate() console.log(this.currentCategory) // 成功更新 } } ","date":"2021-10-01","objectID":"https://MichaelYuhe.github.io/vuex/:1:5","tags":["Vue"],"title":"Vuex使用小结","uri":"https://MichaelYuhe.github.io/vuex/"},{"categories":["Program"],"content":"Vue 3学习之路由的进阶 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:0","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"写在前面 之前学习使用了vue的路由，实现了简单的单页面内部pages跳转，继续跟随官方视频学习，进阶vue3中路由的使用 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:1","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"切换效果 vue-router提供了一套完备方便的，用于给各路由页面切换增加效果的方法。 在vue2中，我们可以使用如下方法给页面切换添加slider效果 \u003ctransition name=\"slide\" mode=\"out-in\"\u003e \u003crouter-view :key=\"$route.path\"/\u003e \u003c/transition\u003e .slide-enter-active, .slide-leave-active { transition: opacity .6s, transform .6s; } .slide-enter, .slide-leave-to { opacity: 0; transform: translateX(-30%); } 但在vue3中，继续这种写法能正常工作，但会有warning。 根据warning提示对其进行修改即可 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:2","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"路由回溯与追踪 想要添加一个回到上一页的功能却苦于状态管理？Vue已经帮我们准备好了方法。很简单，仅需要一行代码。给一个按钮绑定goBack事件，点击触发，以下是goBack函数内的所有内容。this.$router.go()可以接受正数和负数作为参数，来进行路由间的跳转。 return this.$router.go(-1) ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:3","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"嵌套路由 一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构。通过 Vue Router，就可以使用嵌套路由配置来表达这种关系。 想要将组件渲染到嵌套的router-view当中，就需要在路由中配置chidren { path: \"/details/:slug\", name: \"DestinationDetails\", component: () =\u003e import(/* webpackChunkName: \"DestinationDetails\" */\"../views/DestinationDetails.vue\"), props: true, children: [ { path: \":experienceSlug\", name: \"ExperienceDetails\", component: () =\u003e import(/* webpackChunkName: \"ExperienceDetails\" */\"../views/ExperienceDetails.vue\"), props: true } ]} 如上所示，ExperienceDetails组件就将被渲染到嵌套在DestinationDetails组件的router-view中，而不会跳转到新的页面。 children 配置只是另一个路由数组，就像 routes 本身一样。因此，可以根据自己的需要，不断地嵌套视图。 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:4","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"解耦：路由组件传参 在组件中过多使用$route会使组件与路由紧密耦合，限制了其灵活性，因为这样只能用于特定的URL，我们可以通过配置props来解决这个问题。以官方文档为例，我们可以将下面的代码 const User = { template: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e' } const routes = [{ path: '/user/:id', component: User }] 替换成 const User = { props: ['id'], template: '\u003cdiv\u003eUser {{ id }}\u003c/div\u003e' } const routes = [{ path: '/user/:id', component: User, props: true }] 这就允许我们在任何地方使用该组件，使其更易于复用与测试。 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:5","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"导航守卫 正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航 ","date":"2021-09-27","objectID":"https://MichaelYuhe.github.io/vue-router2/:1:6","tags":["Vue"],"title":"Vue Router2","uri":"https://MichaelYuhe.github.io/vue-router2/"},{"categories":["Program"],"content":"Vue学习历程（二） 路由的使用 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:0","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"写在前面 在着手进行一个大项目之前，想先优化、完善之前的todolist项目。例如：增加登录、注册功能；数据储存在云端；增加todo项目的分类与更清晰的状态表示；增加用户自定义设置，如皮肤，显示项等等……这些简单的功能放在单纯的一个页面中就显得拥挤，多页面又小题大做，也会影响使用体验，引入router就显得很有必要 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:1","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"什么是路由？ 路由，可以根据不同的 url 地址展示不同的内容或页面，又有前端路由和后端路由之分，而后端路由的渲染存在性能问腿，所以在项目中前端路由发挥着重要的作用。 简单来说，前端路由就是在保证只有单页面，且交互时不刷新不跳转，为SPA(single page web application)中的每个视图展示形式匹配一个特殊的url。在刷新、前进后退等操作均通过这个特殊url来实现。 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:2","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["Program"],"content":"Vue中如何使用路由？ 路由一般有两种模式，分别是hash模式和History模式，此处将使用history模式(除非为了兼容IE8，均推荐使用History模式) 前置工作 在项目所在目录打开终端，输入以下代码 npm i install vue-router 在src文件夹下新建目录route，在该文件夹里添加一个index.js文件 .// index.js import { createRouter, createWebHistory } from \"vue-router\" const history = createWebHistory() const router = createRouter({ history, routes: [ { path: '/', name: 'Home', component: () =\u003e import('../views/Home.vue') }, { path: '/Login', name: 'Login', component: () =\u003e import('../views/Login.vue') } ] }) export default router 修改main.js文件 // main.js import { createApp } from 'vue' import App from './App.vue' import router from './route' // 引入 createApp(App) .use(router) // 注入 .mount('#app') 新建views文件夹，内部存放需要通过路由显示的视图 接下来就需要添加跳转路由的连接，和存放跳转到的视图的容器。更改App.vue文件结构，新增一个导航区存放链接，内容区存放视图，原有结构转移到Home.vue文件中 \u003c!-- 导航区 --\u003e \u003cdiv class=\"nav\"\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e \u003crouter-link to=\"/Login\"\u003eLogin\u003c/router-link\u003e \u003c/div\u003e \u003c!-- 视图区 --\u003e \u003cdiv class=\"main\"\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e 最终效果展示 当点击Login链接，以路由方式跳转到了Login界面 点击Home或者tourist mode， 回到主页面 // to do 学习VueX 区分登录用户和游客 增加task的分类功能 设置页面更换主题 ","date":"2021-09-23","objectID":"https://MichaelYuhe.github.io/vue-router/:1:3","tags":["Vue"],"title":"Vue Router","uri":"https://MichaelYuhe.github.io/vue-router/"},{"categories":["program"],"content":"前言  学习完基础的三剑客后，决定开始学习框架。无非就两种选择，Vue或是React，了解了一番二者的区别，再看着文档写了两个教程demo，二者具体深层的区别并没有太大了解也没有感受到，单纯觉得Vue更加适合我😂，于是就选择了学习Vue。至于Vue和React两个框架的区别，具体可以看看这篇文章  看完了文档，迫不及待想撸出自己第一个Vue应用，但仍不知道如何下手，对Vue应用的搭建的流程也并不了解，所以选择了观看一个很优秀的Youtuber – Traversy Media的“Vue crash course”，看完视频后去复现他的代码，然后再自己修改样式、添加功能等等…… ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:1","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"成品 点击Add Task按钮，弹出输入框，可以输入任务的具体内容和时间安排 待办的任务将会在下方显示，每个任务的右侧有两个功能按钮，分别是编辑和删除 数据储存于本地的json文件中，刷新浏览器或重新启动服务能照常读取数据 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:2","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"todo 将json数据部署到云端，达到无需启动node服务即可访问的效果 调整布局，美化项目 ","date":"2021-09-07","objectID":"https://MichaelYuhe.github.io/vue-todoist/:0:3","tags":["Vue"],"title":"Vue学习历程(一) Vue-todoist","uri":"https://MichaelYuhe.github.io/vue-todoist/"},{"categories":["program"],"content":"如何给自己的博客添加一键回到顶部的功能？  今天用Hugo搭好了博客，美化、自定义什么的先放在一边，单纯用框架改改参数什么的，总感觉技术含量不高嘛（高了我也做不出来），就想着先添加个小功能，提供一个一键回到顶部的功能。让我们开始吧。  本文以Hugo框架，LoveIt主题为例。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:0","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加样式 在CSS中，定义返回顶部按钮的样式。打开Hugo主题目录下的 static/asserts/_custom.scss，在其中加入样式代码。 .backtop { color: #b3b1b1; position: fixed; right: 16px; bottom: 20px; width: 33px; height: 33px; z-index: 10000; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:1","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"导入按钮图标 准备好按钮的图标，前往Font Awesome找到心仪的图标，下载其SVG文件，打开后全部复制 在Hugo主题目录下layouts/partials新建back2top.html文件，将拷贝的代码放入 \u003csvg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"chevron-circle-up\" class=\"svg-inline--fa fa-chevron-circle-up fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e \u003cpath fill=\"currentColor\" d=\"M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z\"\u003e \u003c/path\u003e \u003c/svg\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:2","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"添加锚点 在当前目录下找到header.html文件并打开，在任意行加入以下代码 \u003cspan id=\"top\"\u003e\u003c/span\u003e 来到layouts/_default文件夹，打开single.html，添加以下代码(与content同级) {{- define \"main\" -}} \u003ca href=\"#top\" class=\"backtop\"\u003e{{ partial \"back2top.html\" . }}\u003c/a\u003e ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:3","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["program"],"content":"大功告成！ ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/back-to-top/:1:4","tags":["Hugo","front-end"],"title":"一键回到顶部","uri":"https://MichaelYuhe.github.io/back-to-top/"},{"categories":["Program"],"content":"LeetCode刷题记录 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:0:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"动态规划 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"121.买卖股票的最佳时机 思路： 动态规划题 minPrice保存前i天的最低价格，用第i天的现价去减这个最小值，就得到了在第i天卖出的利润 取最大利润 var maxProfit = function(prices) { let profit = 0, res = 0, minPrice = prices[0]; let len = prices.length; for(let i = 1; i \u003c len; i++){ if((prices[i] - minPrice) \u003e profit){ profit = prices[i] - minPrice; res = i + 1; } minPrice = Math.min(minPrice, prices[i]); //前i-1天最低价格 } return res; }; 时间复杂度：O(n)，遍历一次 空间复杂度：O(1) 执行用时：84ms，击败了97.91%的用户 内存消耗：47.5MB，击败了71.92%的用户 官方题解： 无js版本，但思路是一致的，不同的点在于官方是从0开始遍历，然后min最开始取一个无穷大值以保证其大于第一天的价格。 class Solution: def maxProfit(self, prices: List[int]) -\u003e int: inf = int(1e9) minprice = inf maxprofit = 0 for price in prices: maxprofit = max(price - minprice, maxprofit) minprice = min(price, minprice) return maxprofit ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"714. 买卖股票的最佳时机含手续费 思路： 动态规划，每天有两种状态，一是今天交易结束后不持有股票，二是持有 sell表示不持有，buy表示持有 不持有的情况：前一天就不持有，或者前一天买入今天卖出 持有的情况：前一天就持有，前一天不持有但今天买入 因此可以得到状态转移方程 sell = max(sell, buy + prices[i] - fee), buy = max(buy, sell - prices[i]) var maxProfit = function(prices, fee) { let sell = 0, buy = -prices[0] for(let i = 1; i \u003c prices.length; i++) { sell = Math.max(sell, buy + prices[i] - fee) buy = Math.max(sell - prices[i], buy) } return sell // 要想利润最大，结束后肯定不能持有股票 }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1014.最佳观光组合 思路： maxScore由三个值组成：距离以及两个景点的好看程度 很明显，两个景点都好看，又近的时候最完美 因此可以先用一个值记录第一个好看的景点，当第二个离他越来越远，这个景点的好看程度也一直下降 var maxScoreSightseeingPair = function(values) { let maxScore = 0, firstSight = 0, secondSight = 1 for(let i = 0; i \u003c values.length - 1; i++) { // 如果第一个景点不够好看，无法支持这个距离，更新 if(values[firstSight] \u003c= values[i]) { // 更新第一个景点（第一个因为太远被抛弃了） firstSight = i secondSight = firstSight + 1 } // 每次循环，第一个景点的吸引力就下降一点 values[firstSight]-- // maxScore维护最大值 maxScore = Math.max(maxScore, (values[firstSight] + values[secondSight])) // 一直在往后找第二个景点 secondSight++ } return maxScore ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"413.等差数列划分 思路： 每个等差数列内的子数列，都是等差数列 不是别的等差数列的子数列的等差数列😂,之间不会有交集 var numberOfArithmeticSlices = function(nums) { if(nums.length \u003c 3) return 0 let res = 0, len = 2 for(let i = 1; i \u003c nums.length - 1; i++) { if((nums[i] - nums[i-1]) === (nums[i+1] - nums[i])) { len++ } else { if(len \u003e= 3) { res = res + (len-1) * (len-2) / 2 } len = 2 } if(i === nums.length - 2) { if(len \u003e= 3) { res = res + (len-1) * (len-2) /2 } } } return res }; 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：64ms，击败了88.75%的用户 内存消耗：37.6MB，击败了58.73%的用户 官方题解 var numberOfArithmeticSlices = function(nums) { const n = nums.length; if (n === 1) { return 0; } let d = nums[0] - nums[1], t = 0; let ans = 0; // 因为等差数列的长度至少为 3，所以可以从 i=2 开始枚举 for (let i = 2; i \u003c n; ++i) { if (nums[i - 1] - nums[i] === d) { ++t; } else { d = nums[i - 1] - nums[i]; t = 0; } ans += t; } return ans; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"53.最大子序和 思路： 若只有一个元素，直接返回 从前往后遍历并求和，若sum\u003c0，则sum归零（前面的元素都不要了） 到后面遇到了负数，但是这个负数加进来也不足以使sum\u003c0，则从这个负数开始往后看，它和后面的元素依此相加，得到一个newSum，一大于0就把newSum加上。 官方题解： 动态规划 var maxSubArray = function(nums) { let pre = 0, maxAns = nums[0]; nums.forEach((x) =\u003e { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); }); return maxAns; }; foreach：对数组的每个元素执行一次给定的函数。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:5","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"918. 环形子数组的最大和 思路： 处理思想和最大子序和基本一致，唯一区别要考虑到环 可以分为两种情况考虑，第一种是不需要越过边界，则和最大子序和一样 第二种是越过了边界，这是只需要求出数组的总和，再减去最小子序和，就是越过环的结果 最后在处理结果时还需要考虑全为负数的情况 var maxSubarraySumCircular = function(nums) { let max = nums[0], min = nums[0], preMax = nums[0], preMax = nums[0], sum = nums[0] for(let i = 1; i \u003c nums.length; i++) { preMax = Math.max(nums[i], (preMax + nums[i])) preMin = Math.min(nums[i], (preMin + nums[i])) max = Math.max(preMax, max) min = Math.min(preMin, min) sum += nums[i] } return (max \u003c 0) ? max : Math.max(max, sum - min) } 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：84ms，击败了80.75%的用户 内存消耗：43.6MB，击败了78.73%的用户 官方题解 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:6","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"70. 爬楼梯 思路： 爬到某一级台阶的前一步，必定落在上一级或者上上级。 所以爬到某一台阶的方法数，等于爬到上一级和上上级的方法数之和。 var climbStairs = function(n) { if(n \u003c= 2){ return n; } let i1 = 1, i2 = 2, temp = 0; for(let i = 3; i \u003c= n; i++){ temp = i1 + i2; i1 = i2; i2 = temp; } return temp; } 时间复杂度：O(N)，遍历一次 空间复杂度：O(1)，不需要额外空间 执行用时：64ms，击败了94.33%的用户 内存消耗：37.7MB，击败了30.68%的用户 官方题解 /* 方法一，动态规划 */ var climbStairs = function(n) { let p = 0, q = 0, r = 1; for (let i = 1; i \u003c= n; ++i) { p = q; q = r; r = p + q; } return r; }; /* 方法二，通项公式 */ var climbStairs = function(n) { const sqrt5 = Math.sqrt(5); const fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1); return Math.round(fibn / sqrt5); }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:7","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"198. 打家劫舍 思路： 小偷身处第 i 间房子时，知道自己在 “ 只偷到(k - 2)间时最多能偷到的钱 i1 ” 和 “ 只偷到(k - 1)间时最多能偷到的钱 i2 ” 第 i 间房子的钱加上 i1 比 i2 大的话，就偷，然后到了下一间房子后，i1 变成了之前的 i2 ， i2 变成了现在的sum 如果小，就不偷，直接到下一间房子，此时 i1 变为 i2， i2 则不变 var rob = function(nums) { let len = nums.length; if(len === 1) return nums[0]; if(len === 2) return Math.max(nums[0], nums[1]); let i1 = nums[0], i2 = Math.max(nums[0], nums[1]); let sum = 0; for(let i = 2; i \u003c len; i++){ if((nums[i] + i1) \u003e i2){ sum = nums[i] + i1; i1 = i2; i2 = sum; } else{ sum = i2; i1 = i2; } } return sum; }; 执行用时：68ms，击败了84.07%的用户 内存消耗：37.7MB，击败了44.61%的用户 时间复杂度：O(n) 空间复杂度：O(1) 官方题解 class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int length = nums.length; if (length == 1) { return nums[0]; } int first = nums[0], second = Math.max(nums[0], nums[1]); for (int i = 2; i \u003c length; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:1:8","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"二分法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"35.搜索插入位置 思路： 二分查找法的基础变式 如果查找到了，直接返回； 如果没找到，返回left(right+1)，也就是当前“光标”所在位置 var searchInsert = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, mid; while(left \u003c= right){ mid = parseInt(left + (right-left) / 2); if(nums[mid] \u003e target){ right = mid - 1; } else if(nums[mid] \u003c target){ left = mid + 1; } else{ return mid; //找到了就直接返回索引值 } } return left; //若没找到，则返回目前“光标”位置，该位置前面的数都小于target，后面则都更大 }; 执行用时：68ms，击败了94.68%的用户 内存消耗：39.1MB，击败了12.19%的用户 时间复杂度：O(logn) 空间复杂度：O(1) 官方题解： var searchInsert = function(nums, target) { const n = nums.length; let left = 0, right = n - 1, ans = n; while (left \u003c= right) { let mid = ((right - left) \u003e\u003e 1) + left; if (target \u003c= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; }; 和自己思路类似，自己的觉得更简洁直白 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"34. 在排序数组中查找元素的第一个和最后一个位置 思路： 用二分法，找一个target 如果没找到，则直接返回-1，-1 找到了的话，从mid开始两头找start和end var searchRange = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, start = -1, end = -1; let mid = parseInt(left + (right - left) / 2); while(left \u003c= right){ if(nums[mid] \u003e target){ right = mid - 1; mid = parseInt(left + (right - left) / 2); } else if(nums[mid] \u003c target){ left = mid + 1; mid = parseInt(left + (right - left) / 2); } else{ break; /* 找到了 */ } } /* 如果是因为left大于right而跳出的循环，则证明没有找到 */ /* 如果left仍未大于right，则证明找到了，需要继续找 */ if(left \u003e right){ return [start,end]; /* 直接返回[-1,-1] */ } let i = 0, j = 0; while(++i){ if(nums[mid-i] != target || (mid-i) \u003c left){ start = mid - i + 1; break; } } while(++j){ if(nums[mid+j] != target || (mid+j) \u003e right){ end = mid + j - 1; break; } } return [start,end]; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：68ms，击败了94.12%的用户 内存消耗：39.9MB，击败了12.97%的用户 陷入了误区，找到mid后使用了线性查找，导致时间复杂度来到了O(n)而不是O(logn)！！正确的做法是继续二分查找！！！ 改进版 var searchRange = function(nums, target) { const len = nums.length; let left = 0, right = len - 1, start = -1, end = -1; let mid = parseInt(left + (right - left) / 2); while(left \u003c= right){ if(nums[mid] \u003e target){ right = mid - 1; mid = parseInt(left + (right - left) / 2); } else if(nums[mid] \u003c target){ left = mid + 1; mid = parseInt(left + (right - left) / 2); } else{ break; /* 找到了 */ } } /* 如果是因为left大于right而跳出的循环，则证明没有找到 */ /* 如果left仍未大于right，则证明找到了，需要继续找 */ if(left \u003e right){ return [start,end]; /* 直接返回[-1,-1] */ } 官方题解 const binarySearch = (nums, target, lower) =\u003e { let left = 0, right = nums.length - 1, ans = nums.length; while (left \u003c= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] \u003e target || (lower \u0026\u0026 nums[mid] \u003e= target)) { right = mid - 1; ans = mid; } else { left = mid + 1; } } return ans; } var searchRange = function(nums, target) { let ans = [-1, -1]; const leftIdx = binarySearch(nums, target, true); const rightIdx = binarySearch(nums, target, false) - 1; if (leftIdx \u003c= rightIdx \u0026\u0026 rightIdx \u003c nums.length \u0026\u0026 nums[leftIdx] === target \u0026\u0026 nums[rightIdx] === target) { ans = [leftIdx, rightIdx]; } return ans; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"4. 寻找两个正序数组的中位数 思路： 归并排序，根据长度返回中位数 var findMedianSortedArrays = function(nums1, nums2) { let len1 = nums1.length, len2 = nums2.length; let res = 1.0, i = 0, j = 0; let nums = []; while(i \u003c len1 || j \u003c len2) { if(i \u003e= len1) { nums.push(nums2[j++]); } else if(j \u003e= len2) { nums.push(nums1[i++]); } else { if(nums1[i] \u003e= nums2[j]) { nums.push(nums2[j++]); } else { nums.push(nums1[i++]); } } } let len = nums.length; if(len % 2) { res = nums[Math.floor(len / 2)]; } else { res = (nums[len / 2] + nums[len / 2 - 1]) / 2 } return res; }; 时间复杂度：O(m+n) 空间复杂度：O(m+n) 执行用时：124ms，击败了65.19%的用户 内存消耗：43.2MB，击败了63.96%的用户 官方题解： 题目要求：时间复杂度O(log(m+n))。 该题可以转化为，求两个有序数组中第k小的数，其中k为(m+n)/2或者(m+n)/2+1 要找到第k小的元素，我们可以比较nums1[k / 2 - 1]和nums2[k / 2 - 1]，所以对于nums1[k / 2 - 1]和nums2[k / 2 - 1]中的较小值，最多只会有(k-2)个元素比它小，那么它不可能是第k小的元素。 此处k / 2为整数除法( Math.floor() ) 此时可以归纳三种情况： nums1[k / 2 - 1] \u003c nums2[k / 2 - 1]，则可以排除nums1[1] 到nums1[k / 2 - 1] nums2[k / 2 - 1] \u003c nums1[k / 2 - 1]，则可以排除nums2[1] 到nums2[k / 2 - 1] nums1[k / 2 - 1] == nums2[k / 2 - 1]，可以并入第一种情况 所以在比较后，我们可以排除k / 2个不可能是第k小的数，意味着查找的范围已经缩小了一半 下一步就是在排除后的新数组上继续二分查找，并且根据我们排除的数的个数，来减小k的值 有三种特殊情况需要处理： 越界。则取该数组最后一个数字，同时注意k不能直接减半 若一个数组为空，直接返回另一个数组第k小的数字 若k=1，直接返回两数组首元素较小值 优化后： ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:2:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"栈 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:3:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"剑指offer 06 从尾到头打印链表 思路： 遍历链表，依此在头部添加val var reversePrint = function(head) { let res = new Array(); while(head!==null){ res.unshift(head.val); head = head.next; } return res; }; 时间复杂度：O(n) 空间复杂度：O(n) 执行用时：80ms，击败了94.21%的用户 内存消耗：39.4MB，击败了94.03%的用户 官方题解 栈 ​ 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:3:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"树 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:4:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"671. 二叉树中第二小的节点(https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/) 思路： 在这个特殊的二叉树中，子节点的元素均大于等于父节点元素的值。 所以只要自顶往下，在某一层遇到了比根节点大，且是这一层最小的，那就是所要的节点。 如果一直没找到，直到所有节点遍历完了，也就是所有叶节点也和根节点的值一样，返回-1； 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解 var findSecondMinimumValue = function(root){ let ans = -1; const rootValue = root.val; const dfs = (node) =\u003e { if(node === null){ return; } if(ans !== -1 \u0026\u0026 node.val \u003e= ans){ return; } if(node.val \u003e rootValue){ ans = node.val; } dfs(node.left); dfs(node.right); } dfs(root); return ans; } **const dfs = (node) =\u003e {} ** =\u003e : 箭头函数，相当于匿名函数，且简化了函数定义 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:4:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"BFS和DFS ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:5:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"200. 岛屿数量 思路 遍历grid，当遇到1，将其置0，将其上下左右的1置0，将其上下左右的1的上下左右的1置零…… var numIslands = function(grid) { let res = 0 const bfs = (i, j) =\u003e { if(i \u003c 0 || j \u003c 0 || i \u003e= grid.length || j \u003e= grid[0].length || grid[i][j] === '0') { return } grid[i][j] = '0' bfs(i + 1, j) bfs(i - 1, j) bfs(i, j + 1) bfs(i, j - 1) } for(let i = 0; i \u003c grid.length; i++) { for(let j = 0; j \u003c grid[0].length; j++) { if(grid[i][j] === '1') { res++ bfs(i, j) } } } return res }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：84ms，击败了52.76%的用户 内存消耗：40.4MB，击败了49.33%的用户 官方题解 1.广度优先搜索BFS class Solution: def numIslands(self, grid: [[str]]) -\u003e int: def bfs(grid, i, j): queue = [[i, j]] while queue: [i, j] = queue.pop(0) if 0 \u003c= i \u003c len(grid) and 0 \u003c= j \u003c len(grid[0]) and grid[i][j] == '1': grid[i][j] = '0' queue += [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]] count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '0': continue bfs(grid, i, j) count += 1 return count 2.深度优先搜索DFS class Solution: def numIslands(self, grid: [[str]]) -\u003e int: def dfs(grid, i, j): if not 0 \u003c= i \u003c len(grid) or not 0 \u003c= j \u003c len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' dfs(grid, i + 1, j) dfs(grid, i, j + 1) dfs(grid, i - 1, j) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:5:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"摩尔投票法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:6:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"面试题17.10.主要元素 思路： 若数组里只有一个数字，直接返回； 对数组进行排序后，若两个相差一半长度的元素相等，则该元素就是主要元素； 若遍历到一半还没出现，则证明没有主要元素。 var majorityElement = function(nums) { l = parseInt(nums.length/2); if(!l){ return nums[0]; } nums.sort(); for(let i = 0; i \u003c= l; i++){ if(nums[i] == nums[i+l]){ return nums[i]; } } return -1; }; 时间复杂度：O(nlogn)。排序复杂度超出了要求 空间复杂度：O(1)，没有用到多余的空间 执行用时：72ms，击败了94.35%的用户 内存消耗：42.2MB，击败了10.63%的用户 官方题解： Boyer-Moore投票算法 Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。 该题中表现为：遍历到x时，若count为0，则先将x的值赋给candidate；接下去若遇到不相同的，count–，遇到相同的，count++，若count为0，重新赋值。因此遍历一遍过后，如果数组nums 中存在主要元素，则candidate 即为主要元素，否则candidate 可能为数组中的任意一个元素。 因此需要二次遍历，看candidate出现的次数是否大于l/2。 【主要元素出现次数大于其他元素出现次数之和】 【== 和 === 的区别： == 会先将两边的值进行强制类型转换】 null == undefined //true null === undefined //false 55 == '55' //true 55 === '55' //false //因此推荐使用=== var majorityElement = function(nums) { let candidate = -1; //候选主要元素，初始可以是任意值 let count = 0; //候选主要元素出现的次数 for (const num of nums) { if (count === 0) { candidate = num; } if (num === candidate) { count++; } else { count--; } } count = 0; const length = nums.length; for (const num of nums) { if (num === candidate) { count++; } } return count * 2 \u003e length ? candidate : -1; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:6:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"双指针 || 滑动窗口 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"3. 无重复字符的最长字串 思路 最初的思路是，用两重循环，以数组每个元素为起点都做一次最大长度，保留最大 后面发现这样会超时(O(N^2)) 改进成：遇到一个重复元素，则将pre中的该重复元素及其之前的元素截取掉 var lengthOfLongestSubstring = function(s) { let pre = [], counts = 0; let len = s.length; for(let i = 0; i \u003c len; i++){ let index = pre.indexOf(s[i]); if(index !== -1){ pre.splice(0,(index + 1)); //截取数组，把前面的重复元素及其之前的元素删掉 } pre.push(s[i]); counts = Math.max(counts,pre.length); } return counts; }; 时间复杂度：O(n)，遍历一次 空间复杂度：O(∣Σ∣)，最坏情况全不重复，则最长是所有字符的合集128 执行用时：76ms，击败了99.90%的用户 内存消耗：41.4MB，击败了71.54%的用户 官方题解 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i \u003c n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 \u003c n \u0026\u0026 !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }; 该做法称为“滑动窗口” 使用两个指针表示字符串的某个子串（窗口）的左右边界 每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，记下长度 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"26.删除有序数组中的重复元素 思路： 因为数组是有序的，所以遍历数组，当某元素和前一个元素不等，则代表它没出现过，把他放到第n个位置，n为出现过的元素个数 var removeDuplicates = function(nums) { let len = nums.length; let res = 0; for(let i=0; i\u003clen; i++){ if(nums[i+1] != nums[i]){ res++; nums[res] = nums[i+1]; } } return res; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解： 快慢指针，实际思想与自己无异 var removeDuplicates = function(nums) { const n = nums.length; if (n === 0) { return 0; } let fast = 1, slow = 1; while (fast \u003c n) { if (nums[fast] !== nums[fast - 1]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"27.移除指定元素 思路： 跟26题几乎一样，不一样的只是res的起点 var removeElement = function(nums, val) { let res = 0; let len = nums.length; for(let i=0; i\u003clen; i++){ if(nums[i] !== val){ nums[res++] = nums[i]; } } return res; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：64ms，击败了99.51%的用户 内存消耗：38MB，击败了32.95%的用户 官方题解： 除了快慢指针，还可以使用左右指针，在val元素数量小时很有效，避免了需要保留的元素的重复赋值操作。 var removeElement = function(nums, val) { let left = 0, right = nums.length; while (left \u003c right) { if (nums[left] === val) { nums[left] = nums[right - 1]; right--; } else { left++; } } return left; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"剑指offer52 两个链表的第一个公共节点 官方题解 var getIntersectionNode = function(headA, headB) { if(headA===null || headB===null){ return null; } /* 有一个为空，则没有交集 */ let pA = headA; let pB = headB; while(pA!==pB){ /* 当他们没有相遇 */ pA = (pA===null) ? headB : pA.next; pB = (pB===null) ? headA : pB.next; } return pA; }; 有点没看懂问什么＋刚搬完寝室无心学习，直接看官方题解了 也属于双指针题目，但特殊的是，由于公共节点离两个头结点的位置是不同的，所以只遍历一遍自身是不够的，需要遍历完自身（若此时还没找到），再去从另一个的头结点处开始遍历，当两边都这么做，就能保证：若有公共节点，则同时停在公共节点处，也就意味着可以返回这个节点。若没有，则会同时处于null（两边都刚好遍历了lenA+lenB） ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"141. 环形链表 思路 val值有限定范围 小聪明，但值得注意的是，面试时应先问清楚面试官题目细节，如果刻意透露了限定条件，则利用反而会加分 var hasCycle = function(head) { while(head){ if(head.val==100001){ return true; } else{ head.val = 100001; } head = head.next; } return false; }; 快慢指针，快的一次走两步，慢的一次走一步，快的能反过来追上慢的就有环 var hasCycle = function(head) { if(head==null || head.next==null){ //没环 return false; } let fast = head.next, slow = head; while(fast){ //如果没环，fast会先到尾 if(fast == slow){ return true; } if(fast.next==null){ return false; } fast = fast.next.next; slow = slow.next; } return false; }; 时间复杂度：O(n) 空间复杂度：O(1) 执行用时：76ms，击败了99.22%的用户 内存消耗：40.2MB，击败了47.62%的用户 官方题解 哈希表，用集合存储访问过的节点 快慢指针 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:5","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"611. 有效三角形的个数 思路 暴力 var triangleNumber = function(nums) { nums.sort((a, b) =\u003e a - b); /* sort方法仅适用于字符串，对数字需要这样操作 */ let len = nums.length; let res = 0; for(let i = 0; i \u003c len - 2; i++){ if(nums[i] \u003c= 0){ continue; /* 三角形边长都是正数 */ } for(let j = i + 1; j \u003c len - 1; j++){ for(let k = j + 1; k \u003c len; k++){ if(nums[i] + nums[j] \u003e nums[k]){ res++; } else{ break; } } } } return res; }; 时间复杂度：O(N3) 执行用时：852ms，击败了23.08%的用户 内存消耗：39.4MB，击败了70.33%的用户 官方题解 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:6","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"881. 救生艇 思路： 重点是每艘船只能载1或2人 排序，最轻的和最重的加，若不大于limit，左边指针后移一位 每次循环都将右指针前移一位，船数也加一 var numRescueBoats = function(people, limit) { let res = 0; people.sort((a,b) =\u003e (a-b)); let left = 0, right = people.length - 1; while(left \u003c= right) { if(people[left] + people[right] \u003c= limit) { left++; } right--; res++; } return res; }; 时间复杂度：O(nlogn) 排序 空间复杂度：O(1) 执行用时：152ms，击败了93.16%的用户 内存消耗：45.5MB，击败了36.32%的用户 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:7","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"15. 三数之和 思路： 此题的重点是，不能存在重复的三元组 要找到和为0的三元组，自然地想到需要先进行排序。排序后找第一个元素，这个元素的特点是不能和前一个元素相等，这也就保证了每个三元组的最小值不会相等，初步保证不会重复 接下去的操作类似于之前的两数之和题目，使用双指针来寻找，对于左指针指向的元素，拥有和对第一个元素一样的约束，这样也保证了第二个元素不会在第二个位置重复使用 当前两个确定后，由于和是0是固定的，第三个只需要正常寻找就可以 var threeSum = function(nums) { let res = []; nums.sort((a,b)=\u003e(a-b)); // 排序数组 for(let i = 0; i \u003c nums.length - 2; i++) { // 最后两个数不可能是三元组内第一个元素 if(i \u003e 0 \u0026\u0026 nums[i-1] === nums[i]) continue; // 确保第一个位置不重复 let first = nums[i]; let left = i + 1, right = nums.length - 1; while(left \u003c right) { let second = nums[left], third = nums[right]; if(first + second + third === 0) { res.push([first, second, third]); // 确保第二个位置不重复 while(1) { left++; if(nums[left] !== nums[left-1] || left \u003e= right) { break; } } } else if(first + second + third \u003c 0) left++; else right--; } } return res; }; 时间复杂度：O(n^2) 空间复杂度：O(logn) 执行用时：136ms，击败了83.01%的用户 内存消耗：6MB，击败了34.90%的用户 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:7:8","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"基础线性表 || 矩阵 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"2. 两数相加 思路 用carry表示进位 head代表头结点，尾结点往后走到l1、l2都为空 如果用一个为空，另一个还未到结束，则空的那部分都是0 var addTwoNumbers = function(l1, l2) { let carry = 0; /* 第一次一定没有进位 */ let head = null, tail = null; while(l1 || l2){ const num1 = l1 ? l1.val : 0; const num2 = l2 ? l2.val : 0; const sum = num1 + num2 + carry; if(!head){ head = tail = new ListNode(sum % 10); } else{ tail.next = new ListNode(sum % 10); tail = tail.next; } carry = (sum \u003e= 10) ? 1 : 0; if(l1){ l1 = l1.next; } if(l2){ l2=l2.next; } } if(carry == 1){ tail.next = new ListNode(1); tail = tail.next; } return head; }; 时间复杂度：O(max(m,n)) 空间复杂度：O(1) 执行用时：96ms，击败了99.90%的用户 内存消耗：43.2MB，击败了32.54%的用户 官方题解 一样 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"21.合并两个有序链表 思路： 创建结点head和tail 先判断是否都不为空，若有一个为空则返回另一个，都为空则直接返回空结点 都不为空的话，head指向小的那个list，然后进入while循环，根据val值决定tail延伸方向，有一个为空即跳出循环 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ struct ListNode *head, *tail; if(l1 \u0026\u0026 l2){ if(l1-\u003eval \u003c l2-\u003eval){ head = l1; l1 = l1-\u003enext; } else{ head = l2; l2 = l2-\u003enext; } tail = head; while(l1 \u0026\u0026 l2){ if(l1-\u003eval\u003cl2-\u003eval){ tail-\u003enext = l1; l1 = l1-\u003enext; } else{ tail-\u003enext = l2; l2 = l2-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = l1?l1:l2; } else if(l1){ return l1; } else if(l2){ return l2; } return head; } 时间复杂度：O(n+m) 空间复杂度：O(n+m) 执行用时：4ms，击败了90.26%的用户 内存消耗：6MB，击败了59.92%的用户 官方递归解法： struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-\u003eval \u003c l2-\u003eval){ l1-\u003enext = mergeTwoLists(l1-\u003enext,l2); return l1; }else{ l2-\u003enext = mergeTwoLists(l1,l2-\u003enext); return l2; } } 递归： 必须要有边界条件，否则递归无法停止将会出错 递归函数通过不断调用自身，直至遇到边界条件后进行回溯，返回最终答案。 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"448.找到消失的数字 思路： 数字大小都在区间[1,n]内，项数范围是[0,n-1] 则每个元素的绝对值减去1，就代表其中一个项的位置 把该位置的元素变为负值 则仍未正数的元素的下标，就是代表没有出现的数字 - 1 var findDisappearedNumbers = function(nums) { len = nums.length; //获取数组长度 var res = new Array(); //存放答案的新数组 for(let i=0;i\u003clen;i++){ let num = Math.abs(nums[i]) - 1; //项数 if(nums[num] \u003e 0){ nums[num] *= -1; //包含的项变负 } } for(let i=0;i\u003clen;i++){ if(nums[i]\u003e0){ res.push(i+1); //添加正数 } } return res; }; 时间复杂度：O(n) 空间复杂度：符合题目要求，除了返回的数组以外不占用其他空间 执行用时：112ms，击败了97.43%的用户 内存消耗：45.2MB，击败了99.32%的用户 官方题解的做法： 每遇到一次x，就让nums[x-1]加上n，最后数组里仍处在[1,n]范围内的项，下标加一就是消失的数字。 var findDisappearedNumbers = function(nums) { const n = nums.length; for (const num of nums) { const x = (num - 1) % n; // %n很重要 nums[x] += n; } const ret = []; for (const [i, num] of nums.entries()) { if (num \u003c= n) { ret.push(i + 1); } } return ret; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"54. 螺旋矩阵 思路： 一层层剥开矩阵，用矩阵的四个边界控制，每走一圈（每剥开一层），矩阵缩小一次 var spiralOrder = function(matrix) { const rows = matrix.length; /* 行数 */ const columns = matrix[0].length; /* 列数 */ let res = []; if(rows==0 || columns==0){ return res; } let left = 0, right = columns - 1, top = 0, bottom = rows - 1; while(left\u003c=right \u0026\u0026 top\u003c=bottom){ for(let j=left; j\u003c=right; j++){ res.push(matrix[top][j]); } for(let i=top+1; i\u003c=bottom; i++){ res.push(matrix[i][right]); } if(left\u003cright \u0026\u0026 top\u003cbottom){ for(let j=right-1; j\u003eleft; j--){ res.push(matrix[bottom][j]); } for(let i=bottom; i\u003etop; i--){ res.push(matrix[i][left]); } } [left,right,top,bottom] = [left + 1, right - 1, top + 1, bottom - 1]; } return res; }; 时间复杂度：O(mn)，遍历矩阵 空间复杂度：O(1)，除了返回的数组，没有用到多余空间 执行用时：60ms，击败了99.00%的用户 内存消耗：37.7MB，击败了48.38%的用户 官方题解： 一样 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:8:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"贪心 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:9:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1736. 替换隐藏数字得到的最晚时间 思路: 从第一位开始判断：因为第一位最重要，直接if else枚举 var maximumTime = function(time) { const arr = Array.from(time); //Array.from:从一个类似数组或可迭代对象创建一个新的、浅拷贝的数组实例 if(arr[0]=='?'){ if(arr[1]\u003c=4 || arr[1]=='?'){ arr[0] = 2; } else{ arr[0] = 1; } } if(arr[1]=='?'){ if(arr[0]=='?' || arr[1]==2){ arr[1] = 4; } else{ arr[1] = 9; } } if(arr[3]=='?'){ arr[3] = 5; } if(arr[4]=='?'){ arr[4] = 9; } return arr.join(''); //用join方法来将各元素连接 }; 时间复杂度：O(1) 空间复杂度：O(1) 执行用时：72ms，击败了90.00%的用户 内存消耗：37.8MB，击败了84.00%的用户 官方题解 var maximumTime = function(time) { const arr = Array.from(time); if (arr[0] === '?') { arr[0] = ('4' \u003c= arr[1] \u0026\u0026 arr[1] \u003c= '9') ? '1' : '2'; } if (arr[1] === '?') { arr[1] = (arr[0] == '2') ? '3' : '9'; } if (arr[3] === '?') { arr[3] = '5'; } if (arr[4] === '?') { arr[4] = '9'; } return arr.join(''); }; 思路一致，官方代码利用正则表达式，更加简洁 贪心算法：是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优算法 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:9:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"哈希表 ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:0","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"705. 设计哈希集合 var MyHashSet = function() { this.BASE = 769; // 哈希函数用的取模方法，选取一个较大质数 this.data = new Array(this.BASE).fill(0).map(() =\u003e new Array()); }; MyHashSet.prototype.add = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { return; // 已经存在，不添加 } } it.push(key); }; MyHashSet.prototype.remove = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { it.splice(i, 1); // 删除 return; } } }; MyHashSet.prototype.contains = function(key) { const h = key % this.BASE; const it = this.data[h]; for(let i = 0; i \u003c it.length; i++) { if(it[i] === key) { return true; } } return false; } ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:1","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"706. 设计哈希映射 var MyHashMap = function() { this.BASE = 769; this.data = new Array(this.BASE).fill(0).map(() =\u003e new Array()); }; MyHashMap.prototype.put = function(key, value) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { it[1] = value; return; } } this.data[h].push([key, value]); }; MyHashMap.prototype.get = function(key) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { return it[1]; } } return -1 }; MyHashMap.prototype.remove = function(key) { const h = this.hash(key); for(let it of this.data[h]) { if(it[0] === key) { this.data[h].splice(this.data[h].indexOf(it), 1); return; } } }; MyHashMap.prototype.hash = function(key) { return key % this.BASE; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:2","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"1.两数之和 思路： 暴力，双重循环 哈希表 var twoSum = function(nums, target) { let hashMap = {}; for(let i = 0; i \u003c nums.length; i++){ if(hashMap[target - nums[i]] !== undefined){ return [i, hashMap[target - nums[i]]]; } hashMap[nums[i]] = i; //存放的是该元素的索引值 } return []; }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:3","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":["Program"],"content":"128. 最长连续子序列 思路： 因为时间复杂度要求为O(n)，所以不能使用排序算法。而很自然就想到应该使用哈希表来解决这个问题let hashNums = new Set(nums) 得到这样一个集合后，对于在数组内的元素，我们查找它的左邻居(比它小1的数字)是否在集合里，若在则长度加一，并保存长度然后从它的右邻居开始找，直到它的右邻居不在集合里 var longestConsecutive = function(nums) { res = 0 let myHash = new Set(nums) for(let num of myHash) { if(!myHash.has(num - 1)) { let currentNum = num let currentLen = 1 while(myHash.has(currentNum + 1)) { currentNum++ currentLen++ } res = Math.max(res, currentLen) } } return res }; ","date":"2021-09-05","objectID":"https://MichaelYuhe.github.io/leetcode/:10:4","tags":["learning","leetcode"],"title":"持续更新的LeetCode笔记","uri":"https://MichaelYuhe.github.io/leetcode/"},{"categories":null,"content":"字节跳动一面 个人 学习路线 怎么学的 有看什么网站么 讲一下最近看到的一个知识点 专业 学了啥 排名 项目 小游戏讲讲 3D怎么做的 算法 setTimeout实现setInterval 最长不重复子串 合并已排序数组 CSS position 选择器 有哪些 优先级 网络 http http2 https tcp和udp 用过哪些方法，讲讲什么时候用的 操作系统 进程和线程 vue 通信方式 vue2和vue3的区别 浏览器 存储 localstorage等，啥时候用的，用来干啥了 进程和线程 ","date":"0001-01-01","objectID":"https://MichaelYuhe.github.io/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2/:1:0","tags":null,"title":"","uri":"https://MichaelYuhe.github.io/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2/"}]